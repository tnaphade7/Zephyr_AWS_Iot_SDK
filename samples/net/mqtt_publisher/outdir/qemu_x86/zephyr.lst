
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  100000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  100003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  100008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  10000b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
  10000c:	0f 01 15 80 00 10 00 	lgdtl  0x100080
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  100013:	0f 01 1d 69 00 10 00 	lidtl  0x100069


#ifdef CONFIG_SET_GDT
	/* If we set our own GDT, update the segment registers as well.
	 */
	movw	$0x10, %ax	/* data segment selector (entry = 3) */
  10001a:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
  10001e:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
  100020:	8e c0                	mov    %eax,%es
	movw	%ax, %fs	/* set FS */
  100022:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* set GS */
  100024:	8e e8                	mov    %eax,%gs
	movw	%ax, %ss	/* set SS */
  100026:	8e d0                	mov    %eax,%ss

	ljmp	$0x08, $__csSet	/* set CS = 0x08 */
  100028:	ea 2f 00 10 00 08 00 	ljmp   $0x8,$0x10002f

0010002f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  10002f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  100032:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  100035:	0f 22 c0             	mov    %eax,%cr0
	 * interfering with interrupt handler use of this stack.
	 * If it is a cold boot then _sys_soc_resume_from_deep_sleep() should
	 * not do anything and must return immediately.
	 */
#ifdef CONFIG_INIT_STACKS
	movl $0xAAAAAAAA, %eax
  100038:	b8 aa aa aa aa       	mov    $0xaaaaaaaa,%eax
	leal _interrupt_stack, %edi
  10003d:	8d 3d a0 bb 10 00    	lea    0x10bba0,%edi
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
  100043:	b9 00 02 00 00       	mov    $0x200,%ecx
	rep  stosl
  100048:	f3 ab                	rep stos %eax,%es:(%edi)
#endif

	movl	$_interrupt_stack, %esp
  10004a:	bc a0 bb 10 00       	mov    $0x10bba0,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  10004f:	81 c4 00 08 00 00    	add    $0x800,%esp

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  100055:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  100057:	bf 80 93 10 00       	mov    $0x109380,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  10005c:	b9 0c 02 00 00       	mov    $0x20c,%ecx
	cld
  100061:	fc                   	cld    
	rep
  100062:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  100064:	e9 23 6d 00 00       	jmp    106d8c <_Cstart>

00100069 <_Idt>:
  100069:	ff 07 50 84 10 00 90 02 b0 ad 1b 00 00 00 00 fe     ..P.............
  100079:	4f 52 e4 8d 74 26 00                                OR..t&.

00100080 <_gdt>:
  100080:	17 00 80 00 10 00 00 00 ff ff 00 00 00 9b cf 00     ................
  100090:	ff ff 00 00 00 93 cf 00                             ........

00100098 <_gdt_rom_end>:
  100098:	66 90                	xchg   %ax,%ax
  10009a:	66 90                	xchg   %ax,%ax
  10009c:	66 90                	xchg   %ax,%ax
  10009e:	66 90                	xchg   %ax,%ax

001000a0 <__udivdi3>:
  1000a0:	55                   	push   %ebp
  1000a1:	57                   	push   %edi
  1000a2:	56                   	push   %esi
  1000a3:	53                   	push   %ebx
  1000a4:	83 ec 1c             	sub    $0x1c,%esp
  1000a7:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  1000ab:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  1000af:	8b 7c 24 38          	mov    0x38(%esp),%edi
  1000b3:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  1000b7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1000bb:	89 ca                	mov    %ecx,%edx
  1000bd:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1000c1:	85 f6                	test   %esi,%esi
  1000c3:	75 3b                	jne    100100 <__udivdi3+0x60>
  1000c5:	39 cf                	cmp    %ecx,%edi
  1000c7:	0f 87 c3 00 00 00    	ja     100190 <__udivdi3+0xf0>
  1000cd:	89 fd                	mov    %edi,%ebp
  1000cf:	85 ff                	test   %edi,%edi
  1000d1:	75 0b                	jne    1000de <__udivdi3+0x3e>
  1000d3:	b8 01 00 00 00       	mov    $0x1,%eax
  1000d8:	31 d2                	xor    %edx,%edx
  1000da:	f7 f7                	div    %edi
  1000dc:	89 c5                	mov    %eax,%ebp
  1000de:	89 c8                	mov    %ecx,%eax
  1000e0:	31 d2                	xor    %edx,%edx
  1000e2:	f7 f5                	div    %ebp
  1000e4:	89 c1                	mov    %eax,%ecx
  1000e6:	89 d8                	mov    %ebx,%eax
  1000e8:	89 cf                	mov    %ecx,%edi
  1000ea:	f7 f5                	div    %ebp
  1000ec:	89 fa                	mov    %edi,%edx
  1000ee:	83 c4 1c             	add    $0x1c,%esp
  1000f1:	5b                   	pop    %ebx
  1000f2:	5e                   	pop    %esi
  1000f3:	5f                   	pop    %edi
  1000f4:	5d                   	pop    %ebp
  1000f5:	c3                   	ret    
  1000f6:	8d 76 00             	lea    0x0(%esi),%esi
  1000f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100100:	39 ce                	cmp    %ecx,%esi
  100102:	77 7c                	ja     100180 <__udivdi3+0xe0>
  100104:	0f bd fe             	bsr    %esi,%edi
  100107:	83 f7 1f             	xor    $0x1f,%edi
  10010a:	0f 84 90 00 00 00    	je     1001a0 <__udivdi3+0x100>
  100110:	bd 20 00 00 00       	mov    $0x20,%ebp
  100115:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  100119:	29 fd                	sub    %edi,%ebp
  10011b:	89 f9                	mov    %edi,%ecx
  10011d:	d3 e6                	shl    %cl,%esi
  10011f:	89 d8                	mov    %ebx,%eax
  100121:	89 e9                	mov    %ebp,%ecx
  100123:	d3 e8                	shr    %cl,%eax
  100125:	09 f0                	or     %esi,%eax
  100127:	89 f9                	mov    %edi,%ecx
  100129:	89 44 24 08          	mov    %eax,0x8(%esp)
  10012d:	89 d8                	mov    %ebx,%eax
  10012f:	d3 e0                	shl    %cl,%eax
  100131:	89 d3                	mov    %edx,%ebx
  100133:	89 e9                	mov    %ebp,%ecx
  100135:	d3 eb                	shr    %cl,%ebx
  100137:	89 f9                	mov    %edi,%ecx
  100139:	89 de                	mov    %ebx,%esi
  10013b:	d3 e2                	shl    %cl,%edx
  10013d:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  100141:	89 e9                	mov    %ebp,%ecx
  100143:	d3 eb                	shr    %cl,%ebx
  100145:	09 da                	or     %ebx,%edx
  100147:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10014b:	89 d0                	mov    %edx,%eax
  10014d:	89 f2                	mov    %esi,%edx
  10014f:	f7 74 24 08          	divl   0x8(%esp)
  100153:	89 d6                	mov    %edx,%esi
  100155:	89 c3                	mov    %eax,%ebx
  100157:	f7 64 24 0c          	mull   0xc(%esp)
  10015b:	39 d6                	cmp    %edx,%esi
  10015d:	72 10                	jb     10016f <__udivdi3+0xcf>
  10015f:	8b 6c 24 04          	mov    0x4(%esp),%ebp
  100163:	89 f9                	mov    %edi,%ecx
  100165:	d3 e5                	shl    %cl,%ebp
  100167:	39 c5                	cmp    %eax,%ebp
  100169:	73 55                	jae    1001c0 <__udivdi3+0x120>
  10016b:	39 d6                	cmp    %edx,%esi
  10016d:	75 51                	jne    1001c0 <__udivdi3+0x120>
  10016f:	8d 43 ff             	lea    -0x1(%ebx),%eax
  100172:	31 ff                	xor    %edi,%edi
  100174:	89 fa                	mov    %edi,%edx
  100176:	83 c4 1c             	add    $0x1c,%esp
  100179:	5b                   	pop    %ebx
  10017a:	5e                   	pop    %esi
  10017b:	5f                   	pop    %edi
  10017c:	5d                   	pop    %ebp
  10017d:	c3                   	ret    
  10017e:	66 90                	xchg   %ax,%ax
  100180:	31 ff                	xor    %edi,%edi
  100182:	31 c0                	xor    %eax,%eax
  100184:	89 fa                	mov    %edi,%edx
  100186:	83 c4 1c             	add    $0x1c,%esp
  100189:	5b                   	pop    %ebx
  10018a:	5e                   	pop    %esi
  10018b:	5f                   	pop    %edi
  10018c:	5d                   	pop    %ebp
  10018d:	c3                   	ret    
  10018e:	66 90                	xchg   %ax,%ax
  100190:	89 d8                	mov    %ebx,%eax
  100192:	f7 f7                	div    %edi
  100194:	31 ff                	xor    %edi,%edi
  100196:	89 fa                	mov    %edi,%edx
  100198:	83 c4 1c             	add    $0x1c,%esp
  10019b:	5b                   	pop    %ebx
  10019c:	5e                   	pop    %esi
  10019d:	5f                   	pop    %edi
  10019e:	5d                   	pop    %ebp
  10019f:	c3                   	ret    
  1001a0:	39 ce                	cmp    %ecx,%esi
  1001a2:	72 10                	jb     1001b4 <__udivdi3+0x114>
  1001a4:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  1001a8:	31 c0                	xor    %eax,%eax
  1001aa:	39 5c 24 08          	cmp    %ebx,0x8(%esp)
  1001ae:	0f 87 38 ff ff ff    	ja     1000ec <__udivdi3+0x4c>
  1001b4:	b8 01 00 00 00       	mov    $0x1,%eax
  1001b9:	e9 2e ff ff ff       	jmp    1000ec <__udivdi3+0x4c>
  1001be:	66 90                	xchg   %ax,%ax
  1001c0:	89 d8                	mov    %ebx,%eax
  1001c2:	31 ff                	xor    %edi,%edi
  1001c4:	e9 23 ff ff ff       	jmp    1000ec <__udivdi3+0x4c>

001001c9 <publish_cb>:
 * unknown pkt_id, this routine must return an error, for example -EINVAL or
 * any negative value.
 */
static int publish_cb(struct mqtt_ctx *mqtt_ctx, uint16_t pkt_id,
		      enum mqtt_packet type)
{
  1001c9:	55                   	push   %ebp
  1001ca:	89 e5                	mov    %esp,%ebp
  1001cc:	53                   	push   %ebx
  1001cd:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1001d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1001d3:	8d 51 fc             	lea    -0x4(%ecx),%edx
  1001d6:	83 fa 03             	cmp    $0x3,%edx
  1001d9:	77 10                	ja     1001eb <publish_cb+0x22>
  1001db:	8b 14 95 7c 80 10 00 	mov    0x10807c(,%edx,4),%edx
  1001e2:	0f be 99 4c 80 10 00 	movsbl 0x10804c(%ecx),%ebx
  1001e9:	eb 0a                	jmp    1001f5 <publish_cb+0x2c>
  1001eb:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
  1001f0:	ba 40 7e 10 00       	mov    $0x107e40,%edx
	default:
		rc = -EINVAL;
		str = "Invalid MQTT packet";
	}

	printk("[%s:%d] <%s> packet id: %u", __func__, __LINE__, str, pkt_id);
  1001f5:	0f b7 c0             	movzwl %ax,%eax
  1001f8:	50                   	push   %eax
  1001f9:	52                   	push   %edx
  1001fa:	68 94 00 00 00       	push   $0x94
  1001ff:	68 c8 80 10 00       	push   $0x1080c8
  100204:	68 54 7e 10 00       	push   $0x107e54
  100209:	e8 aa 17 00 00       	call   1019b8 <printk>

	if (client_ctx->publish_data) {
  10020e:	8b 45 08             	mov    0x8(%ebp),%eax
	printk("[%s:%d] <%s> packet id: %u", __func__, __LINE__, str, pkt_id);
  100211:	83 c4 14             	add    $0x14,%esp
	if (client_ctx->publish_data) {
  100214:	8b 40 34             	mov    0x34(%eax),%eax
  100217:	85 c0                	test   %eax,%eax
  100219:	74 0d                	je     100228 <publish_cb+0x5f>
		printk(", user_data: %s",
  10021b:	50                   	push   %eax
  10021c:	68 6f 7e 10 00       	push   $0x107e6f
  100221:	e8 92 17 00 00       	call   1019b8 <printk>
  100226:	5a                   	pop    %edx
  100227:	59                   	pop    %ecx
		       (const char *)client_ctx->publish_data);
	}

	printk("\n");
  100228:	68 4d 80 10 00       	push   $0x10804d
  10022d:	e8 86 17 00 00       	call   1019b8 <printk>
  100232:	58                   	pop    %eax

	return rc;
}
  100233:	89 d8                	mov    %ebx,%eax
  100235:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  100238:	c9                   	leave  
  100239:	c3                   	ret    

0010023a <malformed_cb>:
/**
 * The signature of this routine must match the malformed callback declared at
 * the mqtt.h header.
 */
static void malformed_cb(struct mqtt_ctx *mqtt_ctx, uint16_t pkt_type)
{
  10023a:	55                   	push   %ebp
  10023b:	89 e5                	mov    %esp,%ebp
	printk("[%s:%d] pkt_type: %u\n", __func__, __LINE__, pkt_type);
  10023d:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  100241:	50                   	push   %eax
  100242:	68 a6 00 00 00       	push   $0xa6
  100247:	68 b8 80 10 00       	push   $0x1080b8
  10024c:	68 7f 7e 10 00       	push   $0x107e7f
  100251:	e8 62 17 00 00       	call   1019b8 <printk>
  100256:	83 c4 10             	add    $0x10,%esp
}
  100259:	c9                   	leave  
  10025a:	c3                   	ret    

0010025b <disconnect_cb>:
{
  10025b:	55                   	push   %ebp
  10025c:	89 e5                	mov    %esp,%ebp
  10025e:	53                   	push   %ebx
	printk("[%s:%d]", __func__, __LINE__);
  10025f:	6a 65                	push   $0x65
  100261:	68 a8 80 10 00       	push   $0x1080a8
{
  100266:	8b 5d 08             	mov    0x8(%ebp),%ebx
	printk("[%s:%d]", __func__, __LINE__);
  100269:	68 95 7e 10 00       	push   $0x107e95
  10026e:	e8 45 17 00 00       	call   1019b8 <printk>
  100273:	83 c4 0c             	add    $0xc,%esp
	if (client_ctx->disconnect_data) {
  100276:	8b 43 30             	mov    0x30(%ebx),%eax
  100279:	85 c0                	test   %eax,%eax
  10027b:	74 0d                	je     10028a <disconnect_cb+0x2f>
		printk(" user_data: %s",
  10027d:	50                   	push   %eax
  10027e:	68 70 7e 10 00       	push   $0x107e70
  100283:	e8 30 17 00 00       	call   1019b8 <printk>
  100288:	58                   	pop    %eax
  100289:	5a                   	pop    %edx
}
  10028a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	printk("\n");
  10028d:	c7 45 08 4d 80 10 00 	movl   $0x10804d,0x8(%ebp)
}
  100294:	c9                   	leave  
	printk("\n");
  100295:	e9 1e 17 00 00       	jmp    1019b8 <printk>

0010029a <connect_cb>:
{
  10029a:	55                   	push   %ebp
  10029b:	89 e5                	mov    %esp,%ebp
  10029d:	53                   	push   %ebx
	printk("[%s:%d]", __func__, __LINE__);
  10029e:	6a 52                	push   $0x52
  1002a0:	68 9c 80 10 00       	push   $0x10809c
{
  1002a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	printk("[%s:%d]", __func__, __LINE__);
  1002a8:	68 95 7e 10 00       	push   $0x107e95
  1002ad:	e8 06 17 00 00       	call   1019b8 <printk>
  1002b2:	83 c4 0c             	add    $0xc,%esp
	if (client_ctx->connect_data) {
  1002b5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  1002b8:	85 c0                	test   %eax,%eax
  1002ba:	74 0d                	je     1002c9 <connect_cb+0x2f>
		printk(" user_data: %s",
  1002bc:	50                   	push   %eax
  1002bd:	68 70 7e 10 00       	push   $0x107e70
  1002c2:	e8 f1 16 00 00       	call   1019b8 <printk>
  1002c7:	58                   	pop    %eax
  1002c8:	5a                   	pop    %edx
}
  1002c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	printk("\n");
  1002cc:	c7 45 08 4d 80 10 00 	movl   $0x10804d,0x8(%ebp)
}
  1002d3:	c9                   	leave  
	printk("\n");
  1002d4:	e9 df 16 00 00       	jmp    1019b8 <printk>

001002d9 <prepare_mqtt_publish_msg.constprop.2>:
#else
	return "sensors";
#endif
}

static void prepare_mqtt_publish_msg(struct mqtt_publish_msg *pub_msg,
  1002d9:	55                   	push   %ebp
  1002da:	89 e5                	mov    %esp,%ebp
  1002dc:	53                   	push   %ebx
  1002dd:	89 c3                	mov    %eax,%ebx
	payload[strlen(payload) - 1] = '0' + qos;
  1002df:	68 d0 8c 10 00       	push   $0x108cd0
  1002e4:	e8 e9 10 00 00       	call   1013d2 <strlen>
				     enum mqtt_qos qos)
{
	/* MQTT message payload may be anything, we we use C strings */
	pub_msg->msg = get_mqtt_payload(qos);
	/* Payload's length */
	pub_msg->msg_len = strlen(client_ctx.pub_msg.msg);
  1002e9:	c7 04 24 d0 8c 10 00 	movl   $0x108cd0,(%esp)
	payload[strlen(payload) - 1] = '0' + qos;
  1002f0:	8d 53 30             	lea    0x30(%ebx),%edx
	pub_msg->msg = get_mqtt_payload(qos);
  1002f3:	c7 05 c8 93 10 00 d0 	movl   $0x108cd0,0x1093c8
  1002fa:	8c 10 00 
	payload[strlen(payload) - 1] = '0' + qos;
  1002fd:	88 90 cf 8c 10 00    	mov    %dl,0x108ccf(%eax)
	pub_msg->msg_len = strlen(client_ctx.pub_msg.msg);
  100303:	e8 ca 10 00 00       	call   1013d2 <strlen>
	/* MQTT Quality of Service */
	pub_msg->qos = qos;
	/* Message's topic */
	pub_msg->topic = get_mqtt_topic();
	pub_msg->topic_len = strlen(client_ctx.pub_msg.topic);
  100308:	c7 04 24 9d 7e 10 00 	movl   $0x107e9d,(%esp)
	pub_msg->qos = qos;
  10030f:	89 1d b8 93 10 00    	mov    %ebx,0x1093b8
	pub_msg->msg_len = strlen(client_ctx.pub_msg.msg);
  100315:	66 a3 cc 93 10 00    	mov    %ax,0x1093cc
	pub_msg->topic = get_mqtt_topic();
  10031b:	c7 05 c0 93 10 00 9d 	movl   $0x107e9d,0x1093c0
  100322:	7e 10 00 
	pub_msg->topic_len = strlen(client_ctx.pub_msg.topic);
  100325:	e8 a8 10 00 00       	call   1013d2 <strlen>
  10032a:	5a                   	pop    %edx
  10032b:	66 a3 c4 93 10 00    	mov    %ax,0x1093c4
	/* Packet Identifier, always use different values */
	pub_msg->pkt_id = sys_rand32_get();
  100331:	e8 6f 06 00 00       	call   1009a5 <sys_rand32_get>
}
  100336:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	pub_msg->pkt_id = sys_rand32_get();
  100339:	66 a3 be 93 10 00    	mov    %ax,0x1093be
}
  10033f:	c9                   	leave  
  100340:	c3                   	ret    

00100341 <main>:

	return rc;
}

void main(void)
{
  100341:	55                   	push   %ebp
  100342:	89 e5                	mov    %esp,%ebp
  100344:	57                   	push   %edi
  100345:	56                   	push   %esi
  100346:	53                   	push   %ebx
  100347:	83 ec 10             	sub    $0x10,%esp
	rc = net_addr_pton(AF_INET, addr, ptr);
  10034a:	8d 75 f0             	lea    -0x10(%ebp),%esi
	printk("Wait for network device to come up...\n");
  10034d:	68 ae 7e 10 00       	push   $0x107eae
  100352:	e8 61 16 00 00       	call   1019b8 <printk>
	k_sleep(K_SECONDS(6));
  100357:	c7 04 24 70 17 00 00 	movl   $0x1770,(%esp)
  10035e:	e8 7e 6f 00 00       	call   1072e1 <k_sleep>
	rc = net_addr_pton(AF_INET, addr, ptr);
  100363:	89 34 24             	mov    %esi,(%esp)
	net_sin(sock_addr)->sin_port = htons(port);
  100366:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
	rc = net_addr_pton(AF_INET, addr, ptr);
  10036c:	68 d5 7e 10 00       	push   $0x107ed5
	sock_addr->family = AF_INET;
  100371:	66 c7 45 ec 02 00    	movw   $0x2,-0x14(%ebp)
	rc = net_addr_pton(AF_INET, addr, ptr);
  100377:	6a 02                	push   $0x2
  100379:	e8 f0 33 00 00       	call   10376e <net_addr_pton>
  10037e:	83 c4 0c             	add    $0xc,%esp
	if (rc) {
  100381:	85 c0                	test   %eax,%eax
  100383:	74 1a                	je     10039f <main+0x5e>
		printk("Invalid IP address: %s\n", addr);
  100385:	68 d5 7e 10 00       	push   $0x107ed5
  10038a:	89 c3                	mov    %eax,%ebx
  10038c:	68 df 7e 10 00       	push   $0x107edf
  100391:	e8 22 16 00 00       	call   1019b8 <printk>
  100396:	59                   	pop    %ecx
  100397:	5e                   	pop    %esi
		printk("set_addr (local) error\n");
  100398:	68 f7 7e 10 00       	push   $0x107ef7
  10039d:	eb 39                	jmp    1003d8 <main+0x97>
	p = net_if_ipv4_addr_add(net_if_get_default(),
  10039f:	e8 e1 1b 00 00       	call   101f85 <net_if_get_default>
  1003a4:	6a 00                	push   $0x0
  1003a6:	6a 03                	push   $0x3
  1003a8:	56                   	push   %esi
  1003a9:	50                   	push   %eax
  1003aa:	e8 70 1c 00 00       	call   10201f <net_if_ipv4_addr_add>
  1003af:	83 c4 10             	add    $0x10,%esp
	if (!p) {
  1003b2:	85 c0                	test   %eax,%eax
  1003b4:	0f 84 c4 00 00 00    	je     10047e <main+0x13d>
	rc = net_context_get(family, SOCK_STREAM, IPPROTO_TCP, net_ctx);
  1003ba:	68 08 94 10 00       	push   $0x109408
  1003bf:	6a 06                	push   $0x6
  1003c1:	6a 02                	push   $0x2
  1003c3:	6a 02                	push   $0x2
  1003c5:	e8 7f 24 00 00       	call   102849 <net_context_get>
  1003ca:	83 c4 10             	add    $0x10,%esp
  1003cd:	89 c3                	mov    %eax,%ebx
	if (rc) {
  1003cf:	85 c0                	test   %eax,%eax
  1003d1:	74 0c                	je     1003df <main+0x9e>
		printk("net_context_get error\n");
  1003d3:	68 0f 7f 10 00       	push   $0x107f0f
  1003d8:	e8 db 15 00 00       	call   1019b8 <printk>
  1003dd:	eb 30                	jmp    10040f <main+0xce>
  1003df:	8d 7d ec             	lea    -0x14(%ebp),%edi
	rc = net_context_bind(*net_ctx, &local_sock, addr_len);
  1003e2:	6a 08                	push   $0x8
  1003e4:	57                   	push   %edi
  1003e5:	ff 35 08 94 10 00    	pushl  0x109408
  1003eb:	e8 ea 29 00 00       	call   102dda <net_context_bind>
  1003f0:	83 c4 0c             	add    $0xc,%esp
  1003f3:	89 c3                	mov    %eax,%ebx
	if (rc) {
  1003f5:	85 c0                	test   %eax,%eax
  1003f7:	74 19                	je     100412 <main+0xd1>
		printk("net_context_bind error\n");
  1003f9:	68 26 7f 10 00       	push   $0x107f26
		printk("net_context_connect error\n"
  1003fe:	e8 b5 15 00 00       	call   1019b8 <printk>
  100403:	5f                   	pop    %edi
	net_context_put(*net_ctx);
  100404:	ff 35 08 94 10 00    	pushl  0x109408
  10040a:	e8 1a 29 00 00       	call   102d29 <net_context_put>
  10040f:	5e                   	pop    %esi
  100410:	eb 71                	jmp    100483 <main+0x142>
	rc = net_addr_pton(AF_INET, addr, ptr);
  100412:	8d 45 e8             	lea    -0x18(%ebp),%eax
	net_sin(sock_addr)->sin_port = htons(port);
  100415:	66 c7 45 e6 07 5b    	movw   $0x5b07,-0x1a(%ebp)
	rc = net_addr_pton(AF_INET, addr, ptr);
  10041b:	50                   	push   %eax
	sock_addr->family = AF_INET;
  10041c:	66 c7 45 e4 02 00    	movw   $0x2,-0x1c(%ebp)
	rc = net_addr_pton(AF_INET, addr, ptr);
  100422:	68 3e 7f 10 00       	push   $0x107f3e
  100427:	6a 02                	push   $0x2
  100429:	e8 40 33 00 00       	call   10376e <net_addr_pton>
  10042e:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  100431:	83 c4 0c             	add    $0xc,%esp
  100434:	89 c3                	mov    %eax,%ebx
	if (rc) {
  100436:	85 c0                	test   %eax,%eax
  100438:	74 18                	je     100452 <main+0x111>
		printk("Invalid IP address: %s\n", addr);
  10043a:	68 3e 7f 10 00       	push   $0x107f3e
  10043f:	68 df 7e 10 00       	push   $0x107edf
  100444:	e8 6f 15 00 00       	call   1019b8 <printk>
  100449:	58                   	pop    %eax
  10044a:	5a                   	pop    %edx
		printk("set_addr (server) error\n");
  10044b:	68 48 7f 10 00       	push   $0x107f48
  100450:	eb ac                	jmp    1003fe <main+0xbd>
	rc = net_context_connect(*net_ctx, &server_sock, addr_len, NULL,
  100452:	6a 00                	push   $0x0
  100454:	68 f4 01 00 00       	push   $0x1f4
  100459:	6a 00                	push   $0x0
  10045b:	6a 08                	push   $0x8
  10045d:	56                   	push   %esi
  10045e:	ff 35 08 94 10 00    	pushl  0x109408
  100464:	e8 0d 2a 00 00       	call   102e76 <net_context_connect>
  100469:	83 c4 18             	add    $0x18,%esp
  10046c:	89 c3                	mov    %eax,%ebx
	PRINT_RESULT("network_setup", rc);
  10046e:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
	if (rc) {
  100473:	85 db                	test   %ebx,%ebx
  100475:	74 11                	je     100488 <main+0x147>
		printk("net_context_connect error\n"
  100477:	68 61 7f 10 00       	push   $0x107f61
  10047c:	eb 80                	jmp    1003fe <main+0xbd>
		return -EINVAL;
  10047e:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	PRINT_RESULT("network_setup", rc);
  100483:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  100488:	50                   	push   %eax
  100489:	53                   	push   %ebx
  10048a:	68 a3 7f 10 00       	push   $0x107fa3
  10048f:	68 f8 00 00 00       	push   $0xf8
  100494:	68 d4 80 10 00       	push   $0x1080d4
  100499:	68 b1 7f 10 00       	push   $0x107fb1
  10049e:	e8 15 15 00 00       	call   1019b8 <printk>
  1004a3:	83 c4 18             	add    $0x18,%esp
	if (rc != 0) {
  1004a6:	85 db                	test   %ebx,%ebx
  1004a8:	0f 85 f3 02 00 00    	jne    1007a1 <main+0x460>
	memset(&client_ctx, 0x00, sizeof(client_ctx));
  1004ae:	68 88 00 00 00       	push   $0x88
  1004b3:	6a 00                	push   $0x0
  1004b5:	68 80 93 10 00       	push   $0x109380
  1004ba:	e8 19 10 00 00       	call   1014d8 <memset>
  1004bf:	83 c4 0c             	add    $0xc,%esp
	client_ctx.mqtt_ctx.net_ctx = net_ctx;
  1004c2:	a1 08 94 10 00       	mov    0x109408,%eax
  1004c7:	a3 d0 93 10 00       	mov    %eax,0x1093d0
	client_ctx.mqtt_ctx.connect = connect_cb;
  1004cc:	c7 05 d8 93 10 00 9a 	movl   $0x10029a,0x1093d8
  1004d3:	02 10 00 
	rc = mqtt_init(&client_ctx.mqtt_ctx, MQTT_APP_PUBLISHER);
  1004d6:	6a 01                	push   $0x1
	client_ctx.mqtt_ctx.disconnect = disconnect_cb;
  1004d8:	c7 05 dc 93 10 00 5b 	movl   $0x10025b,0x1093dc
  1004df:	02 10 00 
	rc = mqtt_init(&client_ctx.mqtt_ctx, MQTT_APP_PUBLISHER);
  1004e2:	68 d0 93 10 00       	push   $0x1093d0
	client_ctx.mqtt_ctx.malformed = malformed_cb;
  1004e7:	c7 05 f0 93 10 00 3a 	movl   $0x10023a,0x1093f0
  1004ee:	02 10 00 
	client_ctx.mqtt_ctx.net_timeout = APP_TX_RX_TIMEOUT;
  1004f1:	c7 05 d4 93 10 00 2c 	movl   $0x12c,0x1093d4
  1004f8:	01 00 00 
	client_ctx.mqtt_ctx.publish_tx = publish_cb;
  1004fb:	c7 05 e0 93 10 00 c9 	movl   $0x1001c9,0x1093e0
  100502:	01 10 00 
	rc = mqtt_init(&client_ctx.mqtt_ctx, MQTT_APP_PUBLISHER);
  100505:	e8 b4 61 00 00       	call   1066be <mqtt_init>
  10050a:	59                   	pop    %ecx
  10050b:	5b                   	pop    %ebx
  10050c:	89 c3                	mov    %eax,%ebx
	PRINT_RESULT("mqtt_init", rc);
  10050e:	85 db                	test   %ebx,%ebx
  100510:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
  100515:	74 05                	je     10051c <main+0x1db>
  100517:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  10051c:	50                   	push   %eax
  10051d:	53                   	push   %ebx
  10051e:	68 c6 7f 10 00       	push   $0x107fc6
  100523:	68 11 01 00 00       	push   $0x111
  100528:	68 d4 80 10 00       	push   $0x1080d4
  10052d:	68 b1 7f 10 00       	push   $0x107fb1
  100532:	e8 81 14 00 00       	call   1019b8 <printk>
  100537:	83 c4 18             	add    $0x18,%esp
	if (rc != 0) {
  10053a:	85 db                	test   %ebx,%ebx
  10053c:	0f 85 5f 02 00 00    	jne    1007a1 <main+0x460>
	client_ctx.connect_msg.client_id_len = strlen(MQTT_CLIENTID);
  100542:	68 d0 7f 10 00       	push   $0x107fd0
	client_ctx.connect_msg.client_id = MQTT_CLIENTID;
  100547:	c7 05 84 93 10 00 d0 	movl   $0x107fd0,0x109384
  10054e:	7f 10 00 
	client_ctx.connect_msg.client_id_len = strlen(MQTT_CLIENTID);
  100551:	e8 7c 0e 00 00       	call   1013d2 <strlen>
	client_ctx.publish_data = "PUBLISH";
  100556:	be 0b 00 00 00       	mov    $0xb,%esi
	client_ctx.connect_msg.clean_session = 1;
  10055b:	80 0d 80 93 10 00 01 	orb    $0x1,0x109380
	client_ctx.connect_msg.client_id_len = strlen(MQTT_CLIENTID);
  100562:	5a                   	pop    %edx
  100563:	66 a3 88 93 10 00    	mov    %ax,0x109388
	client_ctx.connect_data = "CONNECTED";
  100569:	c7 05 fc 93 10 00 e4 	movl   $0x107fe4,0x1093fc
  100570:	7f 10 00 
	client_ctx.disconnect_data = "DISCONNECTED";
  100573:	c7 05 00 94 10 00 e1 	movl   $0x107fe1,0x109400
  10057a:	7f 10 00 
	client_ctx.publish_data = "PUBLISH";
  10057d:	c7 05 04 94 10 00 ee 	movl   $0x107fee,0x109404
  100584:	7f 10 00 
	while (i++ < APP_CONNECT_TRIES && !client_ctx->mqtt_ctx.connected) {
  100587:	4e                   	dec    %esi
  100588:	8a 15 f9 93 10 00    	mov    0x1093f9,%dl
  10058e:	74 51                	je     1005e1 <main+0x2a0>
  100590:	f6 c2 02             	test   $0x2,%dl
  100593:	75 4c                	jne    1005e1 <main+0x2a0>
		rc = mqtt_tx_connect(&client_ctx->mqtt_ctx,
  100595:	68 80 93 10 00       	push   $0x109380
  10059a:	68 d0 93 10 00       	push   $0x1093d0
  10059f:	e8 0d 5b 00 00       	call   1060b1 <mqtt_tx_connect>
  1005a4:	5a                   	pop    %edx
  1005a5:	89 c7                	mov    %eax,%edi
  1005a7:	59                   	pop    %ecx
		k_sleep(APP_SLEEP_MSECS);
  1005a8:	68 f4 01 00 00       	push   $0x1f4
  1005ad:	e8 2f 6d 00 00       	call   1072e1 <k_sleep>
  1005b2:	58                   	pop    %eax
		PRINT_RESULT("mqtt_tx_connect", rc);
  1005b3:	85 ff                	test   %edi,%edi
  1005b5:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
  1005ba:	74 05                	je     1005c1 <main+0x280>
  1005bc:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  1005c1:	50                   	push   %eax
  1005c2:	57                   	push   %edi
  1005c3:	68 f6 7f 10 00       	push   $0x107ff6
  1005c8:	68 e4 00 00 00       	push   $0xe4
  1005cd:	68 8c 80 10 00       	push   $0x10808c
  1005d2:	68 b1 7f 10 00       	push   $0x107fb1
  1005d7:	e8 dc 13 00 00       	call   1019b8 <printk>
  1005dc:	83 c4 18             	add    $0x18,%esp
  1005df:	eb a6                	jmp    100587 <main+0x246>
	PRINT_RESULT("try_to_connect", rc);
  1005e1:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
	if (client_ctx->mqtt_ctx.connected) {
  1005e6:	80 e2 02             	and    $0x2,%dl
  1005e9:	75 0a                	jne    1005f5 <main+0x2b4>
	return -EINVAL;
  1005eb:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	PRINT_RESULT("try_to_connect", rc);
  1005f0:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  1005f5:	50                   	push   %eax
  1005f6:	53                   	push   %ebx
  1005f7:	68 06 80 10 00       	push   $0x108006
  1005fc:	68 24 01 00 00       	push   $0x124
  100601:	68 d4 80 10 00       	push   $0x1080d4
  100606:	68 b1 7f 10 00       	push   $0x107fb1
  10060b:	e8 a8 13 00 00       	call   1019b8 <printk>
  100610:	83 c4 18             	add    $0x18,%esp
	if (rc != 0) {
  100613:	85 db                	test   %ebx,%ebx
  100615:	0f 85 86 01 00 00    	jne    1007a1 <main+0x460>
  10061b:	bb 65 00 00 00       	mov    $0x65,%ebx
	while (i++ < APP_MAX_ITERATIONS) {
  100620:	4b                   	dec    %ebx
  100621:	0f 84 43 01 00 00    	je     10076a <main+0x429>
		rc = mqtt_tx_pingreq(&client_ctx.mqtt_ctx);
  100627:	68 d0 93 10 00       	push   $0x1093d0
  10062c:	e8 b7 5c 00 00       	call   1062e8 <mqtt_tx_pingreq>
  100631:	89 c6                	mov    %eax,%esi
		k_sleep(APP_SLEEP_MSECS);
  100633:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  10063a:	e8 a2 6c 00 00       	call   1072e1 <k_sleep>
  10063f:	58                   	pop    %eax
		PRINT_RESULT("mqtt_tx_pingreq", rc);
  100640:	85 f6                	test   %esi,%esi
  100642:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
  100647:	74 05                	je     10064e <main+0x30d>
  100649:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  10064e:	50                   	push   %eax
  10064f:	56                   	push   %esi
  100650:	68 15 80 10 00       	push   $0x108015
  100655:	68 2d 01 00 00       	push   $0x12d
  10065a:	68 d4 80 10 00       	push   $0x1080d4
  10065f:	68 b1 7f 10 00       	push   $0x107fb1
  100664:	e8 4f 13 00 00       	call   1019b8 <printk>
  100669:	83 c4 18             	add    $0x18,%esp
		prepare_mqtt_publish_msg(&client_ctx.pub_msg, MQTT_QoS0);
  10066c:	31 c0                	xor    %eax,%eax
  10066e:	e8 66 fc ff ff       	call   1002d9 <prepare_mqtt_publish_msg.constprop.2>
		rc = mqtt_tx_publish(&client_ctx.mqtt_ctx, &client_ctx.pub_msg);
  100673:	68 b4 93 10 00       	push   $0x1093b4
  100678:	68 d0 93 10 00       	push   $0x1093d0
  10067d:	e8 bc 5b 00 00       	call   10623e <mqtt_tx_publish>
  100682:	89 c6                	mov    %eax,%esi
  100684:	5a                   	pop    %edx
  100685:	59                   	pop    %ecx
		k_sleep(APP_SLEEP_MSECS);
  100686:	68 f4 01 00 00       	push   $0x1f4
  10068b:	e8 51 6c 00 00       	call   1072e1 <k_sleep>
  100690:	5f                   	pop    %edi
		PRINT_RESULT("mqtt_tx_publish", rc);
  100691:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
  100696:	85 f6                	test   %esi,%esi
  100698:	74 05                	je     10069f <main+0x35e>
  10069a:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  10069f:	50                   	push   %eax
  1006a0:	56                   	push   %esi
  1006a1:	68 25 80 10 00       	push   $0x108025
  1006a6:	68 32 01 00 00       	push   $0x132
  1006ab:	68 d4 80 10 00       	push   $0x1080d4
  1006b0:	68 b1 7f 10 00       	push   $0x107fb1
  1006b5:	e8 fe 12 00 00       	call   1019b8 <printk>
  1006ba:	83 c4 18             	add    $0x18,%esp
		prepare_mqtt_publish_msg(&client_ctx.pub_msg, MQTT_QoS1);
  1006bd:	b8 01 00 00 00       	mov    $0x1,%eax
  1006c2:	e8 12 fc ff ff       	call   1002d9 <prepare_mqtt_publish_msg.constprop.2>
		rc = mqtt_tx_publish(&client_ctx.mqtt_ctx, &client_ctx.pub_msg);
  1006c7:	68 b4 93 10 00       	push   $0x1093b4
  1006cc:	68 d0 93 10 00       	push   $0x1093d0
  1006d1:	e8 68 5b 00 00       	call   10623e <mqtt_tx_publish>
  1006d6:	89 c6                	mov    %eax,%esi
  1006d8:	5a                   	pop    %edx
  1006d9:	59                   	pop    %ecx
		k_sleep(APP_SLEEP_MSECS);
  1006da:	68 f4 01 00 00       	push   $0x1f4
  1006df:	e8 fd 6b 00 00       	call   1072e1 <k_sleep>
  1006e4:	5f                   	pop    %edi
		PRINT_RESULT("mqtt_tx_publish", rc);
  1006e5:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
  1006ea:	85 f6                	test   %esi,%esi
  1006ec:	74 05                	je     1006f3 <main+0x3b2>
  1006ee:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  1006f3:	50                   	push   %eax
  1006f4:	56                   	push   %esi
  1006f5:	68 25 80 10 00       	push   $0x108025
  1006fa:	68 37 01 00 00       	push   $0x137
  1006ff:	68 d4 80 10 00       	push   $0x1080d4
  100704:	68 b1 7f 10 00       	push   $0x107fb1
  100709:	e8 aa 12 00 00       	call   1019b8 <printk>
  10070e:	83 c4 18             	add    $0x18,%esp
		prepare_mqtt_publish_msg(&client_ctx.pub_msg, MQTT_QoS2);
  100711:	b8 02 00 00 00       	mov    $0x2,%eax
  100716:	e8 be fb ff ff       	call   1002d9 <prepare_mqtt_publish_msg.constprop.2>
		rc = mqtt_tx_publish(&client_ctx.mqtt_ctx, &client_ctx.pub_msg);
  10071b:	68 b4 93 10 00       	push   $0x1093b4
  100720:	68 d0 93 10 00       	push   $0x1093d0
  100725:	e8 14 5b 00 00       	call   10623e <mqtt_tx_publish>
  10072a:	59                   	pop    %ecx
  10072b:	5e                   	pop    %esi
  10072c:	89 c6                	mov    %eax,%esi
		k_sleep(APP_SLEEP_MSECS);
  10072e:	68 f4 01 00 00       	push   $0x1f4
  100733:	e8 a9 6b 00 00       	call   1072e1 <k_sleep>
  100738:	5f                   	pop    %edi
		PRINT_RESULT("mqtt_tx_publish", rc);
  100739:	b8 a5 7e 10 00       	mov    $0x107ea5,%eax
  10073e:	85 f6                	test   %esi,%esi
  100740:	74 05                	je     100747 <main+0x406>
  100742:	b8 a8 7e 10 00       	mov    $0x107ea8,%eax
  100747:	50                   	push   %eax
  100748:	56                   	push   %esi
  100749:	68 25 80 10 00       	push   $0x108025
  10074e:	68 3c 01 00 00       	push   $0x13c
  100753:	68 d4 80 10 00       	push   $0x1080d4
  100758:	68 b1 7f 10 00       	push   $0x107fb1
  10075d:	e8 56 12 00 00       	call   1019b8 <printk>
  100762:	83 c4 18             	add    $0x18,%esp
  100765:	e9 b6 fe ff ff       	jmp    100620 <main+0x2df>
	rc = mqtt_tx_disconnect(&client_ctx.mqtt_ctx);
  10076a:	68 d0 93 10 00       	push   $0x1093d0
  10076f:	e8 f8 59 00 00       	call   10616c <mqtt_tx_disconnect>
  100774:	5a                   	pop    %edx
	PRINT_RESULT("mqtt_tx_disconnect", rc);
  100775:	85 c0                	test   %eax,%eax
  100777:	ba a5 7e 10 00       	mov    $0x107ea5,%edx
  10077c:	74 05                	je     100783 <main+0x442>
  10077e:	ba a8 7e 10 00       	mov    $0x107ea8,%edx
  100783:	52                   	push   %edx
  100784:	50                   	push   %eax
  100785:	68 35 80 10 00       	push   $0x108035
  10078a:	68 40 01 00 00       	push   $0x140
  10078f:	68 d4 80 10 00       	push   $0x1080d4
  100794:	68 b1 7f 10 00       	push   $0x107fb1
  100799:	e8 1a 12 00 00       	call   1019b8 <printk>
  10079e:	83 c4 18             	add    $0x18,%esp
	net_context_put(net_ctx);
  1007a1:	ff 35 08 94 10 00    	pushl  0x109408
  1007a7:	e8 7d 25 00 00       	call   102d29 <net_context_put>
	printk("\nBye!\n");
  1007ac:	c7 04 24 48 80 10 00 	movl   $0x108048,(%esp)
  1007b3:	e8 00 12 00 00       	call   1019b8 <printk>
  1007b8:	58                   	pop    %eax
	publisher();
}
  1007b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1007bc:	5b                   	pop    %ebx
  1007bd:	5e                   	pop    %esi
  1007be:	5f                   	pop    %edi
  1007bf:	5d                   	pop    %ebp
  1007c0:	c3                   	ret    

001007c1 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1007c1:	55                   	push   %ebp
  1007c2:	89 e5                	mov    %esp,%ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  1007c4:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  1007c8:	75 10                	jne    1007da <console_out+0x19>
		uart_poll_out(uart_console_dev, '\r');
  1007ca:	a1 0c 94 10 00       	mov    0x10940c,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
  1007cf:	8b 50 04             	mov    0x4(%eax),%edx
  1007d2:	6a 0d                	push   $0xd
  1007d4:	50                   	push   %eax
  1007d5:	ff 52 04             	call   *0x4(%edx)
  1007d8:	59                   	pop    %ecx
  1007d9:	58                   	pop    %eax
	}
	uart_poll_out(uart_console_dev, c);
  1007da:	a1 0c 94 10 00       	mov    0x10940c,%eax
  1007df:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
  1007e3:	8b 50 04             	mov    0x4(%eax),%edx
  1007e6:	51                   	push   %ecx
  1007e7:	50                   	push   %eax
  1007e8:	ff 52 04             	call   *0x4(%edx)
  1007eb:	58                   	pop    %eax

	return c;
}
  1007ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1007ef:	5a                   	pop    %edx
  1007f0:	c9                   	leave  
  1007f1:	c3                   	ret    

001007f2 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
  1007f2:	55                   	push   %ebp
  1007f3:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
  1007f5:	68 c1 07 10 00       	push   $0x1007c1
  1007fa:	e8 8c 0b 00 00       	call   10138b <__stdout_hook_install>
	__printk_hook_install(console_out);
  1007ff:	c7 04 24 c1 07 10 00 	movl   $0x1007c1,(%esp)
  100806:	e8 40 0f 00 00       	call   10174b <__printk_hook_install>
  10080b:	58                   	pop    %eax
}
  10080c:	c9                   	leave  
  10080d:	c3                   	ret    

0010080e <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
  10080e:	55                   	push   %ebp
  10080f:	89 e5                	mov    %esp,%ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  100811:	68 de 80 10 00       	push   $0x1080de
  100816:	e8 02 63 00 00       	call   106b1d <device_get_binding>
  10081b:	5a                   	pop    %edx
  10081c:	a3 0c 94 10 00       	mov    %eax,0x10940c
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  100821:	e8 cc ff ff ff       	call   1007f2 <uart_console_hook_install>

	return 0;
}
  100826:	31 c0                	xor    %eax,%eax
  100828:	c9                   	leave  
  100829:	c3                   	ret    

0010082a <uart_pipe_isr>:

static void uart_pipe_isr(struct device *unused)
{
	ARG_UNUSED(unused);

	while (uart_irq_update(uart_pipe_dev)
  10082a:	8b 15 20 94 10 00    	mov    0x109420,%edx
 */
static inline int uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;

	if (api->irq_update) {
  100830:	8b 42 04             	mov    0x4(%edx),%eax
  100833:	8b 40 3c             	mov    0x3c(%eax),%eax
  100836:	85 c0                	test   %eax,%eax
  100838:	74 48                	je     100882 <uart_pipe_isr+0x58>
{
  10083a:	55                   	push   %ebp
  10083b:	89 e5                	mov    %esp,%ebp
  10083d:	53                   	push   %ebx
		return api->irq_update(dev);
  10083e:	52                   	push   %edx
  10083f:	ff d0                	call   *%eax
  100841:	59                   	pop    %ecx
	while (uart_irq_update(uart_pipe_dev)
  100842:	85 c0                	test   %eax,%eax
  100844:	74 38                	je     10087e <uart_pipe_isr+0x54>
	       && uart_irq_is_pending(uart_pipe_dev)) {
  100846:	8b 15 20 94 10 00    	mov    0x109420,%edx
	if (api->irq_is_pending)	{
  10084c:	8b 42 04             	mov    0x4(%edx),%eax
  10084f:	8b 40 38             	mov    0x38(%eax),%eax
  100852:	85 c0                	test   %eax,%eax
  100854:	74 28                	je     10087e <uart_pipe_isr+0x54>
		return api->irq_is_pending(dev);
  100856:	52                   	push   %edx
  100857:	ff d0                	call   *%eax
  100859:	5a                   	pop    %edx
  10085a:	85 c0                	test   %eax,%eax
  10085c:	74 20                	je     10087e <uart_pipe_isr+0x54>
		int rx;

		if (!uart_irq_rx_ready(uart_pipe_dev)) {
  10085e:	8b 15 20 94 10 00    	mov    0x109420,%edx
	if (api->irq_rx_ready) {
  100864:	8b 42 04             	mov    0x4(%edx),%eax
  100867:	8b 40 2c             	mov    0x2c(%eax),%eax
  10086a:	85 c0                	test   %eax,%eax
  10086c:	75 15                	jne    100883 <uart_pipe_isr+0x59>
	while (uart_irq_update(uart_pipe_dev)
  10086e:	8b 15 20 94 10 00    	mov    0x109420,%edx
	if (api->irq_update) {
  100874:	8b 42 04             	mov    0x4(%edx),%eax
  100877:	8b 40 3c             	mov    0x3c(%eax),%eax
  10087a:	85 c0                	test   %eax,%eax
  10087c:	75 c0                	jne    10083e <uart_pipe_isr+0x14>
		 * may provide new buffer or alter data offset.
		 */
		recv_off += rx;
		recv_buf = app_cb(recv_buf, &recv_off);
	}
}
  10087e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  100881:	c9                   	leave  
  100882:	c3                   	ret    
		return api->irq_rx_ready(dev);
  100883:	52                   	push   %edx
  100884:	ff d0                	call   *%eax
  100886:	59                   	pop    %ecx
		if (!uart_irq_rx_ready(uart_pipe_dev)) {
  100887:	85 c0                	test   %eax,%eax
  100889:	74 e3                	je     10086e <uart_pipe_isr+0x44>
		rx = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off,
  10088b:	8b 1d 20 94 10 00    	mov    0x109420,%ebx
	if (api->fifo_read) {
  100891:	8b 43 04             	mov    0x4(%ebx),%eax
  100894:	8b 48 10             	mov    0x10(%eax),%ecx
  100897:	85 c9                	test   %ecx,%ecx
  100899:	74 d3                	je     10086e <uart_pipe_isr+0x44>
				    recv_buf_len - recv_off);
  10089b:	a1 10 94 10 00       	mov    0x109410,%eax
  1008a0:	8b 15 18 94 10 00    	mov    0x109418,%edx
  1008a6:	29 c2                	sub    %eax,%edx
		rx = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off,
  1008a8:	03 05 1c 94 10 00    	add    0x10941c,%eax
		return api->fifo_read(dev, rx_data, size);
  1008ae:	52                   	push   %edx
  1008af:	50                   	push   %eax
  1008b0:	53                   	push   %ebx
  1008b1:	ff d1                	call   *%ecx
  1008b3:	83 c4 0c             	add    $0xc,%esp
		if (!rx) {
  1008b6:	85 c0                	test   %eax,%eax
  1008b8:	74 b4                	je     10086e <uart_pipe_isr+0x44>
		recv_buf = app_cb(recv_buf, &recv_off);
  1008ba:	68 10 94 10 00       	push   $0x109410
		recv_off += rx;
  1008bf:	01 05 10 94 10 00    	add    %eax,0x109410
		recv_buf = app_cb(recv_buf, &recv_off);
  1008c5:	ff 35 1c 94 10 00    	pushl  0x10941c
  1008cb:	ff 15 14 94 10 00    	call   *0x109414
  1008d1:	5b                   	pop    %ebx
  1008d2:	a3 1c 94 10 00       	mov    %eax,0x10941c
  1008d7:	5a                   	pop    %edx
  1008d8:	eb 94                	jmp    10086e <uart_pipe_isr+0x44>

001008da <uart_pipe_send>:

int uart_pipe_send(const uint8_t *data, int len)
{
  1008da:	55                   	push   %ebp
  1008db:	89 e5                	mov    %esp,%ebp
  1008dd:	56                   	push   %esi
  1008de:	53                   	push   %ebx
  1008df:	8b 75 0c             	mov    0xc(%ebp),%esi
  1008e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1008e5:	01 de                	add    %ebx,%esi
	while (len--)  {
  1008e7:	39 f3                	cmp    %esi,%ebx
  1008e9:	74 16                	je     100901 <uart_pipe_send+0x27>
		uart_poll_out(uart_pipe_dev, *data++);
  1008eb:	a1 20 94 10 00       	mov    0x109420,%eax
  1008f0:	43                   	inc    %ebx
  1008f1:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
	return api->poll_out(dev, out_char);
  1008f5:	8b 50 04             	mov    0x4(%eax),%edx
  1008f8:	51                   	push   %ecx
  1008f9:	50                   	push   %eax
  1008fa:	ff 52 04             	call   *0x4(%edx)
  1008fd:	58                   	pop    %eax
  1008fe:	5a                   	pop    %edx
  1008ff:	eb e6                	jmp    1008e7 <uart_pipe_send+0xd>
	}

	return 0;
}
  100901:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100904:	31 c0                	xor    %eax,%eax
  100906:	5b                   	pop    %ebx
  100907:	5e                   	pop    %esi
  100908:	5d                   	pop    %ebp
  100909:	c3                   	ret    

0010090a <uart_pipe_register>:

	uart_irq_rx_enable(uart);
}

void uart_pipe_register(uint8_t *buf, size_t len, uart_pipe_recv_cb cb)
{
  10090a:	55                   	push   %ebp
  10090b:	89 e5                	mov    %esp,%ebp
  10090d:	56                   	push   %esi
  10090e:	53                   	push   %ebx
  10090f:	50                   	push   %eax
	recv_buf = buf;
  100910:	8b 45 08             	mov    0x8(%ebp),%eax
	recv_buf_len = len;
	app_cb = cb;

	uart_pipe_dev = device_get_binding(CONFIG_UART_PIPE_ON_DEV_NAME);
  100913:	68 e5 80 10 00       	push   $0x1080e5
	recv_buf = buf;
  100918:	a3 1c 94 10 00       	mov    %eax,0x10941c
	recv_buf_len = len;
  10091d:	8b 45 0c             	mov    0xc(%ebp),%eax
  100920:	a3 18 94 10 00       	mov    %eax,0x109418
	app_cb = cb;
  100925:	8b 45 10             	mov    0x10(%ebp),%eax
  100928:	a3 14 94 10 00       	mov    %eax,0x109414
	uart_pipe_dev = device_get_binding(CONFIG_UART_PIPE_ON_DEV_NAME);
  10092d:	e8 eb 61 00 00       	call   106b1d <device_get_binding>
  100932:	5a                   	pop    %edx
  100933:	a3 20 94 10 00       	mov    %eax,0x109420

	if (uart_pipe_dev != NULL) {
  100938:	85 c0                	test   %eax,%eax
  10093a:	74 62                	je     10099e <uart_pipe_register+0x94>
  10093c:	89 c3                	mov    %eax,%ebx
	if (api->irq_rx_disable) {
  10093e:	8b 40 04             	mov    0x4(%eax),%eax
  100941:	8b 40 24             	mov    0x24(%eax),%eax
  100944:	85 c0                	test   %eax,%eax
  100946:	74 04                	je     10094c <uart_pipe_register+0x42>
		api->irq_rx_disable(dev);
  100948:	53                   	push   %ebx
  100949:	ff d0                	call   *%eax
  10094b:	58                   	pop    %eax
	if (api->irq_tx_disable) {
  10094c:	8b 43 04             	mov    0x4(%ebx),%eax
  10094f:	8b 40 18             	mov    0x18(%eax),%eax
  100952:	85 c0                	test   %eax,%eax
  100954:	74 04                	je     10095a <uart_pipe_register+0x50>
		api->irq_tx_disable(dev);
  100956:	53                   	push   %ebx
  100957:	ff d0                	call   *%eax
  100959:	5e                   	pop    %esi
		return api->fifo_read(dev, rx_data, size);
  10095a:	8d 75 f7             	lea    -0x9(%ebp),%esi
	if (api->fifo_read) {
  10095d:	8b 43 04             	mov    0x4(%ebx),%eax
  100960:	8b 40 10             	mov    0x10(%eax),%eax
  100963:	85 c0                	test   %eax,%eax
  100965:	75 09                	jne    100970 <uart_pipe_register+0x66>
 * @return N/A
 */
static inline void uart_irq_callback_set(struct device *dev,
					 uart_irq_callback_t cb)
{
	const struct uart_driver_api *api = dev->driver_api;
  100967:	8b 43 04             	mov    0x4(%ebx),%eax

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
  10096a:	85 c0                	test   %eax,%eax
  10096c:	75 11                	jne    10097f <uart_pipe_register+0x75>
  10096e:	eb 20                	jmp    100990 <uart_pipe_register+0x86>
		return api->fifo_read(dev, rx_data, size);
  100970:	6a 01                	push   $0x1
  100972:	56                   	push   %esi
  100973:	53                   	push   %ebx
  100974:	ff d0                	call   *%eax
  100976:	83 c4 0c             	add    $0xc,%esp
	while (uart_fifo_read(uart, &c, 1)) {
  100979:	85 c0                	test   %eax,%eax
  10097b:	75 e0                	jne    10095d <uart_pipe_register+0x53>
  10097d:	eb e8                	jmp    100967 <uart_pipe_register+0x5d>
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
  10097f:	8b 40 40             	mov    0x40(%eax),%eax
  100982:	85 c0                	test   %eax,%eax
  100984:	74 0a                	je     100990 <uart_pipe_register+0x86>
		api->irq_callback_set(dev, cb);
  100986:	68 2a 08 10 00       	push   $0x10082a
  10098b:	53                   	push   %ebx
  10098c:	ff d0                	call   *%eax
  10098e:	5a                   	pop    %edx
  10098f:	59                   	pop    %ecx
	if (api->irq_rx_enable) {
  100990:	8b 43 04             	mov    0x4(%ebx),%eax
  100993:	8b 40 20             	mov    0x20(%eax),%eax
  100996:	85 c0                	test   %eax,%eax
  100998:	74 04                	je     10099e <uart_pipe_register+0x94>
		api->irq_rx_enable(dev);
  10099a:	53                   	push   %ebx
  10099b:	ff d0                	call   *%eax
  10099d:	58                   	pop    %eax
		uart_pipe_setup(uart_pipe_dev);
	}
}
  10099e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1009a1:	5b                   	pop    %ebx
  1009a2:	5e                   	pop    %esi
  1009a3:	5d                   	pop    %ebp
  1009a4:	c3                   	ret    

001009a5 <sys_rand32_get>:
 *
 * @return a 32-bit number
 */

uint32_t sys_rand32_get(void)
{
  1009a5:	55                   	push   %ebp
  1009a6:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t _do_read_cpu_timestamp32(void)
{
	uint32_t rv;

	__asm__ volatile("rdtsc" : "=a"(rv) :  : "%edx");
  1009a8:	0f 31                	rdtsc  
	return _do_read_cpu_timestamp32();
}
  1009aa:	5d                   	pop    %ebp
  1009ab:	c3                   	ret    

001009ac <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed othersie
 */
static int uart_ns16550_init(struct device *dev)
{
  1009ac:	55                   	push   %ebp
  1009ad:	89 e5                	mov    %esp,%ebp
  1009af:	57                   	push   %edi
  1009b0:	56                   	push   %esi
  1009b1:	53                   	push   %ebx
  1009b2:	83 ec 10             	sub    $0x10,%esp
  1009b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  1009b8:	8b 59 08             	mov    0x8(%ecx),%ebx
		dev->driver_api = NULL;
		return -ENOTSUP;
	}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	dev_data->iir_cache = 0;
  1009bb:	c6 43 09 00          	movb   $0x0,0x9(%ebx)
	__asm__ volatile (
  1009bf:	9c                   	pushf  
  1009c0:	fa                   	cli    
  1009c1:	8f 45 e8             	popl   -0x18(%ebp)
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
  1009c4:	8b 7b 04             	mov    0x4(%ebx),%edi
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  1009c7:	8b 71 08             	mov    0x8(%ecx),%esi
	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  1009ca:	85 ff                	test   %edi,%edi
  1009cc:	74 3e                	je     100a0c <uart_ns16550_init+0x60>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  1009ce:	8b 01                	mov    (%ecx),%eax
	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  1009d0:	8b 40 08             	mov    0x8(%eax),%eax
  1009d3:	8b 00                	mov    (%eax),%eax
  1009d5:	85 c0                	test   %eax,%eax
  1009d7:	74 33                	je     100a0c <uart_ns16550_init+0x60>
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  1009d9:	31 d2                	xor    %edx,%edx
  1009db:	f7 f7                	div    %edi
  1009dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		lcr_cache = INBYTE(LCR(dev));
  1009e0:	8b 06                	mov    (%esi),%eax
  1009e2:	83 c0 03             	add    $0x3,%eax
  1009e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
static ALWAYS_INLINE
	uint8_t sys_in8(io_port_t port)
{
	uint8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
  1009e8:	89 c2                	mov    %eax,%edx
  1009ea:	ec                   	in     (%dx),%al
  1009eb:	88 45 e7             	mov    %al,-0x19(%ebp)
	__asm__ volatile("outb	%b0, %w1;\n\t"
  1009ee:	b0 80                	mov    $0x80,%al
  1009f0:	ee                   	out    %al,(%dx)
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  1009f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1009f4:	8b 16                	mov    (%esi),%edx
  1009f6:	c1 e8 04             	shr    $0x4,%eax
  1009f9:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  1009fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1009fd:	42                   	inc    %edx
  1009fe:	c1 e8 0c             	shr    $0xc,%eax
  100a01:	ee                   	out    %al,(%dx)
  100a02:	8a 45 e7             	mov    -0x19(%ebp),%al
  100a05:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100a08:	ee                   	out    %al,(%dx)
		dev_data->baud_rate = baud_rate;
  100a09:	89 7e 04             	mov    %edi,0x4(%esi)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
  100a0c:	8b 36                	mov    (%esi),%esi
  100a0e:	b0 03                	mov    $0x3,%al
  100a10:	8d 56 03             	lea    0x3(%esi),%edx
  100a13:	ee                   	out    %al,(%dx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  100a14:	8a 43 08             	mov    0x8(%ebx),%al
		mdc |= MCR_AFCE;

	OUTBYTE(MDC(dev), mdc);
  100a17:	8d 56 04             	lea    0x4(%esi),%edx
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  100a1a:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
  100a1d:	3c 01                	cmp    $0x1,%al
  100a1f:	19 c0                	sbb    %eax,%eax
  100a21:	83 e0 e0             	and    $0xffffffe0,%eax
  100a24:	83 c0 2b             	add    $0x2b,%eax
  100a27:	ee                   	out    %al,(%dx)
  100a28:	b0 87                	mov    $0x87,%al
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
  100a2a:	8d 56 02             	lea    0x2(%esi),%edx
  100a2d:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100a2e:	89 f2                	mov    %esi,%edx
  100a30:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100a31:	31 c0                	xor    %eax,%eax

	/* clear the port */
	INBYTE(RDR(dev));

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
  100a33:	8d 56 01             	lea    0x1(%esi),%edx
  100a36:	ee                   	out    %al,(%dx)
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  100a37:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100a3a:	0f ba e0 09          	bt     $0x9,%eax
  100a3e:	73 01                	jae    100a41 <uart_ns16550_init+0x95>
	__asm__ volatile (
  100a40:	fb                   	sti    

	irq_unlock(old_level);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
  100a41:	8b 01                	mov    (%ecx),%eax
  100a43:	8b 40 08             	mov    0x8(%eax),%eax
  100a46:	51                   	push   %ecx
  100a47:	ff 50 04             	call   *0x4(%eax)
  100a4a:	58                   	pop    %eax
#endif

	return 0;
}
  100a4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100a4e:	31 c0                	xor    %eax,%eax
  100a50:	5b                   	pop    %ebx
  100a51:	5e                   	pop    %esi
  100a52:	5f                   	pop    %edi
  100a53:	5d                   	pop    %ebp
  100a54:	c3                   	ret    

00100a55 <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
  100a55:	55                   	push   %ebp
  100a56:	89 e5                	mov    %esp,%ebp
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
  100a58:	8b 45 08             	mov    0x8(%ebp),%eax
  100a5b:	8b 40 08             	mov    0x8(%eax),%eax
  100a5e:	8b 08                	mov    (%eax),%ecx
  100a60:	8d 51 05             	lea    0x5(%ecx),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100a63:	ec                   	in     (%dx),%al
  100a64:	88 c2                	mov    %al,%dl
  100a66:	80 e2 01             	and    $0x1,%dl
  100a69:	74 0c                	je     100a77 <uart_ns16550_poll_in+0x22>
  100a6b:	89 ca                	mov    %ecx,%edx
  100a6d:	ec                   	in     (%dx),%al
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
  100a6e:	8b 55 0c             	mov    0xc(%ebp),%edx
  100a71:	88 02                	mov    %al,(%edx)

	return 0;
  100a73:	31 c0                	xor    %eax,%eax
  100a75:	eb 03                	jmp    100a7a <uart_ns16550_poll_in+0x25>
  100a77:	83 c8 ff             	or     $0xffffffff,%eax
}
  100a7a:	5d                   	pop    %ebp
  100a7b:	c3                   	ret    

00100a7c <uart_ns16550_poll_out>:
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  100a7c:	55                   	push   %ebp
  100a7d:	89 e5                	mov    %esp,%ebp
  100a7f:	53                   	push   %ebx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
  100a80:	8b 45 08             	mov    0x8(%ebp),%eax
{
  100a83:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
  100a86:	8b 40 08             	mov    0x8(%eax),%eax
  100a89:	8b 18                	mov    (%eax),%ebx
  100a8b:	8d 53 05             	lea    0x5(%ebx),%edx
  100a8e:	ec                   	in     (%dx),%al
  100a8f:	a8 40                	test   $0x40,%al
  100a91:	74 fb                	je     100a8e <uart_ns16550_poll_out+0x12>
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100a93:	88 c8                	mov    %cl,%al
  100a95:	89 da                	mov    %ebx,%edx
  100a97:	ee                   	out    %al,(%dx)
		;

	OUTBYTE(THR(dev), c);

	return c;
}
  100a98:	5b                   	pop    %ebx
  100a99:	5d                   	pop    %ebp
  100a9a:	c3                   	ret    

00100a9b <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
  100a9b:	55                   	push   %ebp
  100a9c:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  100a9e:	8b 45 08             	mov    0x8(%ebp),%eax
  100aa1:	8b 40 08             	mov    0x8(%eax),%eax
  100aa4:	8b 00                	mov    (%eax),%eax
  100aa6:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100aa9:	ec                   	in     (%dx),%al
  100aaa:	d1 e8                	shr    %eax
}
  100aac:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  100aad:	83 e0 0f             	and    $0xf,%eax
}
  100ab0:	c3                   	ret    

00100ab1 <uart_ns16550_fifo_fill>:
 *
 * @return Number of bytes sent
 */
static int uart_ns16550_fifo_fill(struct device *dev, const uint8_t *tx_data,
				  int size)
{
  100ab1:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  100ab2:	31 c9                	xor    %ecx,%ecx
{
  100ab4:	89 e5                	mov    %esp,%ebp
  100ab6:	57                   	push   %edi
  100ab7:	56                   	push   %esi
  100ab8:	53                   	push   %ebx
  100ab9:	8b 75 08             	mov    0x8(%ebp),%esi
  100abc:	8b 7d 0c             	mov    0xc(%ebp),%edi
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  100abf:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  100ac2:	7d 16                	jge    100ada <uart_ns16550_fifo_fill+0x29>
  100ac4:	8b 46 08             	mov    0x8(%esi),%eax
  100ac7:	8b 18                	mov    (%eax),%ebx
  100ac9:	8d 53 05             	lea    0x5(%ebx),%edx
  100acc:	ec                   	in     (%dx),%al
  100acd:	a8 20                	test   $0x20,%al
  100acf:	74 09                	je     100ada <uart_ns16550_fifo_fill+0x29>
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100ad1:	8a 04 0f             	mov    (%edi,%ecx,1),%al
  100ad4:	89 da                	mov    %ebx,%edx
  100ad6:	ee                   	out    %al,(%dx)
  100ad7:	41                   	inc    %ecx
  100ad8:	eb e5                	jmp    100abf <uart_ns16550_fifo_fill+0xe>
		OUTBYTE(THR(dev), tx_data[i]);
	}
	return i;
}
  100ada:	5b                   	pop    %ebx
  100adb:	89 c8                	mov    %ecx,%eax
  100add:	5e                   	pop    %esi
  100ade:	5f                   	pop    %edi
  100adf:	5d                   	pop    %ebp
  100ae0:	c3                   	ret    

00100ae1 <uart_ns16550_fifo_read>:
 *
 * @return Number of bytes read
 */
static int uart_ns16550_fifo_read(struct device *dev, uint8_t *rx_data,
				  const int size)
{
  100ae1:	55                   	push   %ebp
	int i;

	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  100ae2:	31 c9                	xor    %ecx,%ecx
{
  100ae4:	89 e5                	mov    %esp,%ebp
  100ae6:	56                   	push   %esi
  100ae7:	53                   	push   %ebx
  100ae8:	8b 75 08             	mov    0x8(%ebp),%esi
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  100aeb:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  100aee:	7d 19                	jge    100b09 <uart_ns16550_fifo_read+0x28>
  100af0:	8b 46 08             	mov    0x8(%esi),%eax
  100af3:	8b 18                	mov    (%eax),%ebx
  100af5:	8d 53 05             	lea    0x5(%ebx),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100af8:	ec                   	in     (%dx),%al
  100af9:	a8 01                	test   $0x1,%al
  100afb:	74 0c                	je     100b09 <uart_ns16550_fifo_read+0x28>
  100afd:	89 da                	mov    %ebx,%edx
  100aff:	ec                   	in     (%dx),%al
		rx_data[i] = INBYTE(RDR(dev));
  100b00:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100b03:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
	for (i = 0; i < size && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  100b06:	41                   	inc    %ecx
  100b07:	eb e2                	jmp    100aeb <uart_ns16550_fifo_read+0xa>
	}

	return i;
}
  100b09:	5b                   	pop    %ebx
  100b0a:	89 c8                	mov    %ecx,%eax
  100b0c:	5e                   	pop    %esi
  100b0d:	5d                   	pop    %ebp
  100b0e:	c3                   	ret    

00100b0f <uart_ns16550_irq_tx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_enable(struct device *dev)
{
  100b0f:	55                   	push   %ebp
  100b10:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_TBE);
  100b12:	8b 45 08             	mov    0x8(%ebp),%eax
  100b15:	8b 40 08             	mov    0x8(%eax),%eax
  100b18:	8b 10                	mov    (%eax),%edx
  100b1a:	42                   	inc    %edx
  100b1b:	ec                   	in     (%dx),%al
  100b1c:	83 c8 02             	or     $0x2,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100b1f:	ee                   	out    %al,(%dx)
}
  100b20:	5d                   	pop    %ebp
  100b21:	c3                   	ret    

00100b22 <uart_ns16550_irq_tx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_disable(struct device *dev)
{
  100b22:	55                   	push   %ebp
  100b23:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_TBE));
  100b25:	8b 45 08             	mov    0x8(%ebp),%eax
  100b28:	8b 40 08             	mov    0x8(%eax),%eax
  100b2b:	8b 10                	mov    (%eax),%edx
  100b2d:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100b2e:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100b2f:	83 e0 fd             	and    $0xfffffffd,%eax
  100b32:	ee                   	out    %al,(%dx)
}
  100b33:	5d                   	pop    %ebp
  100b34:	c3                   	ret    

00100b35 <uart_ns16550_irq_tx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_tx_ready(struct device *dev)
{
  100b35:	55                   	push   %ebp
  100b36:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
  100b38:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100b3b:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_THRE);
  100b3c:	8b 40 08             	mov    0x8(%eax),%eax
  100b3f:	8a 40 09             	mov    0x9(%eax),%al
  100b42:	83 e0 06             	and    $0x6,%eax
  100b45:	3c 02                	cmp    $0x2,%al
  100b47:	0f 94 c0             	sete   %al
  100b4a:	0f b6 c0             	movzbl %al,%eax
}
  100b4d:	c3                   	ret    

00100b4e <uart_ns16550_irq_tx_empty>:
 * @param dev UART device struct
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_ns16550_irq_tx_empty(struct device *dev)
{
  100b4e:	55                   	push   %ebp
  100b4f:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
  100b51:	8b 45 08             	mov    0x8(%ebp),%eax
  100b54:	8b 40 08             	mov    0x8(%eax),%eax
  100b57:	8b 00                	mov    (%eax),%eax
  100b59:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100b5c:	ec                   	in     (%dx),%al
  100b5d:	83 e0 60             	and    $0x60,%eax
}
  100b60:	5d                   	pop    %ebp
	return (INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE)) == (LSR_TEMT | LSR_THRE);
  100b61:	3c 60                	cmp    $0x60,%al
  100b63:	0f 94 c0             	sete   %al
  100b66:	0f b6 c0             	movzbl %al,%eax
}
  100b69:	c3                   	ret    

00100b6a <uart_ns16550_irq_rx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_enable(struct device *dev)
{
  100b6a:	55                   	push   %ebp
  100b6b:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_RXRDY);
  100b6d:	8b 45 08             	mov    0x8(%ebp),%eax
  100b70:	8b 40 08             	mov    0x8(%eax),%eax
  100b73:	8b 10                	mov    (%eax),%edx
  100b75:	42                   	inc    %edx
  100b76:	ec                   	in     (%dx),%al
  100b77:	83 c8 01             	or     $0x1,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100b7a:	ee                   	out    %al,(%dx)
}
  100b7b:	5d                   	pop    %ebp
  100b7c:	c3                   	ret    

00100b7d <uart_ns16550_irq_rx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_disable(struct device *dev)
{
  100b7d:	55                   	push   %ebp
  100b7e:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_RXRDY));
  100b80:	8b 45 08             	mov    0x8(%ebp),%eax
  100b83:	8b 40 08             	mov    0x8(%eax),%eax
  100b86:	8b 10                	mov    (%eax),%edx
  100b88:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100b89:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100b8a:	83 e0 fe             	and    $0xfffffffe,%eax
  100b8d:	ee                   	out    %al,(%dx)
}
  100b8e:	5d                   	pop    %ebp
  100b8f:	c3                   	ret    

00100b90 <uart_ns16550_irq_rx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_rx_ready(struct device *dev)
{
  100b90:	55                   	push   %ebp
  100b91:	89 e5                	mov    %esp,%ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
  100b93:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100b96:	5d                   	pop    %ebp
	return ((IIRC(dev) & IIR_ID) == IIR_RBRF);
  100b97:	8b 40 08             	mov    0x8(%eax),%eax
  100b9a:	8a 40 09             	mov    0x9(%eax),%al
  100b9d:	83 e0 06             	and    $0x6,%eax
  100ba0:	3c 04                	cmp    $0x4,%al
  100ba2:	0f 94 c0             	sete   %al
  100ba5:	0f b6 c0             	movzbl %al,%eax
}
  100ba8:	c3                   	ret    

00100ba9 <uart_ns16550_irq_err_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_err_enable(struct device *dev)
{
  100ba9:	55                   	push   %ebp
  100baa:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_LSR);
  100bac:	8b 45 08             	mov    0x8(%ebp),%eax
  100baf:	8b 40 08             	mov    0x8(%eax),%eax
  100bb2:	8b 10                	mov    (%eax),%edx
  100bb4:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100bb5:	ec                   	in     (%dx),%al
  100bb6:	83 c8 04             	or     $0x4,%eax
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100bb9:	ee                   	out    %al,(%dx)
}
  100bba:	5d                   	pop    %ebp
  100bbb:	c3                   	ret    

00100bbc <uart_ns16550_irq_err_disable>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static void uart_ns16550_irq_err_disable(struct device *dev)
{
  100bbc:	55                   	push   %ebp
  100bbd:	89 e5                	mov    %esp,%ebp
	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_LSR));
  100bbf:	8b 45 08             	mov    0x8(%ebp),%eax
  100bc2:	8b 40 08             	mov    0x8(%eax),%eax
  100bc5:	8b 10                	mov    (%eax),%edx
  100bc7:	42                   	inc    %edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100bc8:	ec                   	in     (%dx),%al
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100bc9:	83 e0 fb             	and    $0xfffffffb,%eax
  100bcc:	ee                   	out    %al,(%dx)
}
  100bcd:	5d                   	pop    %ebp
  100bce:	c3                   	ret    

00100bcf <uart_ns16550_irq_is_pending>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_ns16550_irq_is_pending(struct device *dev)
{
  100bcf:	55                   	push   %ebp
  100bd0:	89 e5                	mov    %esp,%ebp
	return (!(IIRC(dev) & IIR_NIP));
  100bd2:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100bd5:	5d                   	pop    %ebp
	return (!(IIRC(dev) & IIR_NIP));
  100bd6:	8b 40 08             	mov    0x8(%eax),%eax
  100bd9:	8a 40 09             	mov    0x9(%eax),%al
  100bdc:	f7 d0                	not    %eax
  100bde:	83 e0 01             	and    $0x1,%eax
}
  100be1:	c3                   	ret    

00100be2 <uart_ns16550_irq_update>:
 * @param dev UART device struct
 *
 * @return Always 1
 */
static int uart_ns16550_irq_update(struct device *dev)
{
  100be2:	55                   	push   %ebp
  100be3:	89 e5                	mov    %esp,%ebp
	IIRC(dev) = INBYTE(IIR(dev));
  100be5:	8b 45 08             	mov    0x8(%ebp),%eax
  100be8:	8b 48 08             	mov    0x8(%eax),%ecx
  100beb:	8b 01                	mov    (%ecx),%eax
  100bed:	8d 50 02             	lea    0x2(%eax),%edx
	__asm__ volatile("inb	%w1, %b0;\n\t"
  100bf0:	ec                   	in     (%dx),%al
  100bf1:	88 41 09             	mov    %al,0x9(%ecx)

	return 1;
}
  100bf4:	b8 01 00 00 00       	mov    $0x1,%eax
  100bf9:	5d                   	pop    %ebp
  100bfa:	c3                   	ret    

00100bfb <uart_ns16550_irq_callback_set>:
 *
 * @return N/A
 */
static void uart_ns16550_irq_callback_set(struct device *dev,
					  uart_irq_callback_t cb)
{
  100bfb:	55                   	push   %ebp
  100bfc:	89 e5                	mov    %esp,%ebp
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	dev_data->cb = cb;
  100bfe:	8b 45 08             	mov    0x8(%ebp),%eax
  100c01:	8b 55 0c             	mov    0xc(%ebp),%edx
  100c04:	8b 40 08             	mov    0x8(%eax),%eax
  100c07:	89 50 0c             	mov    %edx,0xc(%eax)
}
  100c0a:	5d                   	pop    %ebp
  100c0b:	c3                   	ret    

00100c0c <uart_ns16550_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_ns16550_isr(void *arg)
{
  100c0c:	55                   	push   %ebp
  100c0d:	89 e5                	mov    %esp,%ebp
  100c0f:	8b 55 08             	mov    0x8(%ebp),%edx
	struct device *dev = arg;
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);

	if (dev_data->cb) {
  100c12:	8b 42 08             	mov    0x8(%edx),%eax
  100c15:	8b 40 0c             	mov    0xc(%eax),%eax
  100c18:	85 c0                	test   %eax,%eax
  100c1a:	74 03                	je     100c1f <uart_ns16550_isr+0x13>
		dev_data->cb(dev);
	}
}
  100c1c:	5d                   	pop    %ebp
		dev_data->cb(dev);
  100c1d:	ff e0                	jmp    *%eax
}
  100c1f:	5d                   	pop    %ebp
  100c20:	c3                   	ret    

00100c21 <irq_config_func_0>:
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &uart_ns16550_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_0(struct device *dev)
{
  100c21:	55                   	push   %ebp
  100c22:	89 e5                	mov    %esp,%ebp
  100c24:	0f b6 05 54 8c 10 00 	movzbl 0x108c54,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  100c2b:	6a 00                	push   $0x0
  100c2d:	6a 04                	push   $0x4
  100c2f:	50                   	push   %eax
  100c30:	e8 e5 02 00 00       	call   100f1a <__irq_controller_irq_config>
  100c35:	83 c4 0c             	add    $0xc,%esp

	IRQ_CONNECT(UART_NS16550_PORT_0_IRQ,
		    CONFIG_UART_NS16550_PORT_0_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_0),
		    UART_IRQ_FLAGS);
	irq_enable(UART_NS16550_PORT_0_IRQ);
  100c38:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
  100c3f:	c9                   	leave  
	irq_enable(UART_NS16550_PORT_0_IRQ);
  100c40:	e9 fb 02 00 00       	jmp    100f40 <_arch_irq_enable>

00100c45 <uart_ns16550_isr_irq4_stub>:
	IRQ_CONNECT(UART_NS16550_PORT_0_IRQ,
  100c45:	68 cc 8d 10 00       	push   $0x108dcc
  100c4a:	68 0c 0c 10 00       	push   $0x100c0c
  100c4f:	e9 6f 5b 00 00       	jmp    1067c3 <_interrupt_enter>

00100c54 <uart_ns16550_isr_irq3_stub>:
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_1(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(UART_NS16550_PORT_1_IRQ,
  100c54:	68 c0 8d 10 00       	push   $0x108dc0
  100c59:	68 0c 0c 10 00       	push   $0x100c0c
  100c5e:	e9 60 5b 00 00       	jmp    1067c3 <_interrupt_enter>

00100c63 <_timer_int_handler_irq2_stub>:
  100c63:	6a 00                	push   $0x0
  100c65:	68 93 0c 10 00       	push   $0x100c93
  100c6a:	e9 54 5b 00 00       	jmp    1067c3 <_interrupt_enter>

00100c6f <irq_config_func_1>:
{
  100c6f:	55                   	push   %ebp
  100c70:	89 e5                	mov    %esp,%ebp
  100c72:	0f b6 05 53 8c 10 00 	movzbl 0x108c53,%eax
  100c79:	6a 00                	push   $0x0
  100c7b:	6a 03                	push   $0x3
  100c7d:	50                   	push   %eax
  100c7e:	e8 97 02 00 00       	call   100f1a <__irq_controller_irq_config>
  100c83:	83 c4 0c             	add    $0xc,%esp
		    CONFIG_UART_NS16550_PORT_1_IRQ_PRI,
		    uart_ns16550_isr, DEVICE_GET(uart_ns16550_1),
		    UART_IRQ_FLAGS);
	irq_enable(UART_NS16550_PORT_1_IRQ);
  100c86:	c7 45 08 03 00 00 00 	movl   $0x3,0x8(%ebp)
}
  100c8d:	c9                   	leave  
	irq_enable(UART_NS16550_PORT_1_IRQ);
  100c8e:	e9 ad 02 00 00       	jmp    100f40 <_arch_irq_enable>

00100c93 <_timer_int_handler>:
 * is pushed onto the kernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  100c93:	55                   	push   %ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  100c94:	a1 80 8d 10 00       	mov    0x108d80,%eax
{
  100c99:	89 e5                	mov    %esp,%ebp
	_sys_clock_tick_announce();
  100c9b:	89 45 08             	mov    %eax,0x8(%ebp)
	programmed_ticks = 1;

	_sys_clock_final_tick_announce();
#endif /* !CONFIG_TICKLESS_IDLE */

}
  100c9e:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
  100c9f:	e9 19 68 00 00       	jmp    1074bd <_nano_sys_clock_tick_announce>

00100ca4 <_sys_clock_driver_init>:
 *
 * @return 0
 */

int _sys_clock_driver_init(struct device *device)
{
  100ca4:	55                   	push   %ebp
  100ca5:	89 e5                	mov    %esp,%ebp
  100ca7:	57                   	push   %edi
  100ca8:	56                   	push   %esi
  100ca9:	53                   	push   %ebx
	/*
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
  100caa:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
	/*
	 * Convert the 'sys_clock_us_per_tick' value
	 * from microseconds to femptoseconds
	 */

	tickFempto = (uint64_t)sys_clock_us_per_tick * 1000000000;
  100caf:	be 00 ca 9a 3b       	mov    $0x3b9aca00,%esi
	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
  100cb4:	83 e0 fe             	and    $0xfffffffe,%eax
  100cb7:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100cbc:	c7 05 f0 00 d0 fe 00 	movl   $0x0,0xfed000f0
  100cc3:	00 00 00 
	tickFempto = (uint64_t)sys_clock_us_per_tick * 1000000000;
  100cc6:	89 f0                	mov    %esi,%eax
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100cc8:	c7 05 f4 00 d0 fe 00 	movl   $0x0,0xfed000f4
  100ccf:	00 00 00 
	tickFempto = (uint64_t)sys_clock_us_per_tick * 1000000000;
  100cd2:	f7 2d 8c 8d 10 00    	imull  0x108d8c
	 * to determine the frequency of clock applied to the HPET device.
	 */

	/* read the clock period: units are fempto (10^-15) seconds */

	hpetClockPeriod = HPET_COUNTER_CLK_PERIOD(*_HPET_GENERAL_CAPS);
  100cd8:	8b 0d 00 00 d0 fe    	mov    0xfed00000,%ecx
  100cde:	8b 1d 04 00 d0 fe    	mov    0xfed00004,%ebx
  100ce4:	89 d9                	mov    %ebx,%ecx
  100ce6:	31 db                	xor    %ebx,%ebx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  100ce8:	53                   	push   %ebx
  100ce9:	51                   	push   %ecx
  100cea:	52                   	push   %edx
  100ceb:	50                   	push   %eax
  100cec:	e8 af f3 ff ff       	call   1000a0 <__udivdi3>
  100cf1:	31 db                	xor    %ebx,%ebx
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  100cf3:	6b d0 64             	imul   $0x64,%eax,%edx
	sys_clock_hw_cycles_per_tick = counter_load_value;
  100cf6:	a3 88 8d 10 00       	mov    %eax,0x108d88
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  100cfb:	89 15 84 8d 10 00    	mov    %edx,0x108d84
	/*
	 * Configure HPET replace legacy 8254 timer.
	 * In this case the timer0 interrupt is routed to IRQ2
	 * and legacy timer generates no interrupts
	 */
	*_HPET_GENERAL_CONFIG |= HPET_LEGACY_RT_CNF;
  100d01:	8b 15 10 00 d0 fe    	mov    0xfed00010,%edx
	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  100d07:	83 c4 10             	add    $0x10,%esp
	*_HPET_GENERAL_CONFIG |= HPET_LEGACY_RT_CNF;
  100d0a:	83 ca 02             	or     $0x2,%edx
  100d0d:	89 15 10 00 d0 fe    	mov    %edx,0xfed00010
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
  100d13:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  100d19:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  100d1f:	89 f2                	mov    %esi,%edx
  100d21:	81 ca 08 01 00 00    	or     $0x108,%edx
  100d27:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  100d2d:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104

	/*
	 * Set the comparator register for timer0.  The write to the comparator
	 * register is allowed due to setting the HPET_Tn_VAL_SET_CNF bit.
	 */
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_VAL_SET_CNF;
  100d33:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  100d39:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  100d3f:	89 f2                	mov    %esi,%edx
  100d41:	83 ca 40             	or     $0x40,%edx
  100d44:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  100d4a:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104
	*_HPET_TIMER0_COMPARATOR = counter_load_value;
  100d50:	a3 08 01 d0 fe       	mov    %eax,0xfed00108
  100d55:	89 1d 0c 01 d0 fe    	mov    %ebx,0xfed0010c
	/*
	 * After the comparator is loaded, 32-bit mode can be safely
	 * switched off
	 */
	*_HPET_TIMER0_CONFIG_CAPS &= ~HPET_Tn_32MODE_CNF;
  100d5b:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  100d61:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  100d67:	89 cf                	mov    %ecx,%edi
  100d69:	81 e7 ff fe ff ff    	and    $0xfffffeff,%edi
  100d6f:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  100d75:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
#if CONFIG_HPET_TIMER_IRQ < 32
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK) |
  100d7b:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  100d80:	8b 15 04 01 d0 fe    	mov    0xfed00104,%edx
  100d86:	89 c3                	mov    %eax,%ebx
  100d88:	80 e7 c1             	and    $0xc1,%bh
  100d8b:	80 cf 04             	or     $0x4,%bh
	*_HPET_TIMER0_CONFIG_CAPS =
  100d8e:	89 1d 00 01 d0 fe    	mov    %ebx,0xfed00100
  100d94:	89 15 04 01 d0 fe    	mov    %edx,0xfed00104
  100d9a:	0f b6 05 52 8c 10 00 	movzbl 0x108c52,%eax
  100da1:	6a 00                	push   $0x0
  100da3:	6a 02                	push   $0x2
  100da5:	50                   	push   %eax
  100da6:	e8 6f 01 00 00       	call   100f1a <__irq_controller_irq_config>
  100dab:	83 c4 0c             	add    $0xc,%esp
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
		   _timer_int_handler, 0, HPET_IOAPIC_FLAGS);

	/* enable the IRQ in the interrupt controller */

	irq_enable(CONFIG_HPET_TIMER_IRQ);
  100dae:	6a 02                	push   $0x2
  100db0:	e8 8b 01 00 00       	call   100f40 <_arch_irq_enable>
  100db5:	58                   	pop    %eax

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
  100db6:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  100dbb:	83 c8 01             	or     $0x1,%eax
  100dbe:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;

	return 0;
}
  100dc3:	31 c0                	xor    %eax,%eax
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;
  100dc5:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  100dcb:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  100dd1:	89 cf                	mov    %ecx,%edi
  100dd3:	83 cf 04             	or     $0x4,%edi
  100dd6:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  100ddc:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
}
  100de2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100de5:	5b                   	pop    %ebx
  100de6:	5e                   	pop    %esi
  100de7:	5f                   	pop    %edi
  100de8:	5d                   	pop    %ebp
  100de9:	c3                   	ret    

00100dea <_i8259_init>:
 *
 * @return N/A
 */

int _i8259_init(struct device *unused)
{
  100dea:	55                   	push   %ebp
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100deb:	b0 ff                	mov    $0xff,%al
  100ded:	89 e5                	mov    %esp,%ebp
  100def:	e6 a1                	out    %al,$0xa1
  100df1:	e6 21                	out    %al,$0x21
	ARG_UNUSED(unused);
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_SLAVE_BASE_ADRS));
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_MASTER_BASE_ADRS));
	return 0;
}
  100df3:	31 c0                	xor    %eax,%eax
  100df5:	5d                   	pop    %ebp
  100df6:	c3                   	ret    

00100df7 <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
  100df7:	55                   	push   %ebp
  100df8:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  100dfa:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
  100dff:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
  100e02:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  100e07:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
  100e0c:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
  100e13:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
  100e16:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
  100e19:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
  100e20:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
  100e23:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
  100e2a:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
  100e2d:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
  100e34:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
  100e37:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
  100e3d:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  100e43:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
  100e46:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
  100e4c:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
  100e52:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  100e58:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  100e5b:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
  100e5e:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100e64:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
  100e67:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
  100e6e:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
  100e71:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
  100e78:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100e7b:	7e 19                	jle    100e96 <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
  100e7d:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
  100e84:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
  100e87:	83 f8 04             	cmp    $0x4,%eax
  100e8a:	74 0a                	je     100e96 <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
  100e8c:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
  100e93:	00 01 00 

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
  100e96:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
  100e9d:	00 00 00 
#endif

	return 0;
}
  100ea0:	31 c0                	xor    %eax,%eax
  100ea2:	5d                   	pop    %ebp
  100ea3:	c3                   	ret    

00100ea4 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  100ea4:	55                   	push   %ebp
  100ea5:	89 e5                	mov    %esp,%ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
  100ea7:	8b 45 08             	mov    0x8(%ebp),%eax
  100eaa:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  100eaf:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile (
  100eb2:	9c                   	pushf  
  100eb3:	fa                   	cli    
  100eb4:	59                   	pop    %ecx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
  100eb5:	8b 10                	mov    (%eax),%edx
  100eb7:	30 d2                	xor    %dl,%dl
  100eb9:	0b 55 0c             	or     0xc(%ebp),%edx
  100ebc:	0f ba e1 09          	bt     $0x9,%ecx
  100ec0:	89 10                	mov    %edx,(%eax)
  100ec2:	73 01                	jae    100ec5 <_loapic_int_vec_set+0x21>
	__asm__ volatile (
  100ec4:	fb                   	sti    
	irq_unlock(oldLevel);
}
  100ec5:	5d                   	pop    %ebp
  100ec6:	c3                   	ret    

00100ec7 <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
  100ec7:	55                   	push   %ebp
  100ec8:	89 e5                	mov    %esp,%ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
  100eca:	8b 45 08             	mov    0x8(%ebp),%eax
  100ecd:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  100ed2:	c1 e0 04             	shl    $0x4,%eax
	__asm__ volatile (
  100ed5:	9c                   	pushf  
  100ed6:	fa                   	cli    
  100ed7:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
  100ed8:	8b 10                	mov    (%eax),%edx
  100eda:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
  100ee0:	0f ba e1 09          	bt     $0x9,%ecx
  100ee4:	89 10                	mov    %edx,(%eax)
  100ee6:	73 01                	jae    100ee9 <_loapic_irq_enable+0x22>
	__asm__ volatile (
  100ee8:	fb                   	sti    
	irq_unlock(oldLevel);
}
  100ee9:	5d                   	pop    %ebp
  100eea:	c3                   	ret    

00100eeb <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
  100eeb:	55                   	push   %ebp
  100eec:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
  100ef1:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  100ef3:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
  100ef8:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
  100efa:	85 d2                	test   %edx,%edx
  100efc:	74 11                	je     100f0f <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
  100efe:	0f bd d2             	bsr    %edx,%edx
  100f01:	75 05                	jne    100f08 <__irq_controller_isr_vector_get+0x1d>
  100f03:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
  100f08:	c1 e0 05             	shl    $0x5,%eax
  100f0b:	01 d0                	add    %edx,%eax
  100f0d:	eb 09                	jmp    100f18 <__irq_controller_isr_vector_get+0x2d>
  100f0f:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
  100f12:	48                   	dec    %eax
  100f13:	75 e3                	jne    100ef8 <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
  100f15:	83 c8 ff             	or     $0xffffffff,%eax
}
  100f18:	5d                   	pop    %ebp
  100f19:	c3                   	ret    

00100f1a <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
  100f1a:	55                   	push   %ebp
  100f1b:	89 e5                	mov    %esp,%ebp
  100f1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  100f20:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  100f23:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (IS_IOAPIC_IRQ(irq)) {
  100f26:	83 f8 17             	cmp    $0x17,%eax
  100f29:	77 09                	ja     100f34 <__irq_controller_irq_config+0x1a>
		_ioapic_irq_set(irq, vector, flags);
  100f2b:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
  100f2e:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
  100f2f:	e9 af 00 00 00       	jmp    100fe3 <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  100f34:	83 e8 18             	sub    $0x18,%eax
  100f37:	89 45 08             	mov    %eax,0x8(%ebp)
}
  100f3a:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  100f3b:	e9 64 ff ff ff       	jmp    100ea4 <_loapic_int_vec_set>

00100f40 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
  100f40:	55                   	push   %ebp
  100f41:	89 e5                	mov    %esp,%ebp
  100f43:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  100f46:	83 f8 17             	cmp    $0x17,%eax
  100f49:	77 06                	ja     100f51 <_arch_irq_enable+0x11>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
  100f4b:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
  100f4c:	e9 7f 00 00 00       	jmp    100fd0 <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  100f51:	83 e8 18             	sub    $0x18,%eax
  100f54:	89 45 08             	mov    %eax,0x8(%ebp)
}
  100f57:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  100f58:	e9 6a ff ff ff       	jmp    100ec7 <_loapic_irq_enable>

00100f5d <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
  100f5d:	55                   	push   %ebp
  100f5e:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  100f60:	9c                   	pushf  
  100f61:	fa                   	cli    
  100f62:	59                   	pop    %ecx
  100f63:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
  100f67:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
  100f6c:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
  100f72:	73 01                	jae    100f75 <__IoApicSet+0x18>
	__asm__ volatile (
  100f74:	fb                   	sti    

	irq_unlock(key);
}
  100f75:	5d                   	pop    %ebp
  100f76:	c3                   	ret    

00100f77 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  100f77:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  100f78:	01 c0                	add    %eax,%eax
{
  100f7a:	89 e5                	mov    %esp,%ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  100f7c:	83 c0 10             	add    $0x10,%eax
{
  100f7f:	56                   	push   %esi
  100f80:	53                   	push   %ebx
	__asm__ volatile (
  100f81:	9c                   	pushf  
  100f82:	fa                   	cli    
  100f83:	5e                   	pop    %esi
  100f84:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
  100f88:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
  100f8d:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
  100f93:	73 01                	jae    100f96 <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
  100f95:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
  100f96:	31 da                	xor    %ebx,%edx
  100f98:	21 ca                	and    %ecx,%edx
  100f9a:	31 da                	xor    %ebx,%edx
}
  100f9c:	5b                   	pop    %ebx
  100f9d:	5e                   	pop    %esi
  100f9e:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
  100f9f:	e9 b9 ff ff ff       	jmp    100f5d <__IoApicSet>

00100fa4 <_ioapic_init>:
{
  100fa4:	55                   	push   %ebp
  100fa5:	89 e5                	mov    %esp,%ebp
  100fa7:	53                   	push   %ebx
  100fa8:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
  100fad:	31 d2                	xor    %edx,%edx
  100faf:	89 d8                	mov    %ebx,%eax
  100fb1:	e8 a7 ff ff ff       	call   100f5d <__IoApicSet>
	__IoApicSet(offset, lower32);
  100fb6:	8d 43 ff             	lea    -0x1(%ebx),%eax
  100fb9:	ba 00 00 01 00       	mov    $0x10000,%edx
  100fbe:	83 c3 02             	add    $0x2,%ebx
  100fc1:	e8 97 ff ff ff       	call   100f5d <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  100fc6:	83 fb 41             	cmp    $0x41,%ebx
  100fc9:	75 e2                	jne    100fad <_ioapic_init+0x9>
}
  100fcb:	31 c0                	xor    %eax,%eax
  100fcd:	5b                   	pop    %ebx
  100fce:	5d                   	pop    %ebp
  100fcf:	c3                   	ret    

00100fd0 <_ioapic_irq_enable>:
{
  100fd0:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100fd1:	b9 00 00 01 00       	mov    $0x10000,%ecx
{
  100fd6:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100fd8:	31 d2                	xor    %edx,%edx
  100fda:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100fdd:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100fde:	e9 94 ff ff ff       	jmp    100f77 <_IoApicRedUpdateLo>

00100fe3 <_ioapic_irq_set>:
{
  100fe3:	55                   	push   %ebp
	__IoApicSet(offset, upper32);
  100fe4:	31 d2                	xor    %edx,%edx
{
  100fe6:	89 e5                	mov    %esp,%ebp
  100fe8:	56                   	push   %esi
  100fe9:	53                   	push   %ebx
  100fea:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  100fed:	01 db                	add    %ebx,%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
  100fef:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  100ff3:	8d 43 11             	lea    0x11(%ebx),%eax
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  100ff6:	0b 75 10             	or     0x10(%ebp),%esi
	__IoApicSet(offset, upper32);
  100ff9:	e8 5f ff ff ff       	call   100f5d <__IoApicSet>
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  100ffe:	81 ce 00 00 01 00    	or     $0x10000,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  101004:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
  101007:	89 f2                	mov    %esi,%edx
}
  101009:	5b                   	pop    %ebx
  10100a:	5e                   	pop    %esi
  10100b:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
  10100c:	e9 4c ff ff ff       	jmp    100f5d <__IoApicSet>

00101011 <slip_init>:

	return buf;
}

static int slip_init(struct device *dev)
{
  101011:	55                   	push   %ebp
  101012:	89 e5                	mov    %esp,%ebp
	struct slip_context *slip = dev->driver_data;
  101014:	8b 45 08             	mov    0x8(%ebp),%eax
  101017:	8b 40 08             	mov    0x8(%eax),%eax

#if defined(CONFIG_SLIP_TAP) && defined(CONFIG_NET_IPV4)
	SYS_LOG_DBG("ARP enabled");
#endif

	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
  10101a:	83 c0 02             	add    $0x2,%eax
	slip->state = STATE_OK;
  10101d:	c6 40 0e 01          	movb   $0x1,0xe(%eax)
	slip->rx = NULL;
  101021:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	slip->first = false;
  101028:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
  10102c:	68 40 10 10 00       	push   $0x101040
  101031:	6a 01                	push   $0x1
  101033:	50                   	push   %eax
  101034:	e8 d1 f8 ff ff       	call   10090a <uart_pipe_register>
  101039:	83 c4 0c             	add    $0xc,%esp

	return 0;
}
  10103c:	31 c0                	xor    %eax,%eax
  10103e:	c9                   	leave  
  10103f:	c3                   	ret    

00101040 <recv_cb>:
{
  101040:	55                   	push   %ebp
  101041:	89 e5                	mov    %esp,%ebp
  101043:	57                   	push   %edi
  101044:	56                   	push   %esi
  101045:	53                   	push   %ebx
  101046:	53                   	push   %ebx
  101047:	31 f6                	xor    %esi,%esi
  101049:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!slip->init_done) {
  10104c:	80 7f fe 00          	cmpb   $0x0,-0x2(%edi)
  101050:	0f 84 b0 01 00 00    	je     101206 <recv_cb+0x1c6>
	for (i = 0; i < *off; i++) {
  101056:	8b 45 0c             	mov    0xc(%ebp),%eax
  101059:	3b 30                	cmp    (%eax),%esi
  10105b:	0f 83 a5 01 00 00    	jae    101206 <recv_cb+0x1c6>
	switch (slip->state) {
  101061:	8a 47 0e             	mov    0xe(%edi),%al
		if (slip_input_byte(slip, buf[i])) {
  101064:	0f b6 1c 37          	movzbl (%edi,%esi,1),%ebx
	switch (slip->state) {
  101068:	3c 01                	cmp    $0x1,%al
  10106a:	74 49                	je     1010b5 <recv_cb+0x75>
  10106c:	72 09                	jb     101077 <recv_cb+0x37>
  10106e:	3c 02                	cmp    $0x2,%al
  101070:	74 17                	je     101089 <recv_cb+0x49>
  101072:	e9 d1 00 00 00       	jmp    101148 <recv_cb+0x108>
		if (c == SLIP_END) {
  101077:	80 fb c0             	cmp    $0xc0,%bl
  10107a:	0f 85 80 01 00 00    	jne    101200 <recv_cb+0x1c0>
			slip->state = STATE_OK;
  101080:	c6 47 0e 01          	movb   $0x1,0xe(%edi)
  101084:	e9 77 01 00 00       	jmp    101200 <recv_cb+0x1c0>
		if (c == SLIP_ESC_END) {
  101089:	80 fb dc             	cmp    $0xdc,%bl
  10108c:	74 12                	je     1010a0 <recv_cb+0x60>
		} else if (c == SLIP_ESC_ESC) {
  10108e:	80 fb dd             	cmp    $0xdd,%bl
  101091:	74 14                	je     1010a7 <recv_cb+0x67>
			SLIP_STATS(slip->garbage++);
  101093:	66 ff 47 1e          	incw   0x1e(%edi)
			slip->state = STATE_GARBAGE;
  101097:	c6 47 0e 00          	movb   $0x0,0xe(%edi)
  10109b:	e9 60 01 00 00       	jmp    101200 <recv_cb+0x1c0>
			c = SLIP_END;
  1010a0:	bb c0 00 00 00       	mov    $0xc0,%ebx
  1010a5:	eb 05                	jmp    1010ac <recv_cb+0x6c>
			c = SLIP_ESC;
  1010a7:	bb db 00 00 00       	mov    $0xdb,%ebx
		slip->state = STATE_OK;
  1010ac:	c6 47 0e 01          	movb   $0x1,0xe(%edi)
  1010b0:	e9 93 00 00 00       	jmp    101148 <recv_cb+0x108>
		if (c == SLIP_ESC) {
  1010b5:	80 fb db             	cmp    $0xdb,%bl
  1010b8:	75 09                	jne    1010c3 <recv_cb+0x83>
			slip->state = STATE_ESC;
  1010ba:	c6 47 0e 02          	movb   $0x2,0xe(%edi)
  1010be:	e9 3d 01 00 00       	jmp    101200 <recv_cb+0x1c0>
		if (c == SLIP_END) {
  1010c3:	80 fb c0             	cmp    $0xc0,%bl
  1010c6:	75 18                	jne    1010e0 <recv_cb+0xa0>
			if (slip->rx) {
  1010c8:	8b 5f 02             	mov    0x2(%edi),%ebx
			slip->state = STATE_OK;
  1010cb:	c6 47 0e 01          	movb   $0x1,0xe(%edi)
			slip->first = false;
  1010cf:	c6 47 ff 00          	movb   $0x0,-0x1(%edi)
			if (slip->rx) {
  1010d3:	85 db                	test   %ebx,%ebx
  1010d5:	0f 85 e3 00 00 00    	jne    1011be <recv_cb+0x17e>
  1010db:	e9 20 01 00 00       	jmp    101200 <recv_cb+0x1c0>
		if (slip->first && !slip->rx) {
  1010e0:	80 7f ff 00          	cmpb   $0x0,-0x1(%edi)
  1010e4:	74 0b                	je     1010f1 <recv_cb+0xb1>
  1010e6:	83 7f 02 00          	cmpl   $0x0,0x2(%edi)
  1010ea:	75 5c                	jne    101148 <recv_cb+0x108>
  1010ec:	e9 0f 01 00 00       	jmp    101200 <recv_cb+0x1c0>
			slip->first = true;
  1010f1:	c6 47 ff 01          	movb   $0x1,-0x1(%edi)
			slip->rx = net_nbuf_get_reserve_rx(0, K_NO_WAIT);
  1010f5:	6a 00                	push   $0x0
  1010f7:	6a 00                	push   $0x0
  1010f9:	e8 f7 21 00 00       	call   1032f5 <net_nbuf_get_reserve_rx>
  1010fe:	5a                   	pop    %edx
			if (!slip->rx) {
  1010ff:	85 c0                	test   %eax,%eax
			slip->rx = net_nbuf_get_reserve_rx(0, K_NO_WAIT);
  101101:	59                   	pop    %ecx
  101102:	89 47 02             	mov    %eax,0x2(%edi)
			if (!slip->rx) {
  101105:	0f 84 f5 00 00 00    	je     101200 <recv_cb+0x1c0>
			slip->last = net_nbuf_get_reserve_data(0, K_NO_WAIT);
  10110b:	6a 00                	push   $0x0
  10110d:	6a 00                	push   $0x0
  10110f:	e8 0b 22 00 00       	call   10331f <net_nbuf_get_reserve_data>
  101114:	5a                   	pop    %edx
			if (!slip->last) {
  101115:	85 c0                	test   %eax,%eax
			slip->last = net_nbuf_get_reserve_data(0, K_NO_WAIT);
  101117:	59                   	pop    %ecx
  101118:	89 47 06             	mov    %eax,0x6(%edi)
			if (!slip->last) {
  10111b:	75 15                	jne    101132 <recv_cb+0xf2>
				net_nbuf_unref(slip->rx);
  10111d:	ff 77 02             	pushl  0x2(%edi)
  101120:	e8 37 22 00 00       	call   10335c <net_nbuf_unref>
  101125:	58                   	pop    %eax
				slip->rx = NULL;
  101126:	c7 47 02 00 00 00 00 	movl   $0x0,0x2(%edi)
  10112d:	e9 ce 00 00 00       	jmp    101200 <recv_cb+0x1c0>
			net_buf_frag_add(slip->rx, slip->last);
  101132:	50                   	push   %eax
  101133:	ff 77 02             	pushl  0x2(%edi)
  101136:	e8 53 0a 00 00       	call   101b8e <net_buf_frag_add>
  10113b:	59                   	pop    %ecx
  10113c:	58                   	pop    %eax
	buf->len = len;
}

static inline uint8_t *net_nbuf_ip_data(struct net_buf *buf)
{
	return buf->frags->data;
  10113d:	8b 47 02             	mov    0x2(%edi),%eax
  101140:	8b 00                	mov    (%eax),%eax
			slip->ptr = net_nbuf_ip_data(slip->rx);
  101142:	8b 40 10             	mov    0x10(%eax),%eax
  101145:	89 47 0a             	mov    %eax,0xa(%edi)
	if (!net_buf_tailroom(slip->last)) {
  101148:	8b 47 06             	mov    0x6(%edi),%eax
  10114b:	83 c0 10             	add    $0x10,%eax
  10114e:	50                   	push   %eax
  10114f:	e8 e4 0a 00 00       	call   101c38 <net_buf_simple_tailroom>
  101154:	5a                   	pop    %edx
  101155:	85 c0                	test   %eax,%eax
  101157:	75 42                	jne    10119b <recv_cb+0x15b>
		frag = net_nbuf_get_reserve_data(0, K_NO_WAIT);
  101159:	6a 00                	push   $0x0
  10115b:	6a 00                	push   $0x0
  10115d:	e8 bd 21 00 00       	call   10331f <net_nbuf_get_reserve_data>
  101162:	5a                   	pop    %edx
		if (!frag) {
  101163:	85 c0                	test   %eax,%eax
		frag = net_nbuf_get_reserve_data(0, K_NO_WAIT);
  101165:	59                   	pop    %ecx
		if (!frag) {
  101166:	75 19                	jne    101181 <recv_cb+0x141>
			net_nbuf_unref(slip->rx);
  101168:	ff 77 02             	pushl  0x2(%edi)
  10116b:	e8 ec 21 00 00       	call   10335c <net_nbuf_unref>
  101170:	58                   	pop    %eax
			slip->rx = NULL;
  101171:	c7 47 02 00 00 00 00 	movl   $0x0,0x2(%edi)
			slip->last = NULL;
  101178:	c7 47 06 00 00 00 00 	movl   $0x0,0x6(%edi)
  10117f:	eb 7f                	jmp    101200 <recv_cb+0x1c0>
		net_buf_frag_insert(slip->last, frag);
  101181:	50                   	push   %eax
  101182:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101185:	ff 77 06             	pushl  0x6(%edi)
  101188:	e8 dc 09 00 00       	call   101b69 <net_buf_frag_insert>
  10118d:	59                   	pop    %ecx
  10118e:	58                   	pop    %eax
		slip->last = frag;
  10118f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101192:	89 47 06             	mov    %eax,0x6(%edi)
		slip->ptr = slip->last->data;
  101195:	8b 40 10             	mov    0x10(%eax),%eax
  101198:	89 47 0a             	mov    %eax,0xa(%edi)
	if (slip->ptr < slip->last->data) {
  10119b:	8b 47 06             	mov    0x6(%edi),%eax
  10119e:	8b 4f 0a             	mov    0xa(%edi),%ecx
  1011a1:	3b 48 10             	cmp    0x10(%eax),%ecx
  1011a4:	73 04                	jae    1011aa <recv_cb+0x16a>
		*slip->ptr = c;
  1011a6:	88 19                	mov    %bl,(%ecx)
  1011a8:	eb 0f                	jmp    1011b9 <recv_cb+0x179>
		slip->ptr = net_buf_add_u8(slip->last, c);
  1011aa:	83 c0 10             	add    $0x10,%eax
  1011ad:	53                   	push   %ebx
  1011ae:	50                   	push   %eax
  1011af:	e8 48 0a 00 00       	call   101bfc <net_buf_simple_add_u8>
  1011b4:	5b                   	pop    %ebx
  1011b5:	5a                   	pop    %edx
  1011b6:	89 47 0a             	mov    %eax,0xa(%edi)
	slip->ptr++;
  1011b9:	ff 47 0a             	incl   0xa(%edi)
  1011bc:	eb 42                	jmp    101200 <recv_cb+0x1c0>
	if (slip->last && slip->last->len) {
  1011be:	8b 47 06             	mov    0x6(%edi),%eax
  1011c1:	85 c0                	test   %eax,%eax
  1011c3:	74 41                	je     101206 <recv_cb+0x1c6>
  1011c5:	66 83 78 14 00       	cmpw   $0x0,0x14(%eax)
  1011ca:	74 3a                	je     101206 <recv_cb+0x1c6>
	if (!buf || !buf->frags) {
  1011cc:	83 3b 00             	cmpl   $0x0,(%ebx)
  1011cf:	74 35                	je     101206 <recv_cb+0x1c6>
	if (net_recv_data(net_if_get_by_link_addr(&slip->ll_addr), buf) < 0) {
  1011d1:	8d 47 16             	lea    0x16(%edi),%eax
  1011d4:	50                   	push   %eax
  1011d5:	e8 6d 0d 00 00       	call   101f47 <net_if_get_by_link_addr>
  1011da:	89 1c 24             	mov    %ebx,(%esp)
  1011dd:	50                   	push   %eax
  1011de:	e8 1b 0d 00 00       	call   101efe <net_recv_data>
  1011e3:	5a                   	pop    %edx
  1011e4:	85 c0                	test   %eax,%eax
  1011e6:	59                   	pop    %ecx
  1011e7:	79 07                	jns    1011f0 <recv_cb+0x1b0>
		net_nbuf_unref(buf);
  1011e9:	53                   	push   %ebx
  1011ea:	e8 6d 21 00 00       	call   10335c <net_nbuf_unref>
  1011ef:	58                   	pop    %eax
	slip->rx = slip->last = NULL;
  1011f0:	c7 47 06 00 00 00 00 	movl   $0x0,0x6(%edi)
  1011f7:	c7 47 02 00 00 00 00 	movl   $0x0,0x2(%edi)
  1011fe:	eb 06                	jmp    101206 <recv_cb+0x1c6>
	for (i = 0; i < *off; i++) {
  101200:	46                   	inc    %esi
  101201:	e9 50 fe ff ff       	jmp    101056 <recv_cb+0x16>
		*off = 0;
  101206:	8b 45 0c             	mov    0xc(%ebp),%eax
  101209:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  10120f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101212:	89 f8                	mov    %edi,%eax
  101214:	5b                   	pop    %ebx
  101215:	5e                   	pop    %esi
  101216:	5f                   	pop    %edi
  101217:	5d                   	pop    %ebp
  101218:	c3                   	ret    

00101219 <slip_writeb>:
{
  101219:	55                   	push   %ebp
  10121a:	89 e5                	mov    %esp,%ebp
  10121c:	52                   	push   %edx
	uart_pipe_send(&buf[0], 1);
  10121d:	6a 01                	push   $0x1
	uint8_t buf[1] = { c };
  10121f:	88 45 ff             	mov    %al,-0x1(%ebp)
	uart_pipe_send(&buf[0], 1);
  101222:	8d 45 ff             	lea    -0x1(%ebp),%eax
  101225:	50                   	push   %eax
  101226:	e8 af f6 ff ff       	call   1008da <uart_pipe_send>
  10122b:	59                   	pop    %ecx
  10122c:	58                   	pop    %eax
}
  10122d:	c9                   	leave  
  10122e:	c3                   	ret    

0010122f <slip_send>:
{
  10122f:	55                   	push   %ebp
  101230:	89 e5                	mov    %esp,%ebp
  101232:	57                   	push   %edi
  101233:	56                   	push   %esi
  101234:	53                   	push   %ebx
  101235:	83 ec 08             	sub    $0x8,%esp
 *
 *  @return Pointer to the user data of the buffer.
 */
static inline void *net_buf_user_data(struct net_buf *buf)
{
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101238:	8b 45 0c             	mov    0xc(%ebp),%eax
  10123b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10123e:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  101242:	8d 44 01 1b          	lea    0x1b(%ecx,%eax,1),%eax
  101246:	83 e0 fc             	and    $0xfffffffc,%eax
	if (!buf->frags) {
  101249:	83 39 00             	cmpl   $0x0,(%ecx)
	uint16_t ll_reserve = net_nbuf_ll_reserve(buf);
  10124c:	0f b6 40 28          	movzbl 0x28(%eax),%eax
  101250:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  101254:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
	if (!buf->frags) {
  101259:	0f 84 c9 00 00 00    	je     101328 <slip_send+0xf9>
	slip_writeb(SLIP_END);
  10125f:	b8 c0 00 00 00       	mov    $0xc0,%eax
  101264:	e8 b0 ff ff ff       	call   101219 <slip_writeb>
	for (frag = buf->frags; frag; frag = frag->frags) {
  101269:	8b 45 0c             	mov    0xc(%ebp),%eax
	bool send_header_once = false;
  10126c:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
	for (frag = buf->frags; frag; frag = frag->frags) {
  101270:	8b 18                	mov    (%eax),%ebx
  101272:	85 db                	test   %ebx,%ebx
  101274:	0f 84 99 00 00 00    	je     101313 <slip_send+0xe4>
		ptr = frag->data - ll_reserve;
  10127a:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  10127e:	8b 53 10             	mov    0x10(%ebx),%edx
  101281:	89 d7                	mov    %edx,%edi
  101283:	29 c7                	sub    %eax,%edi
		if (!send_header_once && ll_reserve) {
  101285:	66 83 7d f2 00       	cmpw   $0x0,-0xe(%ebp)
  10128a:	0f 95 c0             	setne  %al
  10128d:	31 f6                	xor    %esi,%esi
  10128f:	38 45 f1             	cmp    %al,-0xf(%ebp)
  101292:	73 1a                	jae    1012ae <slip_send+0x7f>
			for (i = 0; i < ll_reserve; i++) {
  101294:	66 39 75 f2          	cmp    %si,-0xe(%ebp)
  101298:	76 12                	jbe    1012ac <slip_send+0x7d>
				slip_writeb(*ptr++);
  10129a:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
  10129e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1012a1:	46                   	inc    %esi
  1012a2:	e8 72 ff ff ff       	call   101219 <slip_writeb>
  1012a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1012aa:	eb e8                	jmp    101294 <slip_send+0x65>
			for (i = 0; i < ll_reserve; i++) {
  1012ac:	89 d7                	mov    %edx,%edi
		if (net_if_get_mtu(iface) > net_buf_headroom(frag)) {
  1012ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1012b1:	0f b7 70 18          	movzwl 0x18(%eax),%esi
  1012b5:	8d 43 10             	lea    0x10(%ebx),%eax
  1012b8:	50                   	push   %eax
  1012b9:	e8 6b 09 00 00       	call   101c29 <net_buf_simple_headroom>
  1012be:	5a                   	pop    %edx
  1012bf:	39 c6                	cmp    %eax,%esi
  1012c1:	76 0d                	jbe    1012d0 <slip_send+0xa1>
			ptr = frag->data;
  1012c3:	8b 7b 10             	mov    0x10(%ebx),%edi
			send_header_once = true;
  1012c6:	c6 45 f1 01          	movb   $0x1,-0xf(%ebp)
			ll_reserve = 0;
  1012ca:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		for (i = 0; i < frag->len; ++i) {
  1012d0:	31 f6                	xor    %esi,%esi
  1012d2:	66 39 73 14          	cmp    %si,0x14(%ebx)
  1012d6:	76 34                	jbe    10130c <slip_send+0xdd>
			c = *ptr++;
  1012d8:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
			switch (c) {
  1012dc:	3c c0                	cmp    $0xc0,%al
  1012de:	74 15                	je     1012f5 <slip_send+0xc6>
  1012e0:	3c db                	cmp    $0xdb,%al
  1012e2:	75 20                	jne    101304 <slip_send+0xd5>
				slip_writeb(SLIP_ESC);
  1012e4:	b8 db 00 00 00       	mov    $0xdb,%eax
  1012e9:	e8 2b ff ff ff       	call   101219 <slip_writeb>
				slip_writeb(SLIP_ESC_ESC);
  1012ee:	b8 dd 00 00 00       	mov    $0xdd,%eax
  1012f3:	eb 0f                	jmp    101304 <slip_send+0xd5>
				slip_writeb(SLIP_ESC);
  1012f5:	b8 db 00 00 00       	mov    $0xdb,%eax
  1012fa:	e8 1a ff ff ff       	call   101219 <slip_writeb>
				slip_writeb(SLIP_ESC_END);
  1012ff:	b8 dc 00 00 00       	mov    $0xdc,%eax
				slip_writeb(c);
  101304:	e8 10 ff ff ff       	call   101219 <slip_writeb>
  101309:	46                   	inc    %esi
  10130a:	eb c6                	jmp    1012d2 <slip_send+0xa3>
	for (frag = buf->frags; frag; frag = frag->frags) {
  10130c:	8b 1b                	mov    (%ebx),%ebx
  10130e:	e9 5f ff ff ff       	jmp    101272 <slip_send+0x43>
	net_nbuf_unref(buf);
  101313:	ff 75 0c             	pushl  0xc(%ebp)
  101316:	e8 41 20 00 00       	call   10335c <net_nbuf_unref>
  10131b:	58                   	pop    %eax
	slip_writeb(SLIP_END);
  10131c:	b8 c0 00 00 00       	mov    $0xc0,%eax
  101321:	e8 f3 fe ff ff       	call   101219 <slip_writeb>
	return 0;
  101326:	31 c0                	xor    %eax,%eax
}
  101328:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10132b:	5b                   	pop    %ebx
  10132c:	5e                   	pop    %esi
  10132d:	5f                   	pop    %edi
  10132e:	5d                   	pop    %ebp
  10132f:	c3                   	ret    

00101330 <slip_iface_init>:

	return &slip->ll_addr;
}

static void slip_iface_init(struct net_if *iface)
{
  101330:	55                   	push   %ebp
  101331:	89 e5                	mov    %esp,%ebp
  101333:	56                   	push   %esi
  101334:	53                   	push   %ebx
  101335:	8b 75 08             	mov    0x8(%ebp),%esi
	struct slip_context *slip = net_if_get_device(iface)->driver_data;
  101338:	8b 06                	mov    (%esi),%eax
  10133a:	8b 58 08             	mov    0x8(%eax),%ebx
	if (slip->mac_addr[0] == 0x00) {
  10133d:	80 7b 11 00          	cmpb   $0x0,0x11(%ebx)
  101341:	75 1c                	jne    10135f <slip_iface_init+0x2f>
		slip->mac_addr[0] = 0x10;
  101343:	c6 43 11 10          	movb   $0x10,0x11(%ebx)
		slip->mac_addr[1] = 0x00;
  101347:	c6 43 12 00          	movb   $0x0,0x12(%ebx)
		slip->mac_addr[2] = 0x00;
  10134b:	c6 43 13 00          	movb   $0x0,0x13(%ebx)
		slip->mac_addr[3] = 0x00;
  10134f:	c6 43 14 00          	movb   $0x0,0x14(%ebx)
		slip->mac_addr[4] = 0x00;
  101353:	c6 43 15 00          	movb   $0x0,0x15(%ebx)
		slip->mac_addr[5] = sys_rand32_get();
  101357:	e8 49 f6 ff ff       	call   1009a5 <sys_rand32_get>
  10135c:	88 43 16             	mov    %al,0x16(%ebx)
	slip->ll_addr.addr = slip->mac_addr;
  10135f:	8d 43 11             	lea    0x11(%ebx),%eax
	slip->ll_addr.len = sizeof(slip->mac_addr);
  101362:	c6 43 1c 06          	movb   $0x6,0x1c(%ebx)
	slip->ll_addr.addr = slip->mac_addr;
  101366:	89 43 18             	mov    %eax,0x18(%ebx)
	struct net_linkaddr *ll_addr = slip_get_mac(slip);

	slip->init_done = true;
  101369:	c6 03 01             	movb   $0x1,(%ebx)
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10136c:	8b 56 04             	mov    0x4(%esi),%edx
 */
static inline int net_if_set_link_addr(struct net_if *iface,
				       uint8_t *addr, uint8_t len,
				       enum net_link_type type)
{
	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
  10136f:	80 e2 01             	and    $0x1,%dl
  101372:	75 0b                	jne    10137f <slip_iface_init+0x4f>
		return -EPERM;
	}

	iface->link_addr.addr = addr;
  101374:	89 46 10             	mov    %eax,0x10(%esi)
	iface->link_addr.len = len;
  101377:	c6 46 14 06          	movb   $0x6,0x14(%esi)
	iface->link_addr.type = type;
  10137b:	c6 46 15 03          	movb   $0x3,0x15(%esi)

	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
			     NET_LINK_ETHERNET);
}
  10137f:	5b                   	pop    %ebx
  101380:	5e                   	pop    %esi
  101381:	5d                   	pop    %ebp
  101382:	c3                   	ret    

00101383 <_stdout_hook_default>:
 */

#include <stdio.h>

static int _stdout_hook_default(int c)
{
  101383:	55                   	push   %ebp
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
  101384:	83 c8 ff             	or     $0xffffffff,%eax
{
  101387:	89 e5                	mov    %esp,%ebp
}
  101389:	5d                   	pop    %ebp
  10138a:	c3                   	ret    

0010138b <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
  10138b:	55                   	push   %ebp
  10138c:	89 e5                	mov    %esp,%ebp
	_stdout_hook = hook;
  10138e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101391:	5d                   	pop    %ebp
	_stdout_hook = hook;
  101392:	a3 08 8d 10 00       	mov    %eax,0x108d08
}
  101397:	c3                   	ret    

00101398 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
  101398:	55                   	push   %ebp
  101399:	89 e5                	mov    %esp,%ebp
  10139b:	53                   	push   %ebx
  10139c:	8b 55 0c             	mov    0xc(%ebp),%edx
  10139f:	8b 45 08             	mov    0x8(%ebp),%eax
	char tmp = (char) c;
  1013a2:	88 d3                	mov    %dl,%bl

	while ((*s != tmp) && (*s != '\0'))
  1013a4:	8a 08                	mov    (%eax),%cl
  1013a6:	38 cb                	cmp    %cl,%bl
  1013a8:	74 0d                	je     1013b7 <strchr+0x1f>
  1013aa:	84 c9                	test   %cl,%cl
  1013ac:	74 03                	je     1013b1 <strchr+0x19>
		s++;
  1013ae:	40                   	inc    %eax
  1013af:	eb f3                	jmp    1013a4 <strchr+0xc>

	return (*s == tmp) ? (char *) s : NULL;
  1013b1:	84 d2                	test   %dl,%dl
  1013b3:	74 02                	je     1013b7 <strchr+0x1f>
  1013b5:	31 c0                	xor    %eax,%eax
}
  1013b7:	5b                   	pop    %ebx
  1013b8:	5d                   	pop    %ebp
  1013b9:	c3                   	ret    

001013ba <strrchr>:
 *
 * @return pointer to last instance of found byte, or NULL if not found
 */

char *strrchr(const char *s, int c)
{
  1013ba:	55                   	push   %ebp
	char *match = NULL;
  1013bb:	31 c0                	xor    %eax,%eax
{
  1013bd:	89 e5                	mov    %esp,%ebp
  1013bf:	8b 55 08             	mov    0x8(%ebp),%edx

	do {
		if (*s == (char)c) {
  1013c2:	8a 0a                	mov    (%edx),%cl
  1013c4:	3a 4d 0c             	cmp    0xc(%ebp),%cl
  1013c7:	75 02                	jne    1013cb <strrchr+0x11>
  1013c9:	89 d0                	mov    %edx,%eax
			match = (char *)s;
		}
	} while (*s++);
  1013cb:	42                   	inc    %edx
  1013cc:	84 c9                	test   %cl,%cl
  1013ce:	75 f2                	jne    1013c2 <strrchr+0x8>

	return match;
}
  1013d0:	5d                   	pop    %ebp
  1013d1:	c3                   	ret    

001013d2 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
  1013d2:	55                   	push   %ebp
	size_t n = 0;
  1013d3:	31 c0                	xor    %eax,%eax
{
  1013d5:	89 e5                	mov    %esp,%ebp
  1013d7:	8b 55 08             	mov    0x8(%ebp),%edx

	while (*s != '\0') {
  1013da:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  1013de:	74 03                	je     1013e3 <strlen+0x11>
		s++;
		n++;
  1013e0:	40                   	inc    %eax
  1013e1:	eb f7                	jmp    1013da <strlen+0x8>
	}

	return n;
}
  1013e3:	5d                   	pop    %ebp
  1013e4:	c3                   	ret    

001013e5 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  1013e5:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  1013e6:	31 c9                	xor    %ecx,%ecx
{
  1013e8:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  1013ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1013ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  1013f0:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  1013f4:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
  1013f8:	38 d0                	cmp    %dl,%al
  1013fa:	75 08                	jne    101404 <strcmp+0x1f>
  1013fc:	41                   	inc    %ecx
  1013fd:	84 c0                	test   %al,%al
  1013ff:	75 e9                	jne    1013ea <strcmp+0x5>
  101401:	0f be d0             	movsbl %al,%edx
		s1++;
		s2++;
	}

	return *s1 - *s2;
  101404:	29 d0                	sub    %edx,%eax
}
  101406:	5d                   	pop    %ebp
  101407:	c3                   	ret    

00101408 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
  101408:	55                   	push   %ebp
  101409:	31 c0                	xor    %eax,%eax
  10140b:	89 e5                	mov    %esp,%ebp
  10140d:	53                   	push   %ebx
  10140e:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n)
  101411:	85 c9                	test   %ecx,%ecx
  101413:	74 1d                	je     101432 <memcmp+0x2a>
  101415:	8b 55 0c             	mov    0xc(%ebp),%edx
  101418:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;

	while ((--n > 0) && (*c1 == *c2)) {
  10141b:	49                   	dec    %ecx
  10141c:	75 0a                	jne    101428 <memcmp+0x20>
		c1++;
		c2++;
	}

	return *c1 - *c2;
  10141e:	0f be 00             	movsbl (%eax),%eax
  101421:	0f be 12             	movsbl (%edx),%edx
  101424:	29 d0                	sub    %edx,%eax
  101426:	eb 0a                	jmp    101432 <memcmp+0x2a>
	while ((--n > 0) && (*c1 == *c2)) {
  101428:	8a 1a                	mov    (%edx),%bl
  10142a:	38 18                	cmp    %bl,(%eax)
  10142c:	75 f0                	jne    10141e <memcmp+0x16>
		c1++;
  10142e:	40                   	inc    %eax
		c2++;
  10142f:	42                   	inc    %edx
  101430:	eb e9                	jmp    10141b <memcmp+0x13>
}
  101432:	5b                   	pop    %ebx
  101433:	5d                   	pop    %ebp
  101434:	c3                   	ret    

00101435 <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
  101435:	55                   	push   %ebp
  101436:	89 e5                	mov    %esp,%ebp
  101438:	56                   	push   %esi
  101439:	53                   	push   %ebx
  10143a:	8b 45 08             	mov    0x8(%ebp),%eax
  10143d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *dest = d;
	const char *src  = s;

	if ((size_t) (d - s) < n) {
  101440:	89 c1                	mov    %eax,%ecx
{
  101442:	8b 75 10             	mov    0x10(%ebp),%esi
	if ((size_t) (d - s) < n) {
  101445:	29 d9                	sub    %ebx,%ecx
  101447:	39 f1                	cmp    %esi,%ecx
  101449:	72 04                	jb     10144f <memmove+0x1a>
  10144b:	31 c9                	xor    %ecx,%ecx
  10144d:	eb 0d                	jmp    10145c <memmove+0x27>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
  10144f:	4e                   	dec    %esi
		while (n > 0) {
  101450:	85 f6                	test   %esi,%esi
			dest[n] = src[n];
  101452:	8a 0c 33             	mov    (%ebx,%esi,1),%cl
  101455:	88 0c 30             	mov    %cl,(%eax,%esi,1)
		while (n > 0) {
  101458:	75 f5                	jne    10144f <memmove+0x1a>
  10145a:	eb 0d                	jmp    101469 <memmove+0x34>
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
  10145c:	39 ce                	cmp    %ecx,%esi
  10145e:	74 09                	je     101469 <memmove+0x34>
			*dest = *src;
  101460:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
  101463:	88 14 08             	mov    %dl,(%eax,%ecx,1)
  101466:	41                   	inc    %ecx
  101467:	eb f3                	jmp    10145c <memmove+0x27>
			n--;
		}
	}

	return d;
}
  101469:	5b                   	pop    %ebx
  10146a:	5e                   	pop    %esi
  10146b:	5d                   	pop    %ebp
  10146c:	c3                   	ret    

0010146d <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  10146d:	55                   	push   %ebp
  10146e:	89 e5                	mov    %esp,%ebp
  101470:	57                   	push   %edi
  101471:	56                   	push   %esi
  101472:	53                   	push   %ebx
  101473:	8b 45 08             	mov    0x8(%ebp),%eax
  101476:	8b 55 0c             	mov    0xc(%ebp),%edx
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
  101479:	89 c1                	mov    %eax,%ecx
{
  10147b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
  10147e:	31 d1                	xor    %edx,%ecx
  101480:	80 e1 03             	and    $0x3,%cl
  101483:	75 3d                	jne    1014c2 <memcpy+0x55>
  101485:	89 c1                	mov    %eax,%ecx
  101487:	89 de                	mov    %ebx,%esi

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
  101489:	f6 c1 03             	test   $0x3,%cl
  10148c:	74 0f                	je     10149d <memcpy+0x30>
			if (n == 0) {
  10148e:	85 f6                	test   %esi,%esi
  101490:	74 41                	je     1014d3 <memcpy+0x66>
				return d;
			}
			*(d_byte++) = *(s_byte++);
  101492:	42                   	inc    %edx
  101493:	41                   	inc    %ecx
  101494:	8a 5a ff             	mov    -0x1(%edx),%bl
			n--;
  101497:	4e                   	dec    %esi
			*(d_byte++) = *(s_byte++);
  101498:	88 59 ff             	mov    %bl,-0x1(%ecx)
  10149b:	eb ec                	jmp    101489 <memcpy+0x1c>
  10149d:	31 db                	xor    %ebx,%ebx
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
  10149f:	89 f7                	mov    %esi,%edi
  1014a1:	29 df                	sub    %ebx,%edi
  1014a3:	83 ff 03             	cmp    $0x3,%edi
  1014a6:	76 0b                	jbe    1014b3 <memcpy+0x46>
			*(d_word++) = *(s_word++);
  1014a8:	8b 3c 1a             	mov    (%edx,%ebx,1),%edi
  1014ab:	89 3c 19             	mov    %edi,(%ecx,%ebx,1)
  1014ae:	83 c3 04             	add    $0x4,%ebx
  1014b1:	eb ec                	jmp    10149f <memcpy+0x32>
  1014b3:	89 f3                	mov    %esi,%ebx
  1014b5:	83 e6 fc             	and    $0xfffffffc,%esi
  1014b8:	83 e3 03             	and    $0x3,%ebx
		while (n >= sizeof(unsigned int)) {
  1014bb:	01 f2                	add    %esi,%edx
  1014bd:	8d 3c 31             	lea    (%ecx,%esi,1),%edi
  1014c0:	eb 02                	jmp    1014c4 <memcpy+0x57>
	unsigned char *d_byte = (unsigned char *)d;
  1014c2:	89 c7                	mov    %eax,%edi
  1014c4:	31 f6                	xor    %esi,%esi
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
  1014c6:	39 f3                	cmp    %esi,%ebx
  1014c8:	74 09                	je     1014d3 <memcpy+0x66>
		*(d_byte++) = *(s_byte++);
  1014ca:	8a 0c 32             	mov    (%edx,%esi,1),%cl
  1014cd:	88 0c 37             	mov    %cl,(%edi,%esi,1)
  1014d0:	46                   	inc    %esi
  1014d1:	eb f3                	jmp    1014c6 <memcpy+0x59>
		n--;
	}

	return d;
}
  1014d3:	5b                   	pop    %ebx
  1014d4:	5e                   	pop    %esi
  1014d5:	5f                   	pop    %edi
  1014d6:	5d                   	pop    %ebp
  1014d7:	c3                   	ret    

001014d8 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  1014d8:	55                   	push   %ebp
  1014d9:	89 e5                	mov    %esp,%ebp
  1014db:	57                   	push   %edi
  1014dc:	56                   	push   %esi
  1014dd:	53                   	push   %ebx
  1014de:	8b 55 0c             	mov    0xc(%ebp),%edx
  1014e1:	8b 5d 10             	mov    0x10(%ebp),%ebx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
  1014e4:	88 d0                	mov    %dl,%al
	unsigned char *d_byte = (unsigned char *)buf;
  1014e6:	8b 4d 08             	mov    0x8(%ebp),%ecx

	while (((unsigned int)d_byte) & 0x3) {
  1014e9:	f6 c1 03             	test   $0x3,%cl
  1014ec:	74 0b                	je     1014f9 <memset+0x21>
		if (n == 0) {
  1014ee:	85 db                	test   %ebx,%ebx
  1014f0:	74 41                	je     101533 <memset+0x5b>
			return buf;
		}
		*(d_byte++) = c_byte;
  1014f2:	41                   	inc    %ecx
		n--;
  1014f3:	4b                   	dec    %ebx
		*(d_byte++) = c_byte;
  1014f4:	88 41 ff             	mov    %al,-0x1(%ecx)
  1014f7:	eb f0                	jmp    1014e9 <memset+0x11>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
  1014f9:	0f b6 d2             	movzbl %dl,%edx

	c_word |= c_word << 8;
  1014fc:	89 d6                	mov    %edx,%esi
  1014fe:	c1 e6 08             	shl    $0x8,%esi
  101501:	09 f2                	or     %esi,%edx
	c_word |= c_word << 16;
  101503:	89 d6                	mov    %edx,%esi
  101505:	c1 e6 10             	shl    $0x10,%esi
  101508:	09 f2                	or     %esi,%edx

	while (n >= sizeof(unsigned int)) {
  10150a:	31 f6                	xor    %esi,%esi
  10150c:	89 df                	mov    %ebx,%edi
  10150e:	29 f7                	sub    %esi,%edi
  101510:	83 ff 03             	cmp    $0x3,%edi
  101513:	76 08                	jbe    10151d <memset+0x45>
		*(d_word++) = c_word;
  101515:	89 14 31             	mov    %edx,(%ecx,%esi,1)
  101518:	83 c6 04             	add    $0x4,%esi
  10151b:	eb ef                	jmp    10150c <memset+0x34>
  10151d:	89 da                	mov    %ebx,%edx
  10151f:	83 e3 fc             	and    $0xfffffffc,%ebx
  101522:	01 d9                	add    %ebx,%ecx
  101524:	83 e2 03             	and    $0x3,%edx
	while (n >= sizeof(unsigned int)) {
  101527:	31 db                	xor    %ebx,%ebx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
  101529:	39 da                	cmp    %ebx,%edx
  10152b:	74 06                	je     101533 <memset+0x5b>
		*(d_byte++) = c_byte;
  10152d:	88 04 19             	mov    %al,(%ecx,%ebx,1)
  101530:	43                   	inc    %ebx
  101531:	eb f6                	jmp    101529 <memset+0x51>
		n--;
	}

	return buf;
}
  101533:	5b                   	pop    %ebx
  101534:	8b 45 08             	mov    0x8(%ebp),%eax
  101537:	5e                   	pop    %esi
  101538:	5f                   	pop    %edi
  101539:	5d                   	pop    %ebp
  10153a:	c3                   	ret    

0010153b <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
  10153b:	55                   	push   %ebp
  10153c:	89 e5                	mov    %esp,%ebp
  10153e:	57                   	push   %edi
  10153f:	56                   	push   %esi
  101540:	53                   	push   %ebx
  101541:	83 ec 10             	sub    $0x10,%esp
  101544:	8b 75 10             	mov    0x10(%ebp),%esi
	register const char *s = nptr;
  101547:	8b 45 08             	mov    0x8(%ebp),%eax
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
  10154a:	8d 58 01             	lea    0x1(%eax),%ebx
  10154d:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
	return (((unsigned)c|32)-'a') < 26;
}

static inline int isspace(int c)
{
	return c == ' ' || ((unsigned)c-'\t') < 5;
  101551:	8d 51 f7             	lea    -0x9(%ecx),%edx
	} while (isspace(c));
  101554:	83 fa 04             	cmp    $0x4,%edx
  101557:	77 04                	ja     10155d <strtol+0x22>
  101559:	89 d8                	mov    %ebx,%eax
  10155b:	eb ed                	jmp    10154a <strtol+0xf>
  10155d:	83 f9 20             	cmp    $0x20,%ecx
  101560:	74 f7                	je     101559 <strtol+0x1e>
	if (c == '-') {
  101562:	83 f9 2d             	cmp    $0x2d,%ecx
  101565:	75 0f                	jne    101576 <strtol+0x3b>
		neg = 1;
		c = *s++;
  101567:	0f be 0b             	movsbl (%ebx),%ecx
		neg = 1;
  10156a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
  101571:	8d 58 02             	lea    0x2(%eax),%ebx
  101574:	eb 12                	jmp    101588 <strtol+0x4d>
	register int neg = 0, any, cutlim;
  101576:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	} else if (c == '+')
  10157d:	83 f9 2b             	cmp    $0x2b,%ecx
  101580:	75 06                	jne    101588 <strtol+0x4d>
		c = *s++;
  101582:	0f be 0b             	movsbl (%ebx),%ecx
  101585:	8d 58 02             	lea    0x2(%eax),%ebx
	if ((base == 0 || base == 16) &&
  101588:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
  10158e:	75 30                	jne    1015c0 <strtol+0x85>
  101590:	83 f9 30             	cmp    $0x30,%ecx
  101593:	75 17                	jne    1015ac <strtol+0x71>
	    c == '0' && (*s == 'x' || *s == 'X')) {
  101595:	8a 03                	mov    (%ebx),%al
  101597:	83 e0 df             	and    $0xffffffdf,%eax
  10159a:	3c 58                	cmp    $0x58,%al
  10159c:	75 19                	jne    1015b7 <strtol+0x7c>
		c = s[1];
  10159e:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
		s += 2;
		base = 16;
  1015a2:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
  1015a7:	83 c3 02             	add    $0x2,%ebx
  1015aa:	eb 14                	jmp    1015c0 <strtol+0x85>
	}
	if (base == 0)
  1015ac:	85 f6                	test   %esi,%esi
  1015ae:	75 10                	jne    1015c0 <strtol+0x85>
		base = c == '0' ? 8 : 10;
  1015b0:	be 0a 00 00 00       	mov    $0xa,%esi
  1015b5:	eb 09                	jmp    1015c0 <strtol+0x85>
	if (base == 0)
  1015b7:	85 f6                	test   %esi,%esi
  1015b9:	75 05                	jne    1015c0 <strtol+0x85>
		base = c == '0' ? 8 : 10;
  1015bb:	be 08 00 00 00       	mov    $0x8,%esi
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  1015c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
	cutlim = cutoff % (unsigned long)base;
  1015c3:	31 d2                	xor    %edx,%edx
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  1015c5:	05 ff ff ff 7f       	add    $0x7fffffff,%eax
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
  1015ca:	31 ff                	xor    %edi,%edi
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  1015cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cutlim = cutoff % (unsigned long)base;
  1015cf:	f7 f6                	div    %esi
  1015d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1015d4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (acc = 0, any = 0;; c = *s++) {
  1015d7:	31 c0                	xor    %eax,%eax
	return ((((unsigned)c) >= ' ') && (((unsigned)c) <= '~'));
}

static inline int isdigit(int a)
{
	return (((unsigned)(a)-'0') < 10);
  1015d9:	8d 51 d0             	lea    -0x30(%ecx),%edx
		if (isdigit(c))
  1015dc:	83 fa 09             	cmp    $0x9,%edx
  1015df:	77 04                	ja     1015e5 <strtol+0xaa>
			c -= '0';
  1015e1:	89 d1                	mov    %edx,%ecx
  1015e3:	eb 1d                	jmp    101602 <strtol+0xc7>
	return (((unsigned)c|32)-'a') < 26;
  1015e5:	89 ca                	mov    %ecx,%edx
  1015e7:	83 ca 20             	or     $0x20,%edx
  1015ea:	83 ea 61             	sub    $0x61,%edx
		else if (isalpha(c))
  1015ed:	83 fa 19             	cmp    $0x19,%edx
  1015f0:	77 41                	ja     101633 <strtol+0xf8>
	return ((unsigned)(a)-'A') < 26;
  1015f2:	8d 51 bf             	lea    -0x41(%ecx),%edx
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
  1015f5:	83 fa 1a             	cmp    $0x1a,%edx
  1015f8:	19 d2                	sbb    %edx,%edx
  1015fa:	83 e2 e0             	and    $0xffffffe0,%edx
  1015fd:	83 c2 57             	add    $0x57,%edx
  101600:	29 d1                	sub    %edx,%ecx
		else
			break;
		if (c >= base)
  101602:	39 ce                	cmp    %ecx,%esi
  101604:	7e 2d                	jle    101633 <strtol+0xf8>
			break;
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
  101606:	c1 ef 1f             	shr    $0x1f,%edi
  101609:	75 1e                	jne    101629 <strtol+0xee>
  10160b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10160e:	77 19                	ja     101629 <strtol+0xee>
  101610:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  101613:	75 08                	jne    10161d <strtol+0xe2>
			any = -1;
  101615:	83 cf ff             	or     $0xffffffff,%edi
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
  101618:	3b 4d e4             	cmp    -0x1c(%ebp),%ecx
  10161b:	7f 0f                	jg     10162c <strtol+0xf1>
		else {
			any = 1;
			acc *= base;
  10161d:	0f af c6             	imul   %esi,%eax
			any = 1;
  101620:	bf 01 00 00 00       	mov    $0x1,%edi
			acc += c;
  101625:	01 c8                	add    %ecx,%eax
  101627:	eb 03                	jmp    10162c <strtol+0xf1>
			any = -1;
  101629:	83 cf ff             	or     $0xffffffff,%edi
	for (acc = 0, any = 0;; c = *s++) {
  10162c:	43                   	inc    %ebx
  10162d:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
		if (isdigit(c))
  101631:	eb a6                	jmp    1015d9 <strtol+0x9e>
		}
	}
	if (any < 0) {
  101633:	83 ff ff             	cmp    $0xffffffff,%edi
  101636:	75 16                	jne    10164e <strtol+0x113>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
  101638:	e8 19 55 00 00       	call   106b56 <_get_errno>
	} else if (neg)
		acc = -acc;
	if (endptr != 0)
  10163d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
		errno = ERANGE;
  101641:	c7 00 26 00 00 00    	movl   $0x26,(%eax)
		acc = neg ? LONG_MIN : LONG_MAX;
  101647:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if (endptr != 0)
  10164a:	75 14                	jne    101660 <strtol+0x125>
  10164c:	eb 20                	jmp    10166e <strtol+0x133>
	} else if (neg)
  10164e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  101652:	74 02                	je     101656 <strtol+0x11b>
		acc = -acc;
  101654:	f7 d8                	neg    %eax
	if (endptr != 0)
  101656:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10165a:	74 12                	je     10166e <strtol+0x133>
		*endptr = (char *)(any ? s - 1 : nptr);
  10165c:	85 ff                	test   %edi,%edi
  10165e:	74 06                	je     101666 <strtol+0x12b>
  101660:	8d 73 ff             	lea    -0x1(%ebx),%esi
  101663:	89 75 08             	mov    %esi,0x8(%ebp)
  101666:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  101669:	8b 7d 08             	mov    0x8(%ebp),%edi
  10166c:	89 3b                	mov    %edi,(%ebx)
	return acc;
}
  10166e:	83 c4 10             	add    $0x10,%esp
  101671:	5b                   	pop    %ebx
  101672:	5e                   	pop    %esi
  101673:	5f                   	pop    %edi
  101674:	5d                   	pop    %ebp
  101675:	c3                   	ret    

00101676 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  101676:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  101677:	31 c0                	xor    %eax,%eax
{
  101679:	89 e5                	mov    %esp,%ebp
}
  10167b:	5d                   	pop    %ebp
  10167c:	c3                   	ret    

0010167d <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
  10167d:	55                   	push   %ebp
  10167e:	89 e5                	mov    %esp,%ebp
  101680:	8b 45 0c             	mov    0xc(%ebp),%eax
	ctx->count++;
  101683:	ff 00                	incl   (%eax)
	return _char_out(c);
}
  101685:	5d                   	pop    %ebp
	return _char_out(c);
  101686:	ff 25 0c 8d 10 00    	jmp    *0x108d0c

0010168c <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  10168c:	55                   	push   %ebp
  10168d:	89 e5                	mov    %esp,%ebp
  10168f:	57                   	push   %edi
  101690:	56                   	push   %esi
  101691:	53                   	push   %ebx
  101692:	83 ec 14             	sub    $0x14,%esp
  101695:	89 d6                	mov    %edx,%esi
  101697:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10169a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10169d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  1016a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1016a3:	85 db                	test   %ebx,%ebx
  1016a5:	7f 07                	jg     1016ae <_printk_dec_ulong+0x22>
  1016a7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  1016ae:	83 f8 01             	cmp    $0x1,%eax
  1016b1:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1016b4:	19 db                	sbb    %ebx,%ebx
  1016b6:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
  1016bd:	83 e3 f0             	and    $0xfffffff0,%ebx
  1016c0:	31 ff                	xor    %edi,%edi
  1016c2:	83 c3 30             	add    $0x30,%ebx
  1016c5:	c7 45 ec ff c9 9a 3b 	movl   $0x3b9ac9ff,-0x14(%ebp)
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  1016cc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1016cf:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  1016d2:	72 04                	jb     1016d8 <_printk_dec_ulong+0x4c>
  1016d4:	85 ff                	test   %edi,%edi
  1016d6:	74 20                	je     1016f8 <_printk_dec_ulong+0x6c>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  1016d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1016db:	31 d2                	xor    %edx,%edx
  1016dd:	56                   	push   %esi
  1016de:	8d 48 01             	lea    0x1(%eax),%ecx
  1016e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1016e4:	f7 f1                	div    %ecx
  1016e6:	83 c0 30             	add    $0x30,%eax
  1016e9:	50                   	push   %eax
  1016ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1016ed:	ff d0                	call   *%eax
  1016ef:	59                   	pop    %ecx
  1016f0:	5f                   	pop    %edi
			found_largest_digit = 1;
  1016f1:	bf 01 00 00 00       	mov    $0x1,%edi
  1016f6:	eb 13                	jmp    10170b <_printk_dec_ulong+0x7f>
		} else if (remaining <= min_width) {
  1016f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1016fb:	31 ff                	xor    %edi,%edi
  1016fd:	39 55 e8             	cmp    %edx,-0x18(%ebp)
  101700:	7c 09                	jl     10170b <_printk_dec_ulong+0x7f>
			out((int)(pad_zero ? '0' : ' '), ctx);
  101702:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101705:	56                   	push   %esi
  101706:	53                   	push   %ebx
  101707:	ff d0                	call   *%eax
  101709:	58                   	pop    %eax
  10170a:	5a                   	pop    %edx
		}
		remaining--;
		remainder %= (pos + 1);
  10170b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10170e:	31 d2                	xor    %edx,%edx
		remaining--;
  101710:	ff 4d e4             	decl   -0x1c(%ebp)
		remainder %= (pos + 1);
  101713:	8d 48 01             	lea    0x1(%eax),%ecx
  101716:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101719:	f7 f1                	div    %ecx
  10171b:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
  10171e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101721:	31 d2                	xor    %edx,%edx
  101723:	b9 0a 00 00 00       	mov    $0xa,%ecx
  101728:	f7 f1                	div    %ecx
  10172a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	while (pos >= 9) {
  10172d:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
  101731:	75 99                	jne    1016cc <_printk_dec_ulong+0x40>
	}
	out((int)(remainder + 48), ctx);
  101733:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101736:	89 75 0c             	mov    %esi,0xc(%ebp)
  101739:	83 c1 30             	add    $0x30,%ecx
  10173c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10173f:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
  101742:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101745:	5b                   	pop    %ebx
  101746:	5e                   	pop    %esi
  101747:	5f                   	pop    %edi
  101748:	5d                   	pop    %ebp
	out((int)(remainder + 48), ctx);
  101749:	ff e0                	jmp    *%eax

0010174b <__printk_hook_install>:
{
  10174b:	55                   	push   %ebp
  10174c:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
  10174e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101751:	5d                   	pop    %ebp
	_char_out = fn;
  101752:	a3 0c 8d 10 00       	mov    %eax,0x108d0c
}
  101757:	c3                   	ret    

00101758 <_vprintk>:
{
  101758:	55                   	push   %ebp
  101759:	89 e5                	mov    %esp,%ebp
  10175b:	57                   	push   %edi
  10175c:	56                   	push   %esi
  10175d:	53                   	push   %ebx
  10175e:	83 ec 1c             	sub    $0x1c,%esp
	int might_format = 0; /* 1 if encountered a '%' */
  101761:	31 db                	xor    %ebx,%ebx
{
  101763:	8b 7d 08             	mov    0x8(%ebp),%edi
  101766:	8b 75 14             	mov    0x14(%ebp),%esi
	int min_width = -1;
  101769:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	int pad_zero = 0;
  101770:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	while (*fmt) {
  101777:	8b 45 10             	mov    0x10(%ebp),%eax
  10177a:	0f be 00             	movsbl (%eax),%eax
  10177d:	84 c0                	test   %al,%al
  10177f:	0f 84 2b 02 00 00    	je     1019b0 <_vprintk+0x258>
		if (!might_format) {
  101785:	85 db                	test   %ebx,%ebx
  101787:	75 15                	jne    10179e <_vprintk+0x46>
			if (*fmt != '%') {
  101789:	3c 25                	cmp    $0x25,%al
  10178b:	0f 84 ff 01 00 00    	je     101990 <_vprintk+0x238>
				out((int)*fmt, ctx);
  101791:	ff 75 0c             	pushl  0xc(%ebp)
  101794:	50                   	push   %eax
  101795:	ff d7                	call   *%edi
  101797:	59                   	pop    %ecx
  101798:	58                   	pop    %eax
  101799:	e9 0a 02 00 00       	jmp    1019a8 <_vprintk+0x250>
			switch (*fmt) {
  10179e:	3c 68                	cmp    $0x68,%al
  1017a0:	0f 84 02 02 00 00    	je     1019a8 <_vprintk+0x250>
  1017a6:	7f 3a                	jg     1017e2 <_vprintk+0x8a>
  1017a8:	3c 39                	cmp    $0x39,%al
  1017aa:	7f 19                	jg     1017c5 <_vprintk+0x6d>
  1017ac:	3c 31                	cmp    $0x31,%al
  1017ae:	0f 8d 89 00 00 00    	jge    10183d <_vprintk+0xe5>
  1017b4:	3c 25                	cmp    $0x25,%al
  1017b6:	0f 84 b2 01 00 00    	je     10196e <_vprintk+0x216>
  1017bc:	3c 30                	cmp    $0x30,%al
  1017be:	74 6b                	je     10182b <_vprintk+0xd3>
  1017c0:	e9 b0 01 00 00       	jmp    101975 <_vprintk+0x21d>
  1017c5:	3c 63                	cmp    $0x63,%al
  1017c7:	0f 84 92 01 00 00    	je     10195f <_vprintk+0x207>
  1017cd:	3c 64                	cmp    $0x64,%al
  1017cf:	0f 84 83 00 00 00    	je     101858 <_vprintk+0x100>
  1017d5:	3c 58                	cmp    $0x58,%al
  1017d7:	0f 85 98 01 00 00    	jne    101975 <_vprintk+0x21d>
  1017dd:	e9 c4 00 00 00       	jmp    1018a6 <_vprintk+0x14e>
  1017e2:	3c 73                	cmp    $0x73,%al
  1017e4:	0f 84 5a 01 00 00    	je     101944 <_vprintk+0x1ec>
  1017ea:	7f 1a                	jg     101806 <_vprintk+0xae>
  1017ec:	3c 6c                	cmp    $0x6c,%al
  1017ee:	0f 84 b4 01 00 00    	je     1019a8 <_vprintk+0x250>
  1017f4:	3c 70                	cmp    $0x70,%al
  1017f6:	0f 84 8e 00 00 00    	je     10188a <_vprintk+0x132>
  1017fc:	3c 69                	cmp    $0x69,%al
  1017fe:	0f 85 71 01 00 00    	jne    101975 <_vprintk+0x21d>
  101804:	eb 52                	jmp    101858 <_vprintk+0x100>
  101806:	3c 78                	cmp    $0x78,%al
  101808:	0f 84 98 00 00 00    	je     1018a6 <_vprintk+0x14e>
  10180e:	3c 7a                	cmp    $0x7a,%al
  101810:	0f 84 92 01 00 00    	je     1019a8 <_vprintk+0x250>
  101816:	3c 75                	cmp    $0x75,%al
  101818:	0f 85 57 01 00 00    	jne    101975 <_vprintk+0x21d>
				_printk_dec_ulong(out, ctx, u, pad_zero,
  10181e:	ff 75 f0             	pushl  -0x10(%ebp)
				unsigned long u = va_arg(
  101821:	8d 5e 04             	lea    0x4(%esi),%ebx
				_printk_dec_ulong(out, ctx, u, pad_zero,
  101824:	8b 0e                	mov    (%esi),%ecx
  101826:	ff 75 ec             	pushl  -0x14(%ebp)
  101829:	eb 4c                	jmp    101877 <_vprintk+0x11f>
				if (min_width < 0 && pad_zero == 0) {
  10182b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10182e:	c1 ea 1f             	shr    $0x1f,%edx
  101831:	74 0a                	je     10183d <_vprintk+0xe5>
  101833:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  101837:	0f 84 68 01 00 00    	je     1019a5 <_vprintk+0x24d>
				if (min_width < 0) {
  10183d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  101841:	79 05                	jns    101848 <_vprintk+0xf0>
					min_width = *fmt - '0';
  101843:	83 e8 30             	sub    $0x30,%eax
  101846:	eb 08                	jmp    101850 <_vprintk+0xf8>
					min_width = 10 * min_width + *fmt - '0';
  101848:	6b 55 f0 0a          	imul   $0xa,-0x10(%ebp),%edx
  10184c:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
  101850:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101853:	e9 50 01 00 00       	jmp    1019a8 <_vprintk+0x250>
				long d = va_arg(ap, long);
  101858:	8d 5e 04             	lea    0x4(%esi),%ebx
  10185b:	8b 36                	mov    (%esi),%esi
				if (d < 0) {
  10185d:	85 f6                	test   %esi,%esi
  10185f:	79 0e                	jns    10186f <_vprintk+0x117>
					out((int)'-', ctx);
  101861:	ff 75 0c             	pushl  0xc(%ebp)
  101864:	6a 2d                	push   $0x2d
  101866:	ff d7                	call   *%edi
					min_width--;
  101868:	ff 4d f0             	decl   -0x10(%ebp)
					out((int)'-', ctx);
  10186b:	58                   	pop    %eax
					d = -d;
  10186c:	f7 de                	neg    %esi
					out((int)'-', ctx);
  10186e:	5a                   	pop    %edx
				_printk_dec_ulong(out, ctx, d, pad_zero,
  10186f:	ff 75 f0             	pushl  -0x10(%ebp)
  101872:	ff 75 ec             	pushl  -0x14(%ebp)
  101875:	89 f1                	mov    %esi,%ecx
				_printk_dec_ulong(out, ctx, u, pad_zero,
  101877:	8b 55 0c             	mov    0xc(%ebp),%edx
  10187a:	89 f8                	mov    %edi,%eax
  10187c:	e8 0b fe ff ff       	call   10168c <_printk_dec_ulong>
  101881:	59                   	pop    %ecx
  101882:	5e                   	pop    %esi
				unsigned long u = va_arg(
  101883:	89 de                	mov    %ebx,%esi
  101885:	e9 02 01 00 00       	jmp    10198c <_vprintk+0x234>
				  out('0', ctx);
  10188a:	ff 75 0c             	pushl  0xc(%ebp)
  10188d:	6a 30                	push   $0x30
  10188f:	ff d7                	call   *%edi
  101891:	59                   	pop    %ecx
  101892:	58                   	pop    %eax
				  out('x', ctx);
  101893:	ff 75 0c             	pushl  0xc(%ebp)
  101896:	6a 78                	push   $0x78
  101898:	ff d7                	call   *%edi
  10189a:	58                   	pop    %eax
				  pad_zero = 1;
  10189b:	89 5d ec             	mov    %ebx,-0x14(%ebp)
				  out('x', ctx);
  10189e:	5a                   	pop    %edx
				  min_width = 8;
  10189f:	c7 45 f0 08 00 00 00 	movl   $0x8,-0x10(%ebp)
				unsigned long x = va_arg(
  1018a6:	8d 46 04             	lea    0x4(%esi),%eax
	int remaining = 8; /* 8 digits max */
  1018a9:	ba 08 00 00 00       	mov    $0x8,%edx
  1018ae:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
				unsigned long x = va_arg(
  1018b2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1018b5:	8b 06                	mov    (%esi),%eax
  1018b7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int found_largest_digit = 0;
  1018ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1018c1:	19 c0                	sbb    %eax,%eax
	int size = sizeof(num) * 2;
  1018c3:	be 08 00 00 00       	mov    $0x8,%esi
  1018c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1018cb:	83 65 e4 f0          	andl   $0xfffffff0,-0x1c(%ebp)
  1018cf:	83 45 e4 30          	addl   $0x30,-0x1c(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  1018d3:	4e                   	dec    %esi
  1018d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1018d7:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  1018de:	d3 e8                	shr    %cl,%eax
  1018e0:	89 c1                	mov    %eax,%ecx
		if (nibble || found_largest_digit || size == 1) {
  1018e2:	80 e1 0f             	and    $0xf,%cl
  1018e5:	75 0e                	jne    1018f5 <_vprintk+0x19d>
  1018e7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  1018eb:	75 08                	jne    1018f5 <_vprintk+0x19d>
  1018ed:	85 f6                	test   %esi,%esi
  1018ef:	75 29                	jne    10191a <_vprintk+0x1c2>
			nibble += nibble > 9 ? 87 : 48;
  1018f1:	b0 30                	mov    $0x30,%al
  1018f3:	eb 0d                	jmp    101902 <_vprintk+0x1aa>
  1018f5:	80 f9 09             	cmp    $0x9,%cl
  1018f8:	0f 9f c0             	setg   %al
  1018fb:	48                   	dec    %eax
  1018fc:	83 e0 d9             	and    $0xffffffd9,%eax
  1018ff:	83 c0 57             	add    $0x57,%eax
			out((int)nibble, ctx);
  101902:	ff 75 0c             	pushl  0xc(%ebp)
			nibble += nibble > 9 ? 87 : 48;
  101905:	01 c8                	add    %ecx,%eax
  101907:	89 55 d8             	mov    %edx,-0x28(%ebp)
			out((int)nibble, ctx);
  10190a:	0f b6 c0             	movzbl %al,%eax
  10190d:	50                   	push   %eax
  10190e:	ff d7                	call   *%edi
  101910:	58                   	pop    %eax
			found_largest_digit = 1;
  101911:	89 5d e8             	mov    %ebx,-0x18(%ebp)
			out((int)nibble, ctx);
  101914:	5a                   	pop    %edx
  101915:	8b 55 d8             	mov    -0x28(%ebp),%edx
  101918:	eb 21                	jmp    10193b <_vprintk+0x1e3>
		if (remaining-- <= min_width) {
  10191a:	8d 4a ff             	lea    -0x1(%edx),%ecx
  10191d:	39 55 f0             	cmp    %edx,-0x10(%ebp)
  101920:	7c 10                	jl     101932 <_vprintk+0x1da>
			out((int)(pad_zero ? '0' : ' '), ctx);
  101922:	ff 75 0c             	pushl  0xc(%ebp)
  101925:	ff 75 e4             	pushl  -0x1c(%ebp)
  101928:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10192b:	ff d7                	call   *%edi
  10192d:	59                   	pop    %ecx
		if (remaining-- <= min_width) {
  10192e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			out((int)(pad_zero ? '0' : ' '), ctx);
  101931:	58                   	pop    %eax
		if (remaining-- <= min_width) {
  101932:	89 ca                	mov    %ecx,%edx
  101934:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	for (; size; size--) {
  10193b:	85 f6                	test   %esi,%esi
  10193d:	75 94                	jne    1018d3 <_vprintk+0x17b>
				unsigned long x = va_arg(
  10193f:	8b 75 dc             	mov    -0x24(%ebp),%esi
  101942:	eb 48                	jmp    10198c <_vprintk+0x234>
				char *s = va_arg(ap, char *);
  101944:	8d 5e 04             	lea    0x4(%esi),%ebx
  101947:	8b 36                	mov    (%esi),%esi
				while (*s)
  101949:	0f be 06             	movsbl (%esi),%eax
  10194c:	84 c0                	test   %al,%al
  10194e:	0f 84 2f ff ff ff    	je     101883 <_vprintk+0x12b>
					out((int)(*s++), ctx);
  101954:	ff 75 0c             	pushl  0xc(%ebp)
  101957:	46                   	inc    %esi
  101958:	50                   	push   %eax
  101959:	ff d7                	call   *%edi
  10195b:	58                   	pop    %eax
  10195c:	5a                   	pop    %edx
  10195d:	eb ea                	jmp    101949 <_vprintk+0x1f1>
				out(c, ctx);
  10195f:	ff 75 0c             	pushl  0xc(%ebp)
  101962:	ff 36                	pushl  (%esi)
				int c = va_arg(ap, int);
  101964:	8d 5e 04             	lea    0x4(%esi),%ebx
				out(c, ctx);
  101967:	ff d7                	call   *%edi
  101969:	e9 13 ff ff ff       	jmp    101881 <_vprintk+0x129>
				out((int)'%', ctx);
  10196e:	ff 75 0c             	pushl  0xc(%ebp)
  101971:	6a 25                	push   $0x25
  101973:	eb 13                	jmp    101988 <_vprintk+0x230>
				out((int)'%', ctx);
  101975:	ff 75 0c             	pushl  0xc(%ebp)
  101978:	6a 25                	push   $0x25
  10197a:	ff d7                	call   *%edi
  10197c:	59                   	pop    %ecx
  10197d:	5b                   	pop    %ebx
				out((int)*fmt, ctx);
  10197e:	ff 75 0c             	pushl  0xc(%ebp)
  101981:	8b 45 10             	mov    0x10(%ebp),%eax
  101984:	0f be 00             	movsbl (%eax),%eax
  101987:	50                   	push   %eax
  101988:	ff d7                	call   *%edi
  10198a:	58                   	pop    %eax
  10198b:	5a                   	pop    %edx
			might_format = 0;
  10198c:	31 db                	xor    %ebx,%ebx
				break;
  10198e:	eb 18                	jmp    1019a8 <_vprintk+0x250>
				pad_zero = 0;
  101990:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				min_width = -1;
  101997:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
				might_format = 1;
  10199e:	bb 01 00 00 00       	mov    $0x1,%ebx
  1019a3:	eb 03                	jmp    1019a8 <_vprintk+0x250>
					pad_zero = 1;
  1019a5:	89 5d ec             	mov    %ebx,-0x14(%ebp)
		++fmt;
  1019a8:	ff 45 10             	incl   0x10(%ebp)
  1019ab:	e9 c7 fd ff ff       	jmp    101777 <_vprintk+0x1f>
}
  1019b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1019b3:	5b                   	pop    %ebx
  1019b4:	5e                   	pop    %esi
  1019b5:	5f                   	pop    %edi
  1019b6:	5d                   	pop    %ebp
  1019b7:	c3                   	ret    

001019b8 <printk>:
{
  1019b8:	55                   	push   %ebp
  1019b9:	89 e5                	mov    %esp,%ebp
  1019bb:	50                   	push   %eax
	va_start(ap, fmt);
  1019bc:	8d 45 0c             	lea    0xc(%ebp),%eax
	struct out_context ctx = { 0 };
  1019bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  1019c6:	50                   	push   %eax
  1019c7:	8d 45 fc             	lea    -0x4(%ebp),%eax
  1019ca:	ff 75 08             	pushl  0x8(%ebp)
  1019cd:	50                   	push   %eax
  1019ce:	68 7d 16 10 00       	push   $0x10167d
  1019d3:	e8 80 fd ff ff       	call   101758 <_vprintk>
}
  1019d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  1019db:	83 c4 10             	add    $0x10,%esp
}
  1019de:	c9                   	leave  
  1019df:	c3                   	ret    

001019e0 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
  1019e0:	55                   	push   %ebp
  1019e1:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_SHOW_TAGS, 1);
GEN_ABSOLUTE_SYM(CONFIG_NET_IF_MCAST_IPV4_ADDR_COUNT, 1);

GEN_ABS_SYM_END
  1019e3:	5d                   	pop    %ebp
  1019e4:	c3                   	ret    

001019e5 <net_buf_alloc>:
struct net_buf *net_buf_alloc_debug(struct net_buf_pool *pool, int32_t timeout,
				    const char *func, int line)
#else
struct net_buf *net_buf_alloc(struct net_buf_pool *pool, int32_t timeout)
#endif
{
  1019e5:	55                   	push   %ebp
  1019e6:	89 e5                	mov    %esp,%ebp
  1019e8:	56                   	push   %esi
  1019e9:	53                   	push   %ebx
  1019ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  1019ed:	9c                   	pushf  
  1019ee:	fa                   	cli    
  1019ef:	5e                   	pop    %esi
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
  1019f0:	66 8b 43 0e          	mov    0xe(%ebx),%ax
  1019f4:	66 85 c0             	test   %ax,%ax
  1019f7:	74 5e                	je     101a57 <net_buf_alloc+0x72>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
  1019f9:	66 3b 43 0c          	cmp    0xc(%ebx),%ax
  1019fd:	73 17                	jae    101a16 <net_buf_alloc+0x31>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
  1019ff:	6a 00                	push   $0x0
  101a01:	53                   	push   %ebx
  101a02:	e8 a5 55 00 00       	call   106fac <k_lifo_get>
  101a07:	5a                   	pop    %edx
			if (buf) {
  101a08:	85 c0                	test   %eax,%eax
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
  101a0a:	59                   	pop    %ecx
			if (buf) {
  101a0b:	74 09                	je     101a16 <net_buf_alloc+0x31>
  101a0d:	0f ba e6 09          	bt     $0x9,%esi
  101a11:	73 5a                	jae    101a6d <net_buf_alloc+0x88>
	__asm__ volatile (
  101a13:	fb                   	sti    
  101a14:	eb 57                	jmp    101a6d <net_buf_alloc+0x88>
				irq_unlock(key);
				goto success;
			}
		}

		uninit_count = pool->uninit_count--;
  101a16:	0f b7 4b 0e          	movzwl 0xe(%ebx),%ecx
  101a1a:	0f ba e6 09          	bt     $0x9,%esi
  101a1e:	8d 41 ff             	lea    -0x1(%ecx),%eax
  101a21:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  101a25:	73 01                	jae    101a28 <net_buf_alloc+0x43>
  101a27:	fb                   	sti    
	buf = UNINIT_BUF(pool, pool->buf_count - uninit_count);
  101a28:	0f b7 43 10          	movzwl 0x10(%ebx),%eax
  101a2c:	0f b7 73 12          	movzwl 0x12(%ebx),%esi
  101a30:	89 c2                	mov    %eax,%edx
  101a32:	83 c6 03             	add    $0x3,%esi
  101a35:	83 c0 03             	add    $0x3,%eax
  101a38:	83 e6 fc             	and    $0xfffffffc,%esi
  101a3b:	83 e0 fc             	and    $0xfffffffc,%eax
  101a3e:	8d 44 06 18          	lea    0x18(%esi,%eax,1),%eax
  101a42:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  101a46:	29 ce                	sub    %ecx,%esi
  101a48:	0f af c6             	imul   %esi,%eax
  101a4b:	03 43 18             	add    0x18(%ebx),%eax
	buf->pool = pool;
  101a4e:	89 58 0c             	mov    %ebx,0xc(%eax)
	buf->size = pool->buf_size;
  101a51:	66 89 50 16          	mov    %dx,0x16(%eax)
		irq_unlock(key);

		buf = pool_get_uninit(pool, uninit_count);
		goto success;
  101a55:	eb 16                	jmp    101a6d <net_buf_alloc+0x88>
  101a57:	0f ba e6 09          	bt     $0x9,%esi
  101a5b:	73 01                	jae    101a5e <net_buf_alloc+0x79>
  101a5d:	fb                   	sti    
		}
	} else {
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
  101a5e:	ff 75 0c             	pushl  0xc(%ebp)
  101a61:	53                   	push   %ebx
  101a62:	e8 45 55 00 00       	call   106fac <k_lifo_get>
  101a67:	5a                   	pop    %edx
#endif
	if (!buf) {
  101a68:	85 c0                	test   %eax,%eax
	buf = k_lifo_get(&pool->free, timeout);
  101a6a:	59                   	pop    %ecx
	if (!buf) {
  101a6b:	74 1a                	je     101a87 <net_buf_alloc+0xa2>
success:
	NET_BUF_DBG("allocated buf %p", buf);

	buf->ref   = 1;
	buf->len   = 0;
	buf->data  = buf->__buf;
  101a6d:	8d 50 18             	lea    0x18(%eax),%edx
	buf->ref   = 1;
  101a70:	c6 40 08 01          	movb   $0x1,0x8(%eax)
	buf->len   = 0;
  101a74:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
	buf->data  = buf->__buf;
  101a7a:	89 50 10             	mov    %edx,0x10(%eax)
	buf->flags = 0;
  101a7d:	c6 40 09 00          	movb   $0x0,0x9(%eax)
	buf->frags = NULL;
  101a81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	return buf;
}
  101a87:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101a8a:	5b                   	pop    %ebx
  101a8b:	5e                   	pop    %esi
  101a8c:	5d                   	pop    %ebp
  101a8d:	c3                   	ret    

00101a8e <net_buf_get>:
struct net_buf *net_buf_get_debug(struct k_fifo *fifo, int32_t timeout,
				  const char *func, int line)
#else
struct net_buf *net_buf_get(struct k_fifo *fifo, int32_t timeout)
#endif
{
  101a8e:	55                   	push   %ebp
  101a8f:	89 e5                	mov    %esp,%ebp
  101a91:	57                   	push   %edi
  101a92:	56                   	push   %esi
  101a93:	53                   	push   %ebx
	struct net_buf *buf, *frag;

	NET_BUF_DBG("%s():%d: fifo %p timeout %d", func, line, fifo, timeout);

	buf = k_fifo_get(fifo, timeout);
  101a94:	ff 75 0c             	pushl  0xc(%ebp)
{
  101a97:	8b 7d 08             	mov    0x8(%ebp),%edi
	buf = k_fifo_get(fifo, timeout);
  101a9a:	57                   	push   %edi
  101a9b:	e8 44 52 00 00       	call   106ce4 <k_fifo_get>
  101aa0:	5b                   	pop    %ebx
	if (!buf) {
  101aa1:	85 c0                	test   %eax,%eax
	buf = k_fifo_get(fifo, timeout);
  101aa3:	5e                   	pop    %esi
  101aa4:	89 c3                	mov    %eax,%ebx
  101aa6:	89 c6                	mov    %eax,%esi
	if (!buf) {
  101aa8:	74 20                	je     101aca <net_buf_get+0x3c>
	}

	NET_BUF_DBG("%s():%d: buf %p fifo %p", func, line, buf, fifo);

	/* Get any fragments belonging to this buffer */
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
  101aaa:	f6 43 09 01          	testb  $0x1,0x9(%ebx)
  101aae:	74 14                	je     101ac4 <net_buf_get+0x36>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
  101ab0:	6a 00                	push   $0x0
  101ab2:	57                   	push   %edi
  101ab3:	e8 2c 52 00 00       	call   106ce4 <k_fifo_get>
  101ab8:	5a                   	pop    %edx
  101ab9:	59                   	pop    %ecx
  101aba:	89 03                	mov    %eax,(%ebx)
		NET_BUF_ASSERT(frag->frags);

		/* The fragments flag is only for FIFO-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
  101abc:	80 63 09 fe          	andb   $0xfe,0x9(%ebx)
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
  101ac0:	89 c3                	mov    %eax,%ebx
  101ac2:	eb e6                	jmp    101aaa <net_buf_get+0x1c>
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
  101ac4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	return buf;
}
  101aca:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101acd:	89 f0                	mov    %esi,%eax
  101acf:	5b                   	pop    %ebx
  101ad0:	5e                   	pop    %esi
  101ad1:	5f                   	pop    %edi
  101ad2:	5d                   	pop    %ebp
  101ad3:	c3                   	ret    

00101ad4 <net_buf_reserve>:

void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
  101ad4:	55                   	push   %ebp
  101ad5:	89 e5                	mov    %esp,%ebp
  101ad7:	8b 55 08             	mov    0x8(%ebp),%edx
	NET_BUF_ASSERT(buf);
	NET_BUF_ASSERT(buf->len == 0);
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
  101ada:	8d 42 18             	lea    0x18(%edx),%eax
  101add:	03 45 0c             	add    0xc(%ebp),%eax
  101ae0:	89 42 10             	mov    %eax,0x10(%edx)
}
  101ae3:	5d                   	pop    %ebp
  101ae4:	c3                   	ret    

00101ae5 <net_buf_put>:

void net_buf_put(struct k_fifo *fifo, struct net_buf *buf)
{
  101ae5:	55                   	push   %ebp
  101ae6:	89 e5                	mov    %esp,%ebp
  101ae8:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct net_buf *tail;

	NET_BUF_ASSERT(fifo);
	NET_BUF_ASSERT(buf);

	for (tail = buf; tail->frags; tail = tail->frags) {
  101aeb:	89 d0                	mov    %edx,%eax
  101aed:	8b 08                	mov    (%eax),%ecx
  101aef:	85 c9                	test   %ecx,%ecx
  101af1:	74 08                	je     101afb <net_buf_put+0x16>
		tail->flags |= NET_BUF_FRAGS;
  101af3:	80 48 09 01          	orb    $0x1,0x9(%eax)
  101af7:	89 c8                	mov    %ecx,%eax
  101af9:	eb f2                	jmp    101aed <net_buf_put+0x8>
	}

	k_fifo_put_list(fifo, buf, tail);
  101afb:	50                   	push   %eax
  101afc:	52                   	push   %edx
  101afd:	ff 75 08             	pushl  0x8(%ebp)
  101b00:	e8 25 51 00 00       	call   106c2a <k_fifo_put_list>
  101b05:	83 c4 0c             	add    $0xc,%esp
}
  101b08:	c9                   	leave  
  101b09:	c3                   	ret    

00101b0a <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  101b0a:	55                   	push   %ebp
  101b0b:	89 e5                	mov    %esp,%ebp
  101b0d:	53                   	push   %ebx
  101b0e:	8b 45 08             	mov    0x8(%ebp),%eax
	NET_BUF_ASSERT(buf);

	while (buf) {
  101b11:	85 c0                	test   %eax,%eax
  101b13:	74 32                	je     101b47 <net_buf_unref+0x3d>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool %p frags %p", buf, buf->ref,
			    buf->pool, buf->frags);

		if (--buf->ref > 0) {
  101b15:	8a 48 08             	mov    0x8(%eax),%cl
		struct net_buf *frags = buf->frags;
  101b18:	8b 18                	mov    (%eax),%ebx
		if (--buf->ref > 0) {
  101b1a:	8d 51 ff             	lea    -0x1(%ecx),%edx
  101b1d:	88 50 08             	mov    %dl,0x8(%eax)
  101b20:	84 d2                	test   %dl,%dl
  101b22:	75 23                	jne    101b47 <net_buf_unref+0x3d>
			return;
		}

		buf->frags = NULL;

		if (buf->pool->destroy) {
  101b24:	8b 50 0c             	mov    0xc(%eax),%edx
		buf->frags = NULL;
  101b27:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (buf->pool->destroy) {
  101b2d:	8b 4a 14             	mov    0x14(%edx),%ecx
  101b30:	85 c9                	test   %ecx,%ecx
  101b32:	74 06                	je     101b3a <net_buf_unref+0x30>
			buf->pool->destroy(buf);
  101b34:	50                   	push   %eax
  101b35:	ff d1                	call   *%ecx
  101b37:	59                   	pop    %ecx
  101b38:	eb 09                	jmp    101b43 <net_buf_unref+0x39>
	k_lifo_put(&buf->pool->free, buf);
  101b3a:	50                   	push   %eax
  101b3b:	52                   	push   %edx
  101b3c:	e8 6e 53 00 00       	call   106eaf <k_lifo_put>
  101b41:	58                   	pop    %eax
  101b42:	5a                   	pop    %edx
{
  101b43:	89 d8                	mov    %ebx,%eax
  101b45:	eb ca                	jmp    101b11 <net_buf_unref+0x7>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  101b47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101b4a:	c9                   	leave  
  101b4b:	c3                   	ret    

00101b4c <net_buf_ref>:

struct net_buf *net_buf_ref(struct net_buf *buf)
{
  101b4c:	55                   	push   %ebp
  101b4d:	89 e5                	mov    %esp,%ebp
  101b4f:	8b 45 08             	mov    0x8(%ebp),%eax
	NET_BUF_ASSERT(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool %p",
		    buf, buf->ref, buf->pool);
	buf->ref++;
  101b52:	fe 40 08             	incb   0x8(%eax)
	return buf;
}
  101b55:	5d                   	pop    %ebp
  101b56:	c3                   	ret    

00101b57 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
  101b57:	55                   	push   %ebp
  101b58:	89 e5                	mov    %esp,%ebp
	NET_BUF_ASSERT(buf);

	while (buf->frags) {
  101b5a:	8b 45 08             	mov    0x8(%ebp),%eax
  101b5d:	8b 10                	mov    (%eax),%edx
  101b5f:	85 d2                	test   %edx,%edx
  101b61:	74 04                	je     101b67 <net_buf_frag_last+0x10>
  101b63:	89 d0                	mov    %edx,%eax
  101b65:	eb f6                	jmp    101b5d <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
  101b67:	5d                   	pop    %ebp
  101b68:	c3                   	ret    

00101b69 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
  101b69:	55                   	push   %ebp
  101b6a:	89 e5                	mov    %esp,%ebp
  101b6c:	56                   	push   %esi
  101b6d:	53                   	push   %ebx
  101b6e:	8b 55 08             	mov    0x8(%ebp),%edx
  101b71:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101b74:	89 c8                	mov    %ecx,%eax
	NET_BUF_ASSERT(parent);
	NET_BUF_ASSERT(frag);

	if (parent->frags) {
  101b76:	8b 1a                	mov    (%edx),%ebx
  101b78:	85 db                	test   %ebx,%ebx
  101b7a:	74 0c                	je     101b88 <net_buf_frag_insert+0x1f>
	while (buf->frags) {
  101b7c:	8b 30                	mov    (%eax),%esi
  101b7e:	85 f6                	test   %esi,%esi
  101b80:	74 04                	je     101b86 <net_buf_frag_insert+0x1d>
  101b82:	89 f0                	mov    %esi,%eax
  101b84:	eb f6                	jmp    101b7c <net_buf_frag_insert+0x13>
		net_buf_frag_last(frag)->frags = parent->frags;
  101b86:	89 18                	mov    %ebx,(%eax)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
  101b88:	89 0a                	mov    %ecx,(%edx)
}
  101b8a:	5b                   	pop    %ebx
  101b8b:	5e                   	pop    %esi
  101b8c:	5d                   	pop    %ebp
  101b8d:	c3                   	ret    

00101b8e <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
  101b8e:	55                   	push   %ebp
  101b8f:	89 e5                	mov    %esp,%ebp
  101b91:	53                   	push   %ebx
  101b92:	8b 5d 08             	mov    0x8(%ebp),%ebx
  101b95:	8b 45 0c             	mov    0xc(%ebp),%eax
  101b98:	89 da                	mov    %ebx,%edx
	NET_BUF_ASSERT(frag);

	if (!head) {
  101b9a:	85 db                	test   %ebx,%ebx
  101b9c:	75 05                	jne    101ba3 <net_buf_frag_add+0x15>
	buf->ref++;
  101b9e:	fe 40 08             	incb   0x8(%eax)
		return net_buf_ref(frag);
  101ba1:	eb 15                	jmp    101bb8 <net_buf_frag_add+0x2a>
	while (buf->frags) {
  101ba3:	8b 0a                	mov    (%edx),%ecx
  101ba5:	85 c9                	test   %ecx,%ecx
  101ba7:	74 04                	je     101bad <net_buf_frag_add+0x1f>
  101ba9:	89 ca                	mov    %ecx,%edx
  101bab:	eb f6                	jmp    101ba3 <net_buf_frag_add+0x15>
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);
  101bad:	50                   	push   %eax
  101bae:	52                   	push   %edx
  101baf:	e8 b5 ff ff ff       	call   101b69 <net_buf_frag_insert>
  101bb4:	58                   	pop    %eax

	return head;
  101bb5:	89 d8                	mov    %ebx,%eax
	net_buf_frag_insert(net_buf_frag_last(head), frag);
  101bb7:	5a                   	pop    %edx
}
  101bb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101bbb:	c9                   	leave  
  101bbc:	c3                   	ret    

00101bbd <net_buf_frag_del>:
				       struct net_buf *frag,
				       const char *func, int line)
#else
struct net_buf *net_buf_frag_del(struct net_buf *parent, struct net_buf *frag)
#endif
{
  101bbd:	55                   	push   %ebp
  101bbe:	89 e5                	mov    %esp,%ebp
  101bc0:	53                   	push   %ebx
  101bc1:	8b 45 08             	mov    0x8(%ebp),%eax
  101bc4:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct net_buf *next_frag;

	NET_BUF_ASSERT(frag);

	if (parent) {
  101bc7:	85 c0                	test   %eax,%eax
  101bc9:	74 04                	je     101bcf <net_buf_frag_del+0x12>
		NET_BUF_ASSERT(parent->frags);
		NET_BUF_ASSERT(parent->frags == frag);
		parent->frags = frag->frags;
  101bcb:	8b 0a                	mov    (%edx),%ecx
  101bcd:	89 08                	mov    %ecx,(%eax)
	}

	next_frag = frag->frags;
  101bcf:	8b 1a                	mov    (%edx),%ebx

	frag->frags = NULL;
  101bd1:	c7 02 00 00 00 00    	movl   $0x0,(%edx)

#if defined(CONFIG_NET_BUF_LOG)
	net_buf_unref_debug(frag, func, line);
#else
	net_buf_unref(frag);
  101bd7:	52                   	push   %edx
  101bd8:	e8 2d ff ff ff       	call   101b0a <net_buf_unref>
  101bdd:	58                   	pop    %eax
#endif

	return next_frag;
}
  101bde:	89 d8                	mov    %ebx,%eax
  101be0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101be3:	c9                   	leave  
  101be4:	c3                   	ret    

00101be5 <net_buf_simple_add>:
#define NET_BUF_SIMPLE_INFO(fmt, ...)
#define NET_BUF_SIMPLE_ASSERT(cond)
#endif /* CONFIG_NET_BUF_SIMPLE_LOG */

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
  101be5:	55                   	push   %ebp
  101be6:	89 e5                	mov    %esp,%ebp
  101be8:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return buf->data + buf->len;
  101beb:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
  101bef:	89 c2                	mov    %eax,%edx
  101bf1:	03 01                	add    (%ecx),%eax

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
  101bf3:	03 55 0c             	add    0xc(%ebp),%edx
  101bf6:	66 89 51 04          	mov    %dx,0x4(%ecx)
	return tail;
}
  101bfa:	5d                   	pop    %ebp
  101bfb:	c3                   	ret    

00101bfc <net_buf_simple_add_u8>:

	return memcpy(net_buf_simple_add(buf, len), mem, len);
}

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
  101bfc:	55                   	push   %ebp
  101bfd:	89 e5                	mov    %esp,%ebp
  101bff:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101c02:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
  101c06:	89 c2                	mov    %eax,%edx
  101c08:	03 01                	add    (%ecx),%eax
	buf->len += len;
  101c0a:	42                   	inc    %edx
  101c0b:	66 89 51 04          	mov    %dx,0x4(%ecx)
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
  101c0f:	8b 55 0c             	mov    0xc(%ebp),%edx
  101c12:	88 10                	mov    %dl,(%eax)

	return u8;
}
  101c14:	5d                   	pop    %ebp
  101c15:	c3                   	ret    

00101c16 <net_buf_simple_pull>:

	*data = val;
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
  101c16:	55                   	push   %ebp
  101c17:	89 e5                	mov    %esp,%ebp
  101c19:	8b 55 08             	mov    0x8(%ebp),%edx
  101c1c:	8b 45 0c             	mov    0xc(%ebp),%eax
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(buf->len >= len);

	buf->len -= len;
  101c1f:	66 29 42 04          	sub    %ax,0x4(%edx)
	return buf->data += len;
  101c23:	03 02                	add    (%edx),%eax
  101c25:	89 02                	mov    %eax,(%edx)
}
  101c27:	5d                   	pop    %ebp
  101c28:	c3                   	ret    

00101c29 <net_buf_simple_headroom>:

	return sys_be32_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
  101c29:	55                   	push   %ebp
  101c2a:	89 e5                	mov    %esp,%ebp
  101c2c:	8b 45 08             	mov    0x8(%ebp),%eax
	return buf->data - buf->__buf;
}
  101c2f:	5d                   	pop    %ebp
	return buf->data - buf->__buf;
  101c30:	8d 50 08             	lea    0x8(%eax),%edx
  101c33:	8b 00                	mov    (%eax),%eax
  101c35:	29 d0                	sub    %edx,%eax
}
  101c37:	c3                   	ret    

00101c38 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
  101c38:	55                   	push   %ebp
  101c39:	89 e5                	mov    %esp,%ebp
  101c3b:	8b 55 08             	mov    0x8(%ebp),%edx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}
  101c3e:	5d                   	pop    %ebp
	return buf->data - buf->__buf;
  101c3f:	89 d1                	mov    %edx,%ecx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  101c41:	0f b7 42 06          	movzwl 0x6(%edx),%eax
	return buf->data - buf->__buf;
  101c45:	2b 0a                	sub    (%edx),%ecx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  101c47:	0f b7 52 04          	movzwl 0x4(%edx),%edx
  101c4b:	8d 44 01 08          	lea    0x8(%ecx,%eax,1),%eax
  101c4f:	29 d0                	sub    %edx,%eax
}
  101c51:	c3                   	ret    

00101c52 <net_buf_user_data>:
{
  101c52:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c53:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101c57:	89 e5                	mov    %esp,%ebp
}
  101c59:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c5a:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101c5e:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101c61:	c3                   	ret    

00101c62 <net_buf_user_data>:
{
  101c62:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c63:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101c67:	89 e5                	mov    %esp,%ebp
}
  101c69:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c6a:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101c6e:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101c71:	c3                   	ret    

00101c72 <net_buf_user_data>:
{
  101c72:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c73:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101c77:	89 e5                	mov    %esp,%ebp
}
  101c79:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c7a:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101c7e:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101c81:	c3                   	ret    

00101c82 <net_buf_user_data>:
{
  101c82:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c83:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101c87:	89 e5                	mov    %esp,%ebp
}
  101c89:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c8a:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101c8e:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101c91:	c3                   	ret    

00101c92 <net_buf_user_data>:
{
  101c92:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c93:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101c97:	89 e5                	mov    %esp,%ebp
}
  101c99:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101c9a:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101c9e:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101ca1:	c3                   	ret    

00101ca2 <net_buf_user_data>:
{
  101ca2:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101ca3:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101ca7:	89 e5                	mov    %esp,%ebp
}
  101ca9:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101caa:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101cae:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101cb1:	c3                   	ret    

00101cb2 <net_buf_user_data>:
{
  101cb2:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101cb3:	0f b7 50 16          	movzwl 0x16(%eax),%edx
{
  101cb7:	89 e5                	mov    %esp,%ebp
}
  101cb9:	5d                   	pop    %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  101cba:	8d 44 10 1b          	lea    0x1b(%eax,%edx,1),%eax
  101cbe:	83 e0 fc             	and    $0xfffffffc,%eax
}
  101cc1:	c3                   	ret    

00101cc2 <net_init>:

	NET_DBG("Network L2 init done");
}

static int net_init(struct device *unused)
{
  101cc2:	55                   	push   %ebp
  101cc3:	89 e5                	mov    %esp,%ebp
	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_shell_init();

	net_nbuf_init();
  101cc5:	e8 4a 1a 00 00       	call   103714 <net_nbuf_init>

	net_context_init();
  101cca:	e8 af 14 00 00       	call   10317e <net_context_init>
	net_arp_init();
  101ccf:	e8 be 27 00 00       	call   104492 <net_arp_init>
	net_conn_init();
  101cd4:	e8 61 39 00 00       	call   10563a <net_conn_init>
	net_tcp_init();
  101cd9:	e8 3f 32 00 00       	call   104f1d <net_tcp_init>
	k_fifo_init(&rx_queue);
  101cde:	68 64 94 10 00       	push   $0x109464
  101ce3:	e8 27 4f 00 00       	call   106c0f <k_fifo_init>
	rx_tid = k_thread_spawn(rx_stack, sizeof(rx_stack),
  101ce8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  101cef:	6a 00                	push   $0x0
  101cf1:	6a f8                	push   $0xfffffff8
  101cf3:	6a 00                	push   $0x0
  101cf5:	6a 00                	push   $0x0
  101cf7:	6a 00                	push   $0x0
  101cf9:	68 25 1e 10 00       	push   $0x101e25
  101cfe:	68 b0 04 00 00       	push   $0x4b0
  101d03:	68 c0 9b 10 00       	push   $0x109bc0
  101d08:	e8 0e 5b 00 00       	call   10781b <k_thread_spawn>
  101d0d:	83 c4 24             	add    $0x24,%esp
	net_mgmt_event_init();

	init_rx_queue();

	return 0;
}
  101d10:	31 c0                	xor    %eax,%eax
  101d12:	c9                   	leave  
  101d13:	c3                   	ret    

00101d14 <processing_data>:
{
  101d14:	55                   	push   %ebp
  101d15:	89 e5                	mov    %esp,%ebp
  101d17:	56                   	push   %esi
  101d18:	53                   	push   %ebx
  101d19:	89 c3                	mov    %eax,%ebx
	if (!buf->frags || !buf->pool->user_data_size) {
  101d1b:	83 38 00             	cmpl   $0x0,(%eax)
  101d1e:	0f 84 f3 00 00 00    	je     101e17 <processing_data+0x103>
  101d24:	8b 40 0c             	mov    0xc(%eax),%eax
  101d27:	66 83 78 12 00       	cmpw   $0x0,0x12(%eax)
  101d2c:	0f 84 e5 00 00 00    	je     101e17 <processing_data+0x103>
	if (!is_loopback) {
  101d32:	84 d2                	test   %dl,%dl
  101d34:	74 28                	je     101d5e <processing_data+0x4a>
  101d36:	8b 03                	mov    (%ebx),%eax
	switch (NET_IPV6_BUF(buf)->vtc & 0xf0) {
  101d38:	8b 40 10             	mov    0x10(%eax),%eax
  101d3b:	8a 00                	mov    (%eax),%al
  101d3d:	83 e0 f0             	and    $0xfffffff0,%eax
  101d40:	3c 40                	cmp    $0x40,%al
  101d42:	0f 85 cf 00 00 00    	jne    101e17 <processing_data+0x103>
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  101d48:	89 d8                	mov    %ebx,%eax
  101d4a:	e8 03 ff ff ff       	call   101c52 <net_buf_user_data>
 *
 *  @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
  101d4f:	31 d2                	xor    %edx,%edx
  101d51:	c6 40 29 02          	movb   $0x2,0x29(%eax)
	return buf->frags->data;
  101d55:	8b 03                	mov    (%ebx),%eax
  101d57:	8b 70 10             	mov    0x10(%eax),%esi
  101d5a:	89 d8                	mov    %ebx,%eax
  101d5c:	eb 1e                	jmp    101d7c <processing_data+0x68>
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  101d5e:	89 d8                	mov    %ebx,%eax
  101d60:	e8 ed fe ff ff       	call   101c52 <net_buf_user_data>
  101d65:	8b 40 08             	mov    0x8(%eax),%eax
	return iface->l2->recv(iface, buf);
  101d68:	8b 50 08             	mov    0x8(%eax),%edx
  101d6b:	53                   	push   %ebx
  101d6c:	50                   	push   %eax
  101d6d:	ff 12                	call   *(%edx)
  101d6f:	5e                   	pop    %esi
		if (ret != NET_CONTINUE) {
  101d70:	83 f8 01             	cmp    $0x1,%eax
  101d73:	5a                   	pop    %edx
  101d74:	0f 85 99 00 00 00    	jne    101e13 <processing_data+0xff>
  101d7a:	eb ba                	jmp    101d36 <processing_data+0x22>

	while (buf) {
		bytes += buf->len;
  101d7c:	0f b7 48 14          	movzwl 0x14(%eax),%ecx
		buf = buf->frags;
  101d80:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  101d82:	01 ca                	add    %ecx,%edx
	while (buf) {
  101d84:	85 c0                	test   %eax,%eax
  101d86:	75 f4                	jne    101d7c <processing_data+0x68>
	int pkt_len = (hdr->len[0] << 8) + hdr->len[1];
  101d88:	0f b6 46 02          	movzbl 0x2(%esi),%eax
  101d8c:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
  101d90:	c1 e0 08             	shl    $0x8,%eax
  101d93:	01 c8                	add    %ecx,%eax
	if (real_len != pkt_len) {
  101d95:	39 c2                	cmp    %eax,%edx
  101d97:	75 7e                	jne    101e17 <processing_data+0x103>
	((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len = len;
  101d99:	89 d8                	mov    %ebx,%eax
  101d9b:	e8 b2 fe ff ff       	call   101c52 <net_buf_user_data>
  101da0:	c6 40 2a 14          	movb   $0x14,0x2a(%eax)
	if (!net_is_my_ipv4_addr(&hdr->dst)) {
  101da4:	8d 46 10             	lea    0x10(%esi),%eax
 * @return True if IPv4 address is found in one of the network interfaces,
 * False otherwise.
 */
static inline bool net_is_my_ipv4_addr(const struct in_addr *addr)
{
	return net_if_ipv4_addr_lookup(addr, NULL) != NULL;
  101da7:	6a 00                	push   $0x0
  101da9:	50                   	push   %eax
  101daa:	e8 24 02 00 00       	call   101fd3 <net_if_ipv4_addr_lookup>
  101daf:	5a                   	pop    %edx
  101db0:	85 c0                	test   %eax,%eax
  101db2:	59                   	pop    %ecx
  101db3:	74 62                	je     101e17 <processing_data+0x103>
	switch (hdr->proto) {
  101db5:	8a 46 09             	mov    0x9(%esi),%al
  101db8:	3c 06                	cmp    $0x6,%al
  101dba:	74 48                	je     101e04 <processing_data+0xf0>
  101dbc:	3c 11                	cmp    $0x11,%al
  101dbe:	74 3f                	je     101dff <processing_data+0xeb>
  101dc0:	fe c8                	dec    %al
  101dc2:	75 53                	jne    101e17 <processing_data+0x103>
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  101dc4:	89 d8                	mov    %ebx,%eax
  101dc6:	e8 87 fe ff ff       	call   101c52 <net_buf_user_data>
				 net_nbuf_ext_len(buf)];
}

static inline uint8_t *net_nbuf_icmp_data(struct net_buf *buf)
{
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  101dcb:	8b 0b                	mov    (%ebx),%ecx
  101dcd:	0f b6 50 2a          	movzbl 0x2a(%eax),%edx
				 net_nbuf_ext_len(buf)];
  101dd1:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  101dd5:	01 d0                	add    %edx,%eax
  101dd7:	03 41 10             	add    0x10(%ecx),%eax
	return net_icmpv4_input(buf, len, hdr->type, hdr->code);
  101dda:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  101dde:	52                   	push   %edx
  101ddf:	0f b6 00             	movzbl (%eax),%eax
  101de2:	50                   	push   %eax
	uint16_t len = (ipv4->len[0] << 8) + ipv4->len[1];
  101de3:	0f b6 46 02          	movzbl 0x2(%esi),%eax
  101de7:	0f b6 56 03          	movzbl 0x3(%esi),%edx
  101deb:	c1 e0 08             	shl    $0x8,%eax
  101dee:	01 d0                	add    %edx,%eax
	return net_icmpv4_input(buf, len, hdr->type, hdr->code);
  101df0:	0f b7 c0             	movzwl %ax,%eax
  101df3:	50                   	push   %eax
  101df4:	53                   	push   %ebx
  101df5:	e8 8a 27 00 00       	call   104584 <net_icmpv4_input>
  101dfa:	83 c4 10             	add    $0x10,%esp
  101dfd:	eb 0f                	jmp    101e0e <processing_data+0xfa>
		verdict = net_conn_input(IPPROTO_UDP, buf);
  101dff:	53                   	push   %ebx
  101e00:	6a 11                	push   $0x11
  101e02:	eb 03                	jmp    101e07 <processing_data+0xf3>
		verdict = net_conn_input(IPPROTO_TCP, buf);
  101e04:	53                   	push   %ebx
  101e05:	6a 06                	push   $0x6
  101e07:	e8 ec 36 00 00       	call   1054f8 <net_conn_input>
  101e0c:	5a                   	pop    %edx
  101e0d:	59                   	pop    %ecx
	if (verdict != NET_DROP) {
  101e0e:	83 f8 02             	cmp    $0x2,%eax
  101e11:	74 04                	je     101e17 <processing_data+0x103>
	switch (process_data(buf, is_loopback)) {
  101e13:	85 c0                	test   %eax,%eax
  101e15:	74 07                	je     101e1e <processing_data+0x10a>
		net_nbuf_unref(buf);
  101e17:	53                   	push   %ebx
  101e18:	e8 3f 15 00 00       	call   10335c <net_nbuf_unref>
  101e1d:	58                   	pop    %eax
}
  101e1e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101e21:	5b                   	pop    %ebx
  101e22:	5e                   	pop    %esi
  101e23:	5d                   	pop    %ebp
  101e24:	c3                   	ret    

00101e25 <net_rx_thread>:
{
  101e25:	55                   	push   %ebp
  101e26:	89 e5                	mov    %esp,%ebp
	net_if_init();
  101e28:	e8 71 04 00 00       	call   10229e <net_if_init>
		buf = net_buf_get(&rx_queue, K_FOREVER);
  101e2d:	6a ff                	push   $0xffffffff
  101e2f:	68 64 94 10 00       	push   $0x109464
  101e34:	e8 55 fc ff ff       	call   101a8e <net_buf_get>
  101e39:	5a                   	pop    %edx
		} else {
			break;
		}
	}
#else
	for (i = *stack_offset; i < size; i++) {
  101e3a:	ba 38 00 00 00       	mov    $0x38,%edx
  101e3f:	59                   	pop    %ecx
		if ((unsigned char)stack[i] == 0xaa) {
  101e40:	80 ba c0 9b 10 00 aa 	cmpb   $0xaa,0x109bc0(%edx)
  101e47:	75 09                	jne    101e52 <net_rx_thread+0x2d>
	for (i = *stack_offset; i < size; i++) {
  101e49:	42                   	inc    %edx
  101e4a:	81 fa b0 04 00 00    	cmp    $0x4b0,%edx
  101e50:	75 ee                	jne    101e40 <net_rx_thread+0x1b>
		processing_data(buf, false);
  101e52:	31 d2                	xor    %edx,%edx
  101e54:	e8 bb fe ff ff       	call   101d14 <processing_data>
		k_yield();
  101e59:	e8 4e 54 00 00       	call   1072ac <k_yield>
		buf = net_buf_get(&rx_queue, K_FOREVER);
  101e5e:	eb cd                	jmp    101e2d <net_rx_thread+0x8>

00101e60 <net_send_data>:
{
  101e60:	55                   	push   %ebp
		return -ENODATA;
  101e61:	ba b2 ff ff ff       	mov    $0xffffffb2,%edx
{
  101e66:	89 e5                	mov    %esp,%ebp
  101e68:	56                   	push   %esi
  101e69:	53                   	push   %ebx
  101e6a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!buf || !buf->frags) {
  101e6d:	85 db                	test   %ebx,%ebx
  101e6f:	0f 84 80 00 00 00    	je     101ef5 <net_send_data+0x95>
  101e75:	83 3b 00             	cmpl   $0x0,(%ebx)
  101e78:	74 7b                	je     101ef5 <net_send_data+0x95>
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  101e7a:	89 d8                	mov    %ebx,%eax
  101e7c:	e8 d1 fd ff ff       	call   101c52 <net_buf_user_data>
		return -EINVAL;
  101e81:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	if (!net_nbuf_iface(buf)) {
  101e86:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  101e8a:	74 69                	je     101ef5 <net_send_data+0x95>
	if (net_nbuf_family(buf) == AF_INET) {
  101e8c:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  101e90:	75 45                	jne    101ed7 <net_send_data+0x77>
		if (net_ipv4_addr_cmp(&NET_IPV4_BUF(buf)->dst,
  101e92:	e8 55 2b 00 00       	call   1049ec <net_ipv4_unspecified_address>
	return buf->frags->data;
  101e97:	8b 13                	mov    (%ebx),%edx
  101e99:	8b 4a 10             	mov    0x10(%edx),%ecx
  101e9c:	ba cf ff ff ff       	mov    $0xffffffcf,%edx
  101ea1:	8b 71 10             	mov    0x10(%ecx),%esi
  101ea4:	3b 30                	cmp    (%eax),%esi
  101ea6:	74 4d                	je     101ef5 <net_send_data+0x95>
		if (net_is_ipv4_addr_loopback(&NET_IPV4_BUF(buf)->dst)) {
  101ea8:	80 79 10 7f          	cmpb   $0x7f,0x10(%ecx)
  101eac:	75 1e                	jne    101ecc <net_send_data+0x6c>
			net_ipaddr_copy(&addr, &NET_IPV4_BUF(buf)->src);
  101eae:	8b 51 0c             	mov    0xc(%ecx),%edx
			net_ipaddr_copy(&NET_IPV4_BUF(buf)->src,
  101eb1:	89 71 0c             	mov    %esi,0xc(%ecx)
  101eb4:	8b 03                	mov    (%ebx),%eax
  101eb6:	8b 40 10             	mov    0x10(%eax),%eax
			net_ipaddr_copy(&NET_IPV4_BUF(buf)->dst, &addr);
  101eb9:	89 50 10             	mov    %edx,0x10(%eax)
		processing_data(buf, true);
  101ebc:	ba 01 00 00 00       	mov    $0x1,%edx
  101ec1:	89 d8                	mov    %ebx,%eax
  101ec3:	e8 4c fe ff ff       	call   101d14 <processing_data>
		return 0;
  101ec8:	31 d2                	xor    %edx,%edx
  101eca:	eb 29                	jmp    101ef5 <net_send_data+0x95>
		if (net_is_ipv4_addr_loopback(&NET_IPV4_BUF(buf)->src)) {
  101ecc:	ba cf ff ff ff       	mov    $0xffffffcf,%edx
  101ed1:	80 79 0c 7f          	cmpb   $0x7f,0xc(%ecx)
  101ed5:	74 1e                	je     101ef5 <net_send_data+0x95>
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  101ed7:	89 d8                	mov    %ebx,%eax
  101ed9:	e8 74 fd ff ff       	call   101c52 <net_buf_user_data>
	if (net_if_send_data(net_nbuf_iface(buf), buf) == NET_DROP) {
  101ede:	53                   	push   %ebx
  101edf:	ff 70 08             	pushl  0x8(%eax)
  101ee2:	e8 cf 01 00 00       	call   1020b6 <net_if_send_data>
  101ee7:	5a                   	pop    %edx
	return 0;
  101ee8:	31 d2                	xor    %edx,%edx
  101eea:	83 f8 02             	cmp    $0x2,%eax
  101eed:	0f 95 c2             	setne  %dl
	if (net_if_send_data(net_nbuf_iface(buf), buf) == NET_DROP) {
  101ef0:	59                   	pop    %ecx
	return 0;
  101ef1:	8d 54 92 fb          	lea    -0x5(%edx,%edx,4),%edx
}
  101ef5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101ef8:	89 d0                	mov    %edx,%eax
  101efa:	5b                   	pop    %ebx
  101efb:	5e                   	pop    %esi
  101efc:	5d                   	pop    %ebp
  101efd:	c3                   	ret    

00101efe <net_recv_data>:
{
  101efe:	55                   	push   %ebp
  101eff:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
  101f04:	89 e5                	mov    %esp,%ebp
  101f06:	53                   	push   %ebx
  101f07:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  101f0a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!buf->frags) {
  101f0d:	83 39 00             	cmpl   $0x0,(%ecx)
  101f10:	74 30                	je     101f42 <net_recv_data+0x44>
	((struct net_nbuf *)net_buf_user_data(buf))->iface = iface;
  101f12:	89 c8                	mov    %ecx,%eax
  101f14:	e8 39 fd ff ff       	call   101c52 <net_buf_user_data>
  101f19:	89 58 08             	mov    %ebx,0x8(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  101f1c:	89 c8                	mov    %ecx,%eax
  101f1e:	e8 2f fd ff ff       	call   101c52 <net_buf_user_data>
		iface->link_addr.type;
  101f23:	8a 5b 15             	mov    0x15(%ebx),%bl
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  101f26:	88 58 19             	mov    %bl,0x19(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst.type =
  101f29:	89 c8                	mov    %ecx,%eax
  101f2b:	e8 22 fd ff ff       	call   101c52 <net_buf_user_data>
  101f30:	88 58 21             	mov    %bl,0x21(%eax)
	net_buf_put(&rx_queue, buf);
  101f33:	51                   	push   %ecx
  101f34:	68 64 94 10 00       	push   $0x109464
  101f39:	e8 a7 fb ff ff       	call   101ae5 <net_buf_put>
  101f3e:	58                   	pop    %eax
	return 0;
  101f3f:	31 c0                	xor    %eax,%eax
	net_buf_put(&rx_queue, buf);
  101f41:	5a                   	pop    %edx
}
  101f42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101f45:	c9                   	leave  
  101f46:	c3                   	ret    

00101f47 <net_if_get_by_link_addr>:

	return verdict;
}

struct net_if *net_if_get_by_link_addr(struct net_linkaddr *ll_addr)
{
  101f47:	55                   	push   %ebp
  101f48:	89 e5                	mov    %esp,%ebp
  101f4a:	56                   	push   %esi
  101f4b:	53                   	push   %ebx
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  101f4c:	bb 20 8e 10 00       	mov    $0x108e20,%ebx
{
  101f51:	8b 75 08             	mov    0x8(%ebp),%esi
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  101f54:	81 fb 60 93 10 00    	cmp    $0x109360,%ebx
  101f5a:	74 1e                	je     101f7a <net_if_get_by_link_addr+0x33>
		if (!memcmp(iface->link_addr.addr, ll_addr->addr,
  101f5c:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  101f60:	50                   	push   %eax
  101f61:	ff 36                	pushl  (%esi)
  101f63:	ff 73 10             	pushl  0x10(%ebx)
  101f66:	e8 9d f4 ff ff       	call   101408 <memcmp>
  101f6b:	83 c4 0c             	add    $0xc,%esp
  101f6e:	85 c0                	test   %eax,%eax
  101f70:	74 0a                	je     101f7c <net_if_get_by_link_addr+0x35>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  101f72:	81 c3 40 05 00 00    	add    $0x540,%ebx
  101f78:	eb da                	jmp    101f54 <net_if_get_by_link_addr+0xd>
			    ll_addr->len)) {
			return iface;
		}
	}

	return NULL;
  101f7a:	31 db                	xor    %ebx,%ebx
}
  101f7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101f7f:	89 d8                	mov    %ebx,%eax
  101f81:	5b                   	pop    %ebx
  101f82:	5e                   	pop    %esi
  101f83:	5d                   	pop    %ebp
  101f84:	c3                   	ret    

00101f85 <net_if_get_default>:

	return NULL;
}

struct net_if *net_if_get_default(void)
{
  101f85:	55                   	push   %ebp
	return __net_if_start;
}
  101f86:	b8 20 8e 10 00       	mov    $0x108e20,%eax
{
  101f8b:	89 e5                	mov    %esp,%ebp
}
  101f8d:	5d                   	pop    %ebp
  101f8e:	c3                   	ret    

00101f8f <net_if_ipv4_addr_mask_cmp>:
	return NULL;
}

bool net_if_ipv4_addr_mask_cmp(struct net_if *iface,
			       struct in_addr *addr)
{
  101f8f:	55                   	push   %ebp
  101f90:	89 e5                	mov    %esp,%ebp
  101f92:	53                   	push   %ebx
  101f93:	8b 45 0c             	mov    0xc(%ebp),%eax
  101f96:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101f99:	8b 00                	mov    (%eax),%eax
  101f9b:	8b 91 2c 05 00 00    	mov    0x52c(%ecx),%edx
  101fa1:	0f c8                	bswap  %eax
  101fa3:	89 c3                	mov    %eax,%ebx
	uint32_t subnet = ntohl(addr->s_addr[0]) &
			ntohl(iface->ipv4.netmask.s_addr[0]);
	int i;

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (!iface->ipv4.unicast[i].is_used ||
  101fa5:	8a 81 dc 04 00 00    	mov    0x4dc(%ecx),%al
  101fab:	84 c0                	test   %al,%al
  101fad:	74 21                	je     101fd0 <net_if_ipv4_addr_mask_cmp+0x41>
		     ntohl(iface->ipv4.netmask.s_addr[0])) == subnet) {
			return true;
		}
	}

	return false;
  101faf:	31 c0                	xor    %eax,%eax
		if (!iface->ipv4.unicast[i].is_used ||
  101fb1:	66 83 b9 e0 04 00 00 	cmpw   $0x2,0x4e0(%ecx)
  101fb8:	02 
  101fb9:	75 15                	jne    101fd0 <net_if_ipv4_addr_mask_cmp+0x41>
  101fbb:	8b 89 e4 04 00 00    	mov    0x4e4(%ecx),%ecx
	uint32_t subnet = ntohl(addr->s_addr[0]) &
  101fc1:	89 d8                	mov    %ebx,%eax
  101fc3:	0f ca                	bswap  %edx
  101fc5:	0f c9                	bswap  %ecx
  101fc7:	21 d0                	and    %edx,%eax
		if ((ntohl(iface->ipv4.unicast[i].address.in_addr.s_addr[0]) &
  101fc9:	21 ca                	and    %ecx,%edx
  101fcb:	39 d0                	cmp    %edx,%eax
  101fcd:	0f 94 c0             	sete   %al
}
  101fd0:	5b                   	pop    %ebx
  101fd1:	5d                   	pop    %ebp
  101fd2:	c3                   	ret    

00101fd3 <net_if_ipv4_addr_lookup>:

struct net_if_addr *net_if_ipv4_addr_lookup(const struct in_addr *addr,
					    struct net_if **ret)
{
  101fd3:	55                   	push   %ebp
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  101fd4:	b8 20 8e 10 00       	mov    $0x108e20,%eax
{
  101fd9:	89 e5                	mov    %esp,%ebp
  101fdb:	53                   	push   %ebx
  101fdc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101fdf:	8b 55 0c             	mov    0xc(%ebp),%edx
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  101fe2:	3d 60 93 10 00       	cmp    $0x109360,%eax
  101fe7:	74 31                	je     10201a <net_if_ipv4_addr_lookup+0x47>
		int i;

		for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
			if (!iface->ipv4.unicast[i].is_used ||
  101fe9:	80 b8 dc 04 00 00 00 	cmpb   $0x0,0x4dc(%eax)
  101ff0:	75 07                	jne    101ff9 <net_if_ipv4_addr_lookup+0x26>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  101ff2:	05 40 05 00 00       	add    $0x540,%eax
  101ff7:	eb e9                	jmp    101fe2 <net_if_ipv4_addr_lookup+0xf>
			if (!iface->ipv4.unicast[i].is_used ||
  101ff9:	66 83 b8 e0 04 00 00 	cmpw   $0x2,0x4e0(%eax)
  102000:	02 
  102001:	75 ef                	jne    101ff2 <net_if_ipv4_addr_lookup+0x1f>
			    iface->ipv4.unicast[i].address.family != AF_INET) {
				continue;
			}

			if (addr->s4_addr32[0] ==
  102003:	8b 98 e4 04 00 00    	mov    0x4e4(%eax),%ebx
  102009:	39 19                	cmp    %ebx,(%ecx)
  10200b:	75 e5                	jne    101ff2 <net_if_ipv4_addr_lookup+0x1f>
			    iface->ipv4.unicast[i].address.in_addr.s_addr[0]) {

				if (ret) {
  10200d:	85 d2                	test   %edx,%edx
  10200f:	74 02                	je     102013 <net_if_ipv4_addr_lookup+0x40>
					*ret = iface;
  102011:	89 02                	mov    %eax,(%edx)
				}

				return &iface->ipv4.unicast[i];
  102013:	05 dc 04 00 00       	add    $0x4dc,%eax
  102018:	eb 02                	jmp    10201c <net_if_ipv4_addr_lookup+0x49>
			}
		}
	}

	return NULL;
  10201a:	31 c0                	xor    %eax,%eax
}
  10201c:	5b                   	pop    %ebx
  10201d:	5d                   	pop    %ebp
  10201e:	c3                   	ret    

0010201f <net_if_ipv4_addr_add>:

struct net_if_addr *net_if_ipv4_addr_add(struct net_if *iface,
					 struct in_addr *addr,
					 enum net_addr_type addr_type,
					 uint32_t vlifetime)
{
  10201f:	55                   	push   %ebp
  102020:	89 e5                	mov    %esp,%ebp
  102022:	53                   	push   %ebx
  102023:	8b 55 08             	mov    0x8(%ebp),%edx
  102026:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		if (!iface->ipv4.unicast[i].is_used) {
  102029:	80 ba dc 04 00 00 00 	cmpb   $0x0,0x4dc(%edx)
  102030:	74 0e                	je     102040 <net_if_ipv4_addr_add+0x21>
		if (net_ipv4_addr_cmp(addr,
  102032:	8b 9a e4 04 00 00    	mov    0x4e4(%edx),%ebx
		net_mgmt_event_notify(NET_EVENT_IPV4_ADDR_ADD, iface);

		return &iface->ipv4.unicast[i];
	}

	return NULL;
  102038:	31 c0                	xor    %eax,%eax
		if (net_ipv4_addr_cmp(addr,
  10203a:	39 19                	cmp    %ebx,(%ecx)
  10203c:	75 3e                	jne    10207c <net_if_ipv4_addr_add+0x5d>
  10203e:	eb 36                	jmp    102076 <net_if_ipv4_addr_add+0x57>
		iface->ipv4.unicast[i].is_used = true;
  102040:	c6 82 dc 04 00 00 01 	movb   $0x1,0x4dc(%edx)
		iface->ipv4.unicast[i].address.family = AF_INET;
  102047:	66 c7 82 e0 04 00 00 	movw   $0x2,0x4e0(%edx)
  10204e:	02 00 
						addr->s4_addr32[0];
  102050:	8b 01                	mov    (%ecx),%eax
		iface->ipv4.unicast[i].addr_state = NET_ADDR_PREFERRED;
  102052:	c7 82 ec 04 00 00 01 	movl   $0x1,0x4ec(%edx)
  102059:	00 00 00 
		iface->ipv4.unicast[i].address.in_addr.s4_addr32[0] =
  10205c:	89 82 e4 04 00 00    	mov    %eax,0x4e4(%edx)
		iface->ipv4.unicast[i].addr_type = addr_type;
  102062:	8b 45 10             	mov    0x10(%ebp),%eax
  102065:	89 82 e8 04 00 00    	mov    %eax,0x4e8(%edx)
			iface->ipv4.unicast[i].is_infinite = false;
  10206b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10206f:	0f 94 82 f0 04 00 00 	sete   0x4f0(%edx)
		return &iface->ipv4.unicast[i];
  102076:	8d 82 dc 04 00 00    	lea    0x4dc(%edx),%eax
}
  10207c:	5b                   	pop    %ebx
  10207d:	5d                   	pop    %ebp
  10207e:	c3                   	ret    

0010207f <net_if_call_link_cb>:
	sys_slist_find_and_remove(&link_callbacks, &link->node);
}

void net_if_call_link_cb(struct net_if *iface, struct net_linkaddr *lladdr,
			 int status)
{
  10207f:	55                   	push   %ebp
  102080:	a1 74 94 10 00       	mov    0x109474,%eax
  102085:	89 e5                	mov    %esp,%ebp
  102087:	53                   	push   %ebx
	struct net_if_link_cb *link, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
  102088:	31 db                	xor    %ebx,%ebx
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  10208a:	85 c0                	test   %eax,%eax
  10208c:	74 1f                	je     1020ad <net_if_call_link_cb+0x2e>
	return node->next;
  10208e:	8b 18                	mov    (%eax),%ebx
  102090:	eb 1b                	jmp    1020ad <net_if_call_link_cb+0x2e>
		link->cb(iface, lladdr, status);
  102092:	ff 75 10             	pushl  0x10(%ebp)
  102095:	ff 75 0c             	pushl  0xc(%ebp)
  102098:	ff 75 08             	pushl  0x8(%ebp)
  10209b:	ff 50 04             	call   *0x4(%eax)
  10209e:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
  1020a1:	31 d2                	xor    %edx,%edx
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  1020a3:	85 db                	test   %ebx,%ebx
  1020a5:	74 02                	je     1020a9 <net_if_call_link_cb+0x2a>
	return node->next;
  1020a7:	8b 13                	mov    (%ebx),%edx
  1020a9:	89 d8                	mov    %ebx,%eax
  1020ab:	89 d3                	mov    %edx,%ebx
  1020ad:	85 c0                	test   %eax,%eax
  1020af:	75 e1                	jne    102092 <net_if_call_link_cb+0x13>
	}
}
  1020b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1020b4:	c9                   	leave  
  1020b5:	c3                   	ret    

001020b6 <net_if_send_data>:
{
  1020b6:	55                   	push   %ebp
  1020b7:	89 e5                	mov    %esp,%ebp
  1020b9:	57                   	push   %edi
  1020ba:	56                   	push   %esi
  1020bb:	53                   	push   %ebx
  1020bc:	83 ec 08             	sub    $0x8,%esp
  1020bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1020c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return ((struct net_nbuf *)net_buf_user_data(buf))->context;
  1020c5:	89 c8                	mov    %ecx,%eax
  1020c7:	e8 96 fb ff ff       	call   101c62 <net_buf_user_data>
  1020cc:	89 c6                	mov    %eax,%esi
  1020ce:	8b 38                	mov    (%eax),%edi
	return ((struct net_nbuf *)net_buf_user_data(buf))->token;
  1020d0:	8b 40 04             	mov    0x4(%eax),%eax
  1020d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1020d6:	8b 43 04             	mov    0x4(%ebx),%eax
	if (!atomic_test_bit(iface->flags, NET_IF_UP)) {
  1020d9:	a8 01                	test   $0x1,%al
  1020db:	74 3e                	je     10211b <net_if_send_data+0x65>
  1020dd:	8b 43 04             	mov    0x4(%ebx),%eax
	if (!atomic_test_bit(iface->flags, NET_IF_POINTOPOINT) &&
  1020e0:	a8 02                	test   $0x2,%al
  1020e2:	75 26                	jne    10210a <net_if_send_data+0x54>
	return net_nbuf_ip_data(buf) - net_nbuf_ll_reserve(buf);
}

static inline struct net_linkaddr *net_nbuf_ll_src(struct net_buf *buf)
{
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  1020e4:	89 c8                	mov    %ecx,%eax
  1020e6:	e8 77 fb ff ff       	call   101c62 <net_buf_user_data>
  1020eb:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  1020ef:	75 19                	jne    10210a <net_if_send_data+0x54>
		net_nbuf_ll_src(buf)->addr = net_nbuf_ll_if(buf)->addr;
  1020f1:	8b 50 08             	mov    0x8(%eax),%edx
  1020f4:	8b 52 10             	mov    0x10(%edx),%edx
  1020f7:	89 50 14             	mov    %edx,0x14(%eax)
  1020fa:	89 c8                	mov    %ecx,%eax
  1020fc:	e8 61 fb ff ff       	call   101c62 <net_buf_user_data>
		net_nbuf_ll_src(buf)->len = net_nbuf_ll_if(buf)->len;
  102101:	8b 50 08             	mov    0x8(%eax),%edx
  102104:	8a 52 14             	mov    0x14(%edx),%dl
  102107:	88 50 18             	mov    %dl,0x18(%eax)
	verdict = iface->l2->send(iface, buf);
  10210a:	8b 43 08             	mov    0x8(%ebx),%eax
  10210d:	51                   	push   %ecx
  10210e:	53                   	push   %ebx
  10210f:	ff 50 04             	call   *0x4(%eax)
  102112:	5a                   	pop    %edx
	int status = -EIO;
  102113:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
	verdict = iface->l2->send(iface, buf);
  102118:	59                   	pop    %ecx
  102119:	eb 0a                	jmp    102125 <net_if_send_data+0x6f>
		status = -ENETDOWN;
  10211b:	ba c2 ff ff ff       	mov    $0xffffffc2,%edx
		verdict = NET_DROP;
  102120:	b8 02 00 00 00       	mov    $0x2,%eax
	if (context && verdict == NET_DROP) {
  102125:	85 ff                	test   %edi,%edi
  102127:	74 27                	je     102150 <net_if_send_data+0x9a>
  102129:	83 f8 02             	cmp    $0x2,%eax
  10212c:	75 22                	jne    102150 <net_if_send_data+0x9a>
	if (context->send_cb) {
  10212e:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  102131:	85 c9                	test   %ecx,%ecx
  102133:	74 20                	je     102155 <net_if_send_data+0x9f>
		context->send_cb(context, status, token, context->user_data);
  102135:	ff 77 24             	pushl  0x24(%edi)
  102138:	ff 75 f0             	pushl  -0x10(%ebp)
  10213b:	52                   	push   %edx
  10213c:	57                   	push   %edi
  10213d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102140:	89 55 f0             	mov    %edx,-0x10(%ebp)
  102143:	ff d1                	call   *%ecx
  102145:	83 c4 10             	add    $0x10,%esp
  102148:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10214b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10214e:	eb 05                	jmp    102155 <net_if_send_data+0x9f>
	if (verdict == NET_DROP) {
  102150:	83 f8 02             	cmp    $0x2,%eax
  102153:	75 14                	jne    102169 <net_if_send_data+0xb3>
}

static inline struct net_linkaddr *net_nbuf_ll_dst(struct net_buf *buf)
{
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  102155:	83 c6 1c             	add    $0x1c,%esi
		net_if_call_link_cb(iface, dst, status);
  102158:	52                   	push   %edx
  102159:	56                   	push   %esi
  10215a:	53                   	push   %ebx
  10215b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10215e:	e8 1c ff ff ff       	call   10207f <net_if_call_link_cb>
  102163:	83 c4 0c             	add    $0xc,%esp
  102166:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  102169:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10216c:	5b                   	pop    %ebx
  10216d:	5e                   	pop    %esi
  10216e:	5f                   	pop    %edi
  10216f:	5d                   	pop    %ebp
  102170:	c3                   	ret    

00102171 <net_if_get_by_index>:

struct net_if *net_if_get_by_index(uint8_t index)
{
  102171:	55                   	push   %ebp
  102172:	89 e5                	mov    %esp,%ebp
	if (&__net_if_start[index] >= __net_if_end) {
  102174:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  102178:	69 c0 40 05 00 00    	imul   $0x540,%eax,%eax
  10217e:	05 20 8e 10 00       	add    $0x108e20,%eax
  102183:	3d 60 93 10 00       	cmp    $0x109360,%eax
  102188:	72 02                	jb     10218c <net_if_get_by_index+0x1b>
		NET_DBG("Index %d is too large", index);
		return NULL;
  10218a:	31 c0                	xor    %eax,%eax
	}

	return &__net_if_start[index];
}
  10218c:	5d                   	pop    %ebp
  10218d:	c3                   	ret    

0010218e <net_if_get_by_iface>:

uint8_t net_if_get_by_iface(struct net_if *iface)
{
  10218e:	55                   	push   %ebp
  10218f:	89 e5                	mov    %esp,%ebp
	NET_ASSERT(iface >= __net_if_start && iface < __net_if_end);

	return iface - __net_if_start;
  102191:	8b 45 08             	mov    0x8(%ebp),%eax
}
  102194:	5d                   	pop    %ebp
	return iface - __net_if_start;
  102195:	2d 20 8e 10 00       	sub    $0x108e20,%eax
  10219a:	c1 f8 06             	sar    $0x6,%eax
  10219d:	69 c0 3d cf f3 3c    	imul   $0x3cf3cf3d,%eax,%eax
}
  1021a3:	c3                   	ret    

001021a4 <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
  1021a4:	55                   	push   %ebp
	int status;

	NET_DBG("iface %p", iface);

	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
		return 0;
  1021a5:	31 c0                	xor    %eax,%eax
{
  1021a7:	89 e5                	mov    %esp,%ebp
  1021a9:	53                   	push   %ebx
  1021aa:	8b 55 08             	mov    0x8(%ebp),%edx
  1021ad:	8b 4a 04             	mov    0x4(%edx),%ecx
	if (atomic_test_bit(iface->flags, NET_IF_UP)) {
  1021b0:	80 e1 01             	and    $0x1,%cl
  1021b3:	75 20                	jne    1021d5 <net_if_up+0x31>
	}

	/* If the L2 does not support enable just set the flag */
	if (!iface->l2->enable) {
  1021b5:	8b 42 08             	mov    0x8(%edx),%eax
  1021b8:	8d 5a 04             	lea    0x4(%edx),%ebx
  1021bb:	8b 40 0c             	mov    0xc(%eax),%eax
  1021be:	85 c0                	test   %eax,%eax
  1021c0:	75 08                	jne    1021ca <net_if_up+0x26>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  1021c2:	f0 83 0b 01          	lock orl $0x1,(%ebx)
	net_if_start_rs(iface);
#endif

	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
  1021c6:	31 c0                	xor    %eax,%eax
  1021c8:	eb 0b                	jmp    1021d5 <net_if_up+0x31>
	status = iface->l2->enable(iface, true);
  1021ca:	6a 01                	push   $0x1
  1021cc:	52                   	push   %edx
  1021cd:	ff d0                	call   *%eax
  1021cf:	5a                   	pop    %edx
	if (status < 0) {
  1021d0:	85 c0                	test   %eax,%eax
	status = iface->l2->enable(iface, true);
  1021d2:	59                   	pop    %ecx
	if (status < 0) {
  1021d3:	79 ed                	jns    1021c2 <net_if_up+0x1e>
}
  1021d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1021d8:	c9                   	leave  
  1021d9:	c3                   	ret    

001021da <net_if_tx_thread>:
{
  1021da:	55                   	push   %ebp
  1021db:	89 e5                	mov    %esp,%ebp
  1021dd:	57                   	push   %edi
  1021de:	56                   	push   %esi
  1021df:	53                   	push   %ebx
  1021e0:	83 ec 18             	sub    $0x18,%esp
  1021e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct net_if_api *api = iface->dev->driver_api;
  1021e6:	8b 03                	mov    (%ebx),%eax
  1021e8:	8b 40 04             	mov    0x4(%eax),%eax
	api->init(iface);
  1021eb:	53                   	push   %ebx
	const struct net_if_api *api = iface->dev->driver_api;
  1021ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
	api->init(iface);
  1021ef:	ff 10                	call   *(%eax)
	net_if_up(iface);
  1021f1:	89 1c 24             	mov    %ebx,(%esp)
  1021f4:	e8 ab ff ff ff       	call   1021a4 <net_if_up>
  1021f9:	58                   	pop    %eax
		net_analyze_stack("TX thread", iface->tx_stack,
  1021fa:	8d 43 2c             	lea    0x2c(%ebx),%eax
  1021fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	*stack_offset = K_THREAD_SIZEOF + ((4 - ((unsigned)stack % 4)) % 4);
  102200:	f7 d8                	neg    %eax
  102202:	83 e0 03             	and    $0x3,%eax
  102205:	89 45 e0             	mov    %eax,-0x20(%ebp)
		buf = net_buf_get(&iface->tx_queue, K_FOREVER);
  102208:	8d 43 1c             	lea    0x1c(%ebx),%eax
  10220b:	6a ff                	push   $0xffffffff
  10220d:	50                   	push   %eax
  10220e:	e8 7b f8 ff ff       	call   101a8e <net_buf_get>
  102213:	5e                   	pop    %esi
  102214:	89 c6                	mov    %eax,%esi
  102216:	5f                   	pop    %edi
  102217:	e8 46 fa ff ff       	call   101c62 <net_buf_user_data>
  10221c:	8d 50 1c             	lea    0x1c(%eax),%edx
	return ((struct net_nbuf *)net_buf_user_data(buf))->context;
  10221f:	8b 38                	mov    (%eax),%edi
	return ((struct net_nbuf *)net_buf_user_data(buf))->token;
  102221:	8b 40 04             	mov    0x4(%eax),%eax
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  102224:	89 55 ec             	mov    %edx,-0x14(%ebp)
	return ((struct net_nbuf *)net_buf_user_data(buf))->token;
  102227:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			status = -ENETDOWN;
  10222a:	b8 c2 ff ff ff       	mov    $0xffffffc2,%eax
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10222f:	8b 4b 04             	mov    0x4(%ebx),%ecx
		if (atomic_test_bit(iface->flags, NET_IF_UP)) {
  102232:	80 e1 01             	and    $0x1,%cl
  102235:	74 0e                	je     102245 <net_if_tx_thread+0x6b>
			status = api->send(iface, buf);
  102237:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10223a:	56                   	push   %esi
  10223b:	53                   	push   %ebx
  10223c:	ff 50 04             	call   *0x4(%eax)
  10223f:	5a                   	pop    %edx
		if (status < 0) {
  102240:	85 c0                	test   %eax,%eax
			status = api->send(iface, buf);
  102242:	59                   	pop    %ecx
		if (status < 0) {
  102243:	79 0d                	jns    102252 <net_if_tx_thread+0x78>
  102245:	89 45 dc             	mov    %eax,-0x24(%ebp)
			net_nbuf_unref(buf);
  102248:	56                   	push   %esi
  102249:	e8 0e 11 00 00       	call   10335c <net_nbuf_unref>
  10224e:	58                   	pop    %eax
  10224f:	8b 45 dc             	mov    -0x24(%ebp),%eax
		if (context) {
  102252:	85 ff                	test   %edi,%edi
  102254:	74 1a                	je     102270 <net_if_tx_thread+0x96>
	if (context->send_cb) {
  102256:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  102259:	85 c9                	test   %ecx,%ecx
  10225b:	74 13                	je     102270 <net_if_tx_thread+0x96>
		context->send_cb(context, status, token, context->user_data);
  10225d:	ff 77 24             	pushl  0x24(%edi)
  102260:	ff 75 e4             	pushl  -0x1c(%ebp)
  102263:	50                   	push   %eax
  102264:	57                   	push   %edi
  102265:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  102268:	ff d1                	call   *%ecx
  10226a:	83 c4 10             	add    $0x10,%esp
  10226d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		net_if_call_link_cb(iface, dst, status);
  102270:	50                   	push   %eax
  102271:	ff 75 ec             	pushl  -0x14(%ebp)
  102274:	53                   	push   %ebx
  102275:	e8 05 fe ff ff       	call   10207f <net_if_call_link_cb>
  10227a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10227d:	83 c4 0c             	add    $0xc,%esp
  102280:	83 c0 38             	add    $0x38,%eax
		if ((unsigned char)stack[i] == 0xaa) {
  102283:	8b 55 e8             	mov    -0x18(%ebp),%edx
  102286:	80 3c 02 aa          	cmpb   $0xaa,(%edx,%eax,1)
  10228a:	75 08                	jne    102294 <net_if_tx_thread+0xba>
	for (i = *stack_offset; i < size; i++) {
  10228c:	40                   	inc    %eax
  10228d:	3d b0 04 00 00       	cmp    $0x4b0,%eax
  102292:	75 ef                	jne    102283 <net_if_tx_thread+0xa9>
		k_yield();
  102294:	e8 13 50 00 00       	call   1072ac <k_yield>
	while (1) {
  102299:	e9 6a ff ff ff       	jmp    102208 <net_if_tx_thread+0x2e>

0010229e <net_if_init>:

	return 0;
}

void net_if_init(void)
{
  10229e:	55                   	push   %ebp
  10229f:	89 e5                	mov    %esp,%ebp
  1022a1:	53                   	push   %ebx
	struct net_if *iface;

	NET_DBG("");

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  1022a2:	bb 20 8e 10 00       	mov    $0x108e20,%ebx
  1022a7:	81 fb 60 93 10 00    	cmp    $0x109360,%ebx
  1022ad:	74 3b                	je     1022ea <net_if_init+0x4c>
	k_fifo_init(&iface->tx_queue);
  1022af:	8d 43 1c             	lea    0x1c(%ebx),%eax
  1022b2:	50                   	push   %eax
  1022b3:	e8 57 49 00 00       	call   106c0f <k_fifo_init>
	k_thread_spawn(iface->tx_stack, sizeof(iface->tx_stack),
  1022b8:	8d 43 2c             	lea    0x2c(%ebx),%eax
  1022bb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1022c2:	6a 00                	push   $0x0
  1022c4:	6a f7                	push   $0xfffffff7
  1022c6:	6a 00                	push   $0x0
  1022c8:	6a 00                	push   $0x0
  1022ca:	53                   	push   %ebx
  1022cb:	68 da 21 10 00       	push   $0x1021da
  1022d0:	68 b0 04 00 00       	push   $0x4b0
  1022d5:	50                   	push   %eax
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
  1022d6:	81 c3 40 05 00 00    	add    $0x540,%ebx
	k_thread_spawn(iface->tx_stack, sizeof(iface->tx_stack),
  1022dc:	e8 3a 55 00 00       	call   10781b <k_thread_spawn>
		init_tx_queue(iface);

#if defined(CONFIG_NET_IPV4)
		iface->ttl = CONFIG_NET_INITIAL_TTL;
  1022e1:	c6 43 f0 40          	movb   $0x40,-0x10(%ebx)
	k_thread_spawn(iface->tx_stack, sizeof(iface->tx_stack),
  1022e5:	83 c4 24             	add    $0x24,%esp
  1022e8:	eb bd                	jmp    1022a7 <net_if_init+0x9>

	/* RPL init must be done after the network interface is up
	 * as the RPL code wants to add multicast address to interface.
	 */
	net_rpl_init();
}
  1022ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1022ed:	c9                   	leave  
  1022ee:	c3                   	ret    

001022ef <sys_get_be32>:
 *  @param src Location of the big-endian 32-bit integer to get.
 *
 *  @return 32-bit integer in host endianness.
 */
static inline uint32_t sys_get_be32(const uint8_t src[4])
{
  1022ef:	55                   	push   %ebp
  1022f0:	89 c1                	mov    %eax,%ecx
  1022f2:	89 e5                	mov    %esp,%ebp
  1022f4:	53                   	push   %ebx
	return ((uint16_t)src[0] << 8) | src[1];
  1022f5:	0f b6 18             	movzbl (%eax),%ebx
  1022f8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  1022fc:	c1 e3 08             	shl    $0x8,%ebx
  1022ff:	09 d8                	or     %ebx,%eax
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
  102301:	89 c3                	mov    %eax,%ebx
	return ((uint16_t)src[0] << 8) | src[1];
  102303:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  102307:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
  10230b:	c1 e0 08             	shl    $0x8,%eax
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
  10230e:	c1 e3 10             	shl    $0x10,%ebx
	return ((uint16_t)src[0] << 8) | src[1];
  102311:	09 c2                	or     %eax,%edx
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
  102313:	0f b7 c2             	movzwl %dx,%eax
  102316:	09 d8                	or     %ebx,%eax
}
  102318:	5b                   	pop    %ebx
  102319:	5d                   	pop    %ebp
  10231a:	c3                   	ret    

0010231b <check_used_port>:

static int check_used_port(enum net_ip_protocol ip_proto,
			   uint16_t local_port,
			   const struct sockaddr *local_addr)

{
  10231b:	55                   	push   %ebp
  10231c:	89 e5                	mov    %esp,%ebp
  10231e:	57                   	push   %edi
  10231f:	56                   	push   %esi
  102320:	53                   	push   %ebx
  102321:	83 ec 08             	sub    $0x8,%esp
  102324:	89 ce                	mov    %ecx,%esi
  102326:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102329:	31 db                	xor    %ebx,%ebx

		if (local_addr->family == AF_INET6) {
			if (net_ipv6_addr_cmp(
				    net_sin6_ptr(&contexts[i].local)->
							     sin6_addr,
				    &((struct sockaddr_in6 *)
  10232b:	8d 79 04             	lea    0x4(%ecx),%edi
  10232e:	8a 83 d9 94 10 00    	mov    0x1094d9(%ebx),%al
		if (!net_context_is_used(&contexts[i])) {
  102334:	a8 01                	test   $0x1,%al
  102336:	75 0f                	jne    102347 <check_used_port+0x2c>
  102338:	83 c3 40             	add    $0x40,%ebx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10233b:	81 fb 80 01 00 00    	cmp    $0x180,%ebx
  102341:	75 eb                	jne    10232e <check_used_port+0x13>
				return -EEXIST;
			}
		}
	}

	return 0;
  102343:	31 c0                	xor    %eax,%eax
  102345:	eb 50                	jmp    102397 <check_used_port+0x7c>
static inline
enum net_ip_protocol net_context_get_ip_proto(struct net_context *context)
{
	NET_ASSERT(context);

	if (context->flags & NET_CONTEXT_PROTO) {
  102347:	83 e0 40             	and    $0x40,%eax
		return IPPROTO_TCP;
  10234a:	3c 01                	cmp    $0x1,%al
  10234c:	19 c0                	sbb    %eax,%eax
  10234e:	83 e0 0b             	and    $0xb,%eax
  102351:	83 c0 06             	add    $0x6,%eax
		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
  102354:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  102357:	75 df                	jne    102338 <check_used_port+0x1d>
  102359:	66 39 93 a6 94 10 00 	cmp    %dx,0x1094a6(%ebx)
  102360:	75 d6                	jne    102338 <check_used_port+0x1d>
		if (local_addr->family == AF_INET6) {
  102362:	66 83 3e 0a          	cmpw   $0xa,(%esi)
  102366:	75 22                	jne    10238a <check_used_port+0x6f>
 *  @return True if the addresses are the same, false otherwise.
 */
static inline bool net_ipv6_addr_cmp(const struct in6_addr *addr1,
				     const struct in6_addr *addr2)
{
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
  102368:	6a 10                	push   $0x10
  10236a:	57                   	push   %edi
  10236b:	ff b3 a8 94 10 00    	pushl  0x1094a8(%ebx)
  102371:	89 55 ec             	mov    %edx,-0x14(%ebp)
  102374:	e8 8f f0 ff ff       	call   101408 <memcmp>
  102379:	83 c4 0c             	add    $0xc,%esp
			if (net_ipv6_addr_cmp(
  10237c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10237f:	85 c0                	test   %eax,%eax
  102381:	75 b5                	jne    102338 <check_used_port+0x1d>
				return -EEXIST;
  102383:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  102388:	eb 0d                	jmp    102397 <check_used_port+0x7c>
	return addr1->s_addr[0] == addr2->s_addr[0];
  10238a:	8b 83 a8 94 10 00    	mov    0x1094a8(%ebx),%eax
			if (net_ipv4_addr_cmp(
  102390:	8b 4e 04             	mov    0x4(%esi),%ecx
  102393:	39 08                	cmp    %ecx,(%eax)
  102395:	eb ea                	jmp    102381 <check_used_port+0x66>
}
  102397:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10239a:	5b                   	pop    %ebx
  10239b:	5e                   	pop    %esi
  10239c:	5f                   	pop    %edi
  10239d:	5d                   	pop    %ebp
  10239e:	c3                   	ret    

0010239f <send_reset.isra.11>:
	}

	return ret;
}

static int send_reset(struct net_context *context,
  10239f:	55                   	push   %ebp
  1023a0:	89 e5                	mov    %esp,%ebp
  1023a2:	83 ec 08             	sub    $0x8,%esp
		      struct sockaddr *remote)
{
	struct net_buf *buf = NULL;
	int ret;

	ret = net_tcp_prepare_reset(context->tcp, remote, &buf);
  1023a5:	8d 4d fc             	lea    -0x4(%ebp),%ecx
	struct net_buf *buf = NULL;
  1023a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	ret = net_tcp_prepare_reset(context->tcp, remote, &buf);
  1023af:	51                   	push   %ecx
  1023b0:	52                   	push   %edx
  1023b1:	50                   	push   %eax
  1023b2:	e8 ce 29 00 00       	call   104d85 <net_tcp_prepare_reset>
  1023b7:	83 c4 0c             	add    $0xc,%esp
	if (ret) {
  1023ba:	85 c0                	test   %eax,%eax
  1023bc:	75 1c                	jne    1023da <send_reset.isra.11+0x3b>
		return ret;
	}

	net_tcp_print_send_info("RST", buf, NET_TCP_BUF(buf)->dst_port);

	ret = net_send_data(buf);
  1023be:	ff 75 fc             	pushl  -0x4(%ebp)
  1023c1:	e8 9a fa ff ff       	call   101e60 <net_send_data>
  1023c6:	5a                   	pop    %edx
	if (ret < 0) {
  1023c7:	85 c0                	test   %eax,%eax
  1023c9:	79 0f                	jns    1023da <send_reset.isra.11+0x3b>
		net_nbuf_unref(buf);
  1023cb:	ff 75 fc             	pushl  -0x4(%ebp)
  1023ce:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1023d1:	e8 86 0f 00 00       	call   10335c <net_nbuf_unref>
  1023d6:	58                   	pop    %eax
  1023d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
	}

	return ret;
}
  1023da:	c9                   	leave  
  1023db:	c3                   	ret    

001023dc <send_control_segment.isra.12>:
static inline int send_control_segment(struct net_context *context,
  1023dc:	55                   	push   %ebp
  1023dd:	89 e5                	mov    %esp,%ebp
  1023df:	53                   	push   %ebx
  1023e0:	83 ec 08             	sub    $0x8,%esp
	ret = net_tcp_prepare_segment(context->tcp, flags, NULL, 0,
  1023e3:	8d 5d f8             	lea    -0x8(%ebp),%ebx
	struct net_buf *buf = NULL;
  1023e6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	ret = net_tcp_prepare_segment(context->tcp, flags, NULL, 0,
  1023ed:	53                   	push   %ebx
  1023ee:	51                   	push   %ecx
  1023ef:	52                   	push   %edx
  1023f0:	6a 00                	push   $0x0
  1023f2:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  1023f6:	6a 00                	push   $0x0
  1023f8:	52                   	push   %edx
  1023f9:	50                   	push   %eax
  1023fa:	e8 94 2b 00 00       	call   104f93 <net_tcp_prepare_segment>
  1023ff:	83 c4 1c             	add    $0x1c,%esp
	if (ret) {
  102402:	85 c0                	test   %eax,%eax
  102404:	75 1c                	jne    102422 <send_control_segment.isra.12+0x46>
	ret = net_send_data(buf);
  102406:	ff 75 f8             	pushl  -0x8(%ebp)
  102409:	e8 52 fa ff ff       	call   101e60 <net_send_data>
  10240e:	5a                   	pop    %edx
	if (ret < 0) {
  10240f:	85 c0                	test   %eax,%eax
  102411:	79 0f                	jns    102422 <send_control_segment.isra.12+0x46>
		net_nbuf_unref(buf);
  102413:	ff 75 f8             	pushl  -0x8(%ebp)
  102416:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102419:	e8 3e 0f 00 00       	call   10335c <net_nbuf_unref>
  10241e:	58                   	pop    %eax
  10241f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  102422:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102425:	c9                   	leave  
  102426:	c3                   	ret    

00102427 <send_ack.isra.13>:
static inline int send_ack(struct net_context *context,
  102427:	55                   	push   %ebp
  102428:	89 e5                	mov    %esp,%ebp
  10242a:	83 ec 08             	sub    $0x8,%esp
	if (context->tcp->send_ack == context->tcp->sent_ack) {
  10242d:	8b 48 78             	mov    0x78(%eax),%ecx
	struct net_buf *buf = NULL;
  102430:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	if (context->tcp->send_ack == context->tcp->sent_ack) {
  102437:	39 48 74             	cmp    %ecx,0x74(%eax)
  10243a:	74 30                	je     10246c <send_ack.isra.13+0x45>
	ret = net_tcp_prepare_ack(context->tcp, remote, &buf);
  10243c:	8d 4d fc             	lea    -0x4(%ebp),%ecx
  10243f:	51                   	push   %ecx
  102440:	52                   	push   %edx
  102441:	50                   	push   %eax
  102442:	e8 54 2c 00 00       	call   10509b <net_tcp_prepare_ack>
  102447:	83 c4 0c             	add    $0xc,%esp
	if (ret) {
  10244a:	85 c0                	test   %eax,%eax
  10244c:	75 20                	jne    10246e <send_ack.isra.13+0x47>
	ret = net_tcp_send_buf(buf);
  10244e:	ff 75 fc             	pushl  -0x4(%ebp)
  102451:	e8 b2 29 00 00       	call   104e08 <net_tcp_send_buf>
  102456:	5a                   	pop    %edx
	if (ret < 0) {
  102457:	85 c0                	test   %eax,%eax
  102459:	79 13                	jns    10246e <send_ack.isra.13+0x47>
		net_nbuf_unref(buf);
  10245b:	ff 75 fc             	pushl  -0x4(%ebp)
  10245e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102461:	e8 f6 0e 00 00       	call   10335c <net_nbuf_unref>
  102466:	58                   	pop    %eax
  102467:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10246a:	eb 02                	jmp    10246e <send_ack.isra.13+0x47>
		return 0;
  10246c:	31 c0                	xor    %eax,%eax
}
  10246e:	c9                   	leave  
  10246f:	c3                   	ret    

00102470 <net_nbuf_tcp_data>:
{
  102470:	55                   	push   %ebp
  102471:	89 c1                	mov    %eax,%ecx
  102473:	89 e5                	mov    %esp,%ebp
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  102475:	e8 f8 f7 ff ff       	call   101c72 <net_buf_user_data>
}
  10247a:	5d                   	pop    %ebp
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  10247b:	0f b6 50 2a          	movzbl 0x2a(%eax),%edx
				 net_nbuf_ext_len(buf)];
  10247f:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  102483:	8b 09                	mov    (%ecx),%ecx
  102485:	01 d0                	add    %edx,%eax
  102487:	03 41 10             	add    0x10(%ecx),%eax
}
  10248a:	c3                   	ret    

0010248b <net_nbuf_tcp_data>:
{
  10248b:	55                   	push   %ebp
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  10248c:	0f b7 50 16          	movzwl 0x16(%eax),%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  102490:	8b 08                	mov    (%eax),%ecx
{
  102492:	89 e5                	mov    %esp,%ebp
  102494:	8d 54 10 1b          	lea    0x1b(%eax,%edx,1),%edx
}
  102498:	5d                   	pop    %ebp
  102499:	83 e2 fc             	and    $0xfffffffc,%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  10249c:	0f b6 42 2a          	movzbl 0x2a(%edx),%eax
				 net_nbuf_ext_len(buf)];
  1024a0:	0f b6 52 2b          	movzbl 0x2b(%edx),%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1024a4:	01 d0                	add    %edx,%eax
  1024a6:	03 41 10             	add    0x10(%ecx),%eax
}
  1024a9:	c3                   	ret    

001024aa <net_nbuf_tcp_data>:
{
  1024aa:	55                   	push   %ebp
  1024ab:	0f b7 50 16          	movzwl 0x16(%eax),%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1024af:	8b 08                	mov    (%eax),%ecx
{
  1024b1:	89 e5                	mov    %esp,%ebp
  1024b3:	8d 54 10 1b          	lea    0x1b(%eax,%edx,1),%edx
}
  1024b7:	5d                   	pop    %ebp
  1024b8:	83 e2 fc             	and    $0xfffffffc,%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1024bb:	0f b6 42 2a          	movzbl 0x2a(%edx),%eax
				 net_nbuf_ext_len(buf)];
  1024bf:	0f b6 52 2b          	movzbl 0x2b(%edx),%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1024c3:	01 d0                	add    %edx,%eax
  1024c5:	03 41 10             	add    0x10(%ecx),%eax
}
  1024c8:	c3                   	ret    

001024c9 <sendto>:
		  socklen_t addrlen,
		  net_context_send_cb_t cb,
		  int32_t timeout,
		  void *token,
		  void *user_data)
{
  1024c9:	55                   	push   %ebp
  1024ca:	89 e5                	mov    %esp,%ebp
  1024cc:	57                   	push   %edi
  1024cd:	56                   	push   %esi
  1024ce:	53                   	push   %ebx
  1024cf:	83 ec 14             	sub    $0x14,%esp
  1024d2:	89 c3                	mov    %eax,%ebx
  1024d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1024d7:	89 d6                	mov    %edx,%esi
  1024d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1024dc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1024df:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1024e2:	8b 45 10             	mov    0x10(%ebp),%eax
  1024e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1024e8:	8b 45 14             	mov    0x14(%ebp),%eax
  1024eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return ((struct net_nbuf *)net_buf_user_data(buf))->context;
  1024ee:	89 d8                	mov    %ebx,%eax
  1024f0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1024f3:	e8 7a f7 ff ff       	call   101c72 <net_buf_user_data>
  1024f8:	8b 38                	mov    (%eax),%edi
  1024fa:	8a 57 39             	mov    0x39(%edi),%dl
	struct net_context *context = net_nbuf_context(buf);
	int ret;

	if (!net_context_is_used(context)) {
  1024fd:	f6 c2 01             	test   $0x1,%dl
  102500:	0f 84 83 01 00 00    	je     102689 <sendto+0x1c0>
	if (context->flags & NET_CONTEXT_PROTO) {
  102506:	f6 c2 40             	test   $0x40,%dl
  102509:	75 07                	jne    102512 <sendto+0x49>
	}

	return IPPROTO_UDP;
  10250b:	ba 11 00 00 00       	mov    $0x11,%edx
  102510:	eb 20                	jmp    102532 <sendto+0x69>
	return (context->flags >> NET_CONTEXT_STATE_SHIFT) &
  102512:	d0 ea                	shr    %dl
		return -ENOENT;
	}

#if defined(CONFIG_NET_TCP)
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		if (net_context_get_state(context) != NET_CONTEXT_CONNECTED) {
  102514:	83 e2 03             	and    $0x3,%edx
  102517:	80 fa 02             	cmp    $0x2,%dl
  10251a:	0f 85 8c 01 00 00    	jne    1026ac <sendto+0x1e3>
			return -ENOTCONN;
		}

		NET_ASSERT(context->tcp);
		if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
  102520:	8b 57 3c             	mov    0x3c(%edi),%edx
  102523:	f6 42 7d 01          	testb  $0x1,0x7d(%edx)
  102527:	0f 85 78 01 00 00    	jne    1026a5 <sendto+0x1dc>
		return IPPROTO_TCP;
  10252d:	ba 06 00 00 00       	mov    $0x6,%edx
			return -ESHUTDOWN;
		}
	}
#endif /* CONFIG_NET_TCP */

	if (!dst_addr) {
  102532:	85 f6                	test   %esi,%esi
  102534:	0f 84 5d 01 00 00    	je     102697 <sendto+0x1ce>

#if defined(CONFIG_NET_IPV4)
	if (net_nbuf_family(buf) == AF_INET) {
		struct sockaddr_in *addr4 = (struct sockaddr_in *)dst_addr;

		if (addrlen < sizeof(struct sockaddr_in)) {
  10253a:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  10253e:	0f 85 4c 01 00 00    	jne    102690 <sendto+0x1c7>
  102544:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
  102548:	0f 86 42 01 00 00    	jbe    102690 <sendto+0x1c7>
			return -EINVAL;
		}

		if (!addr4->sin_addr.s_addr[0]) {
  10254e:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  102552:	0f 84 3f 01 00 00    	je     102697 <sendto+0x1ce>
		NET_DBG("Invalid protocol family %d", net_nbuf_family(buf));
		return -EINVAL;
	}

#if defined(CONFIG_NET_UDP)
	if (net_context_get_ip_proto(context) == IPPROTO_UDP) {
  102558:	83 fa 11             	cmp    $0x11,%edx
  10255b:	0f 85 b9 00 00 00    	jne    10261a <sendto+0x151>
		buf = net_ipv4_create(context, buf, NULL, &addr4->sin_addr);
  102561:	8d 46 04             	lea    0x4(%esi),%eax
  102564:	50                   	push   %eax
  102565:	6a 00                	push   $0x0
  102567:	53                   	push   %ebx
  102568:	57                   	push   %edi
  102569:	e8 13 23 00 00       	call   104881 <net_ipv4_create>
  10256e:	83 c4 10             	add    $0x10,%esp
  102571:	89 c3                	mov    %eax,%ebx
static inline struct net_buf *net_udp_append(struct net_context *context,
					     struct net_buf *buf,
					     uint16_t port)
{
	return net_udp_append_raw(buf,
				  ntohs(net_sin((struct sockaddr *)
  102573:	66 8b 47 06          	mov    0x6(%edi),%ax
  102577:	86 e0                	xchg   %ah,%al
  102579:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	NET_UDP_BUF(buf)->src_port = htons(src_port);
  10257d:	89 d8                	mov    %ebx,%eax
		buf = net_udp_append(context, buf, ntohs(addr4->sin_port));
  10257f:	66 8b 76 02          	mov    0x2(%esi),%si
  102583:	e8 e8 fe ff ff       	call   102470 <net_nbuf_tcp_data>
  102588:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10258b:	86 f2                	xchg   %dh,%dl
  10258d:	66 c1 c6 08          	rol    $0x8,%si
	NET_UDP_BUF(buf)->dst_port = htons(dst_port);
  102591:	66 c1 c6 08          	rol    $0x8,%si
	NET_UDP_BUF(buf)->src_port = htons(src_port);
  102595:	66 89 10             	mov    %dx,(%eax)
	NET_UDP_BUF(buf)->dst_port = htons(dst_port);
  102598:	89 d8                	mov    %ebx,%eax
  10259a:	e8 d1 fe ff ff       	call   102470 <net_nbuf_tcp_data>
  10259f:	66 89 70 02          	mov    %si,0x2(%eax)
	net_buf_add(buf->frags, sizeof(struct net_udp_hdr));
  1025a3:	6a 08                	push   $0x8
  1025a5:	8b 03                	mov    (%ebx),%eax
  1025a7:	83 c0 10             	add    $0x10,%eax
  1025aa:	50                   	push   %eax
  1025ab:	e8 35 f6 ff ff       	call   101be5 <net_buf_simple_add>
  1025b0:	5e                   	pop    %esi
  1025b1:	58                   	pop    %eax
	NET_UDP_BUF(buf)->len = htons(net_buf_frags_len(buf) -
  1025b2:	89 d8                	mov    %ebx,%eax
  1025b4:	e8 b7 fe ff ff       	call   102470 <net_nbuf_tcp_data>
	size_t bytes = 0;
  1025b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1025c0:	89 c6                	mov    %eax,%esi
  1025c2:	89 d8                	mov    %ebx,%eax
		bytes += buf->len;
  1025c4:	0f b7 50 14          	movzwl 0x14(%eax),%edx
		buf = buf->frags;
  1025c8:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  1025ca:	01 55 f0             	add    %edx,-0x10(%ebp)
	while (buf) {
  1025cd:	85 c0                	test   %eax,%eax
  1025cf:	75 f3                	jne    1025c4 <sendto+0xfb>
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  1025d1:	89 d8                	mov    %ebx,%eax
  1025d3:	e8 9a f6 ff ff       	call   101c72 <net_buf_user_data>
  1025d8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1025db:	0f b6 40 2a          	movzbl 0x2a(%eax),%eax
  1025df:	29 c1                	sub    %eax,%ecx
  1025e1:	89 c2                	mov    %eax,%edx
  1025e3:	89 c8                	mov    %ecx,%eax
  1025e5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1025e8:	66 c1 e8 08          	shr    $0x8,%ax
  1025ec:	29 d1                	sub    %edx,%ecx
  1025ee:	c1 e1 08             	shl    $0x8,%ecx
  1025f1:	09 c1                	or     %eax,%ecx
	net_nbuf_set_appdata(buf, net_nbuf_udp_data(buf) +
  1025f3:	89 d8                	mov    %ebx,%eax
	NET_UDP_BUF(buf)->len = htons(net_buf_frags_len(buf) -
  1025f5:	66 89 4e 04          	mov    %cx,0x4(%esi)
	net_nbuf_set_appdata(buf, net_nbuf_udp_data(buf) +
  1025f9:	e8 72 fe ff ff       	call   102470 <net_nbuf_tcp_data>
  1025fe:	89 c6                	mov    %eax,%esi
	((struct net_nbuf *)net_buf_user_data(buf))->appdata = data;
  102600:	89 d8                	mov    %ebx,%eax
  102602:	e8 6b f6 ff ff       	call   101c72 <net_buf_user_data>
  102607:	8d 4e 08             	lea    0x8(%esi),%ecx
  10260a:	89 48 0c             	mov    %ecx,0xc(%eax)
		buf = net_ipv4_finalize(context, buf);
  10260d:	53                   	push   %ebx
  10260e:	57                   	push   %edi
  10260f:	e8 b3 23 00 00       	call   1049c7 <net_ipv4_finalize>
  102614:	5a                   	pop    %edx
  102615:	89 c3                	mov    %eax,%ebx
  102617:	59                   	pop    %ecx
  102618:	eb 16                	jmp    102630 <sendto+0x167>
		ret = create_udp_packet(context, buf, dst_addr, &buf);
	} else
#endif /* CONFIG_NET_UDP */

#if defined(CONFIG_NET_TCP)
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
  10261a:	83 fa 06             	cmp    $0x6,%edx
  10261d:	75 7f                	jne    10269e <sendto+0x1d5>
		ret = net_tcp_queue_data(context, buf);
  10261f:	53                   	push   %ebx
  102620:	57                   	push   %edi
  102621:	e8 0a 2b 00 00       	call   105130 <net_tcp_queue_data>
  102626:	59                   	pop    %ecx
		NET_DBG("Unknown protocol while sending packet: %d",
			net_context_get_ip_proto(context));
		return -EPROTONOSUPPORT;
	}

	if (ret < 0) {
  102627:	85 c0                	test   %eax,%eax
		ret = net_tcp_queue_data(context, buf);
  102629:	5e                   	pop    %esi
	if (ret < 0) {
  10262a:	0f 88 81 00 00 00    	js     1026b1 <sendto+0x1e8>
	context->send_cb = cb;
  102630:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102633:	89 47 1c             	mov    %eax,0x1c(%edi)
	context->user_data = user_data;
  102636:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102639:	89 47 24             	mov    %eax,0x24(%edi)
	((struct net_nbuf *)net_buf_user_data(buf))->token = token;
  10263c:	89 d8                	mov    %ebx,%eax
  10263e:	e8 2f f6 ff ff       	call   101c72 <net_buf_user_data>
  102643:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	if (!timeout || net_context_get_ip_proto(context) == IPPROTO_UDP) {
  102646:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  10264a:	89 48 04             	mov    %ecx,0x4(%eax)
  10264d:	74 06                	je     102655 <sendto+0x18c>
	if (context->flags & NET_CONTEXT_PROTO) {
  10264f:	f6 47 39 40          	testb  $0x40,0x39(%edi)
  102653:	75 0f                	jne    102664 <sendto+0x19b>
		return net_send_data(buf);
  102655:	89 5d 08             	mov    %ebx,0x8(%ebp)
		NET_DBG("Could not create network packet to send");
		return ret;
	}

	return send_data(context, buf, cb, timeout, token, user_data);
}
  102658:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10265b:	5b                   	pop    %ebx
  10265c:	5e                   	pop    %esi
  10265d:	5f                   	pop    %edi
  10265e:	5d                   	pop    %ebp
		return net_send_data(buf);
  10265f:	e9 fc f7 ff ff       	jmp    101e60 <net_send_data>
		int ret = net_tcp_send_data(context);
  102664:	57                   	push   %edi
  102665:	e8 70 28 00 00       	call   104eda <net_tcp_send_data>
  10266a:	5a                   	pop    %edx
		if (cb) {
  10266b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10266f:	74 40                	je     1026b1 <sendto+0x1e8>
			cb(context, ret, token, user_data);
  102671:	ff 75 e4             	pushl  -0x1c(%ebp)
  102674:	ff 75 e8             	pushl  -0x18(%ebp)
  102677:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10267a:	50                   	push   %eax
  10267b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10267e:	57                   	push   %edi
  10267f:	ff d0                	call   *%eax
  102681:	83 c4 10             	add    $0x10,%esp
  102684:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102687:	eb 28                	jmp    1026b1 <sendto+0x1e8>
		return -ENOENT;
  102689:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  10268e:	eb 21                	jmp    1026b1 <sendto+0x1e8>
			return -EINVAL;
  102690:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  102695:	eb 1a                	jmp    1026b1 <sendto+0x1e8>
		return -EDESTADDRREQ;
  102697:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
  10269c:	eb 13                	jmp    1026b1 <sendto+0x1e8>
		return -EPROTONOSUPPORT;
  10269e:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
  1026a3:	eb 0c                	jmp    1026b1 <sendto+0x1e8>
			return -ESHUTDOWN;
  1026a5:	b8 c6 ff ff ff       	mov    $0xffffffc6,%eax
  1026aa:	eb 05                	jmp    1026b1 <sendto+0x1e8>
			return -ENOTCONN;
  1026ac:	b8 c7 ff ff ff       	mov    $0xffffffc7,%eax
}
  1026b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1026b4:	5b                   	pop    %ebx
  1026b5:	5e                   	pop    %esi
  1026b6:	5f                   	pop    %edi
  1026b7:	5d                   	pop    %ebp
  1026b8:	c3                   	ret    

001026b9 <set_appdata_values>:
}

static void set_appdata_values(struct net_buf *buf,
			       enum net_ip_protocol proto,
			       size_t total_len)
{
  1026b9:	55                   	push   %ebp
#if defined(CONFIG_NET_UDP)
	if (proto == IPPROTO_UDP) {
  1026ba:	83 fa 11             	cmp    $0x11,%edx
{
  1026bd:	89 e5                	mov    %esp,%ebp
  1026bf:	57                   	push   %edi
  1026c0:	56                   	push   %esi
  1026c1:	89 ce                	mov    %ecx,%esi
  1026c3:	53                   	push   %ebx
  1026c4:	89 c3                	mov    %eax,%ebx
	if (proto == IPPROTO_UDP) {
  1026c6:	75 20                	jne    1026e8 <set_appdata_values+0x2f>
		net_nbuf_set_appdata(buf, net_nbuf_udp_data(buf) +
  1026c8:	e8 a3 fd ff ff       	call   102470 <net_nbuf_tcp_data>
				     sizeof(struct net_udp_hdr));
		net_nbuf_set_appdatalen(buf, total_len -
					net_nbuf_ip_hdr_len(buf) -
  1026cd:	83 ee 08             	sub    $0x8,%esi
		net_nbuf_set_appdata(buf, net_nbuf_udp_data(buf) +
  1026d0:	89 c1                	mov    %eax,%ecx
	((struct net_nbuf *)net_buf_user_data(buf))->appdata = data;
  1026d2:	89 d8                	mov    %ebx,%eax
  1026d4:	e8 99 f5 ff ff       	call   101c72 <net_buf_user_data>
  1026d9:	83 c1 08             	add    $0x8,%ecx
  1026dc:	89 48 0c             	mov    %ecx,0xc(%eax)
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  1026df:	89 d8                	mov    %ebx,%eax
  1026e1:	e8 8c f5 ff ff       	call   101c72 <net_buf_user_data>
  1026e6:	eb 6b                	jmp    102753 <set_appdata_values+0x9a>
					sizeof(struct net_udp_hdr));
	} else
#endif /* CONFIG_NET_UDP */

#if defined(CONFIG_NET_TCP)
	if (proto == IPPROTO_TCP) {
  1026e8:	83 fa 06             	cmp    $0x6,%edx
  1026eb:	75 4e                	jne    10273b <set_appdata_values+0x82>
		net_nbuf_set_appdata(buf, net_nbuf_udp_data(buf) +
  1026ed:	e8 7e fd ff ff       	call   102470 <net_nbuf_tcp_data>
  1026f2:	89 c7                	mov    %eax,%edi
	struct net_tcp_hdr *hdr = (void *)net_nbuf_tcp_data(buf);
  1026f4:	89 d8                	mov    %ebx,%eax
  1026f6:	e8 75 fd ff ff       	call   102470 <net_nbuf_tcp_data>
	return 4 * (hdr->offset >> 4);
  1026fb:	8a 40 0c             	mov    0xc(%eax),%al
  1026fe:	c0 e8 04             	shr    $0x4,%al
  102701:	0f b6 c0             	movzbl %al,%eax
		net_nbuf_set_appdata(buf, net_nbuf_udp_data(buf) +
  102704:	8d 0c 87             	lea    (%edi,%eax,4),%ecx
	((struct net_nbuf *)net_buf_user_data(buf))->appdata = data;
  102707:	89 d8                	mov    %ebx,%eax
  102709:	e8 64 f5 ff ff       	call   101c72 <net_buf_user_data>
  10270e:	89 48 0c             	mov    %ecx,0xc(%eax)
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  102711:	89 d8                	mov    %ebx,%eax
  102713:	e8 5a f5 ff ff       	call   101c72 <net_buf_user_data>
  102718:	89 c7                	mov    %eax,%edi
				     tcp_hdr_len(buf));
		net_nbuf_set_appdatalen(buf, total_len -
					net_nbuf_ip_hdr_len(buf) -
  10271a:	0f b6 40 2a          	movzbl 0x2a(%eax),%eax
		net_nbuf_set_appdatalen(buf, total_len -
  10271e:	29 c6                	sub    %eax,%esi
	struct net_tcp_hdr *hdr = (void *)net_nbuf_tcp_data(buf);
  102720:	89 d8                	mov    %ebx,%eax
  102722:	e8 49 fd ff ff       	call   102470 <net_nbuf_tcp_data>
	return 4 * (hdr->offset >> 4);
  102727:	8a 40 0c             	mov    0xc(%eax),%al
  10272a:	c0 e8 04             	shr    $0x4,%al
  10272d:	0f b6 c0             	movzbl %al,%eax
  102730:	c1 e0 02             	shl    $0x2,%eax
					net_nbuf_ip_hdr_len(buf) -
  102733:	29 c6                	sub    %eax,%esi
  102735:	66 89 77 24          	mov    %si,0x24(%edi)
  102739:	eb 22                	jmp    10275d <set_appdata_values+0xa4>
  10273b:	e8 32 f5 ff ff       	call   101c72 <net_buf_user_data>
	return buf->frags->data;
  102740:	8b 0b                	mov    (%ebx),%ecx
					tcp_hdr_len(buf));
	} else
#endif /* CONFIG_NET_TCP */
	{
		net_nbuf_set_appdata(buf, net_nbuf_ip_data(buf) +
				     net_nbuf_ip_hdr_len(buf));
  102742:	0f b6 50 2a          	movzbl 0x2a(%eax),%edx
		net_nbuf_set_appdata(buf, net_nbuf_ip_data(buf) +
  102746:	03 51 10             	add    0x10(%ecx),%edx
	((struct net_nbuf *)net_buf_user_data(buf))->appdata = data;
  102749:	89 50 0c             	mov    %edx,0xc(%eax)
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  10274c:	89 d8                	mov    %ebx,%eax
  10274e:	e8 1f f5 ff ff       	call   101c72 <net_buf_user_data>
		net_nbuf_set_appdatalen(buf, total_len -
					net_nbuf_ip_hdr_len(buf));
  102753:	0f b6 50 2a          	movzbl 0x2a(%eax),%edx
		net_nbuf_set_appdatalen(buf, total_len -
  102757:	29 d6                	sub    %edx,%esi
  102759:	66 89 70 24          	mov    %si,0x24(%eax)
	}

	NET_ASSERT_INFO(net_nbuf_appdatalen(buf) < total_len,
			"Wrong appdatalen %u, total %zu",
			net_nbuf_appdatalen(buf), total_len);
}
  10275d:	5b                   	pop    %ebx
  10275e:	5e                   	pop    %esi
  10275f:	5f                   	pop    %edi
  102760:	5d                   	pop    %ebp
  102761:	c3                   	ret    

00102762 <packet_received>:

enum net_verdict packet_received(struct net_conn *conn,
				 struct net_buf *buf,
				 void *user_data)
{
  102762:	55                   	push   %ebp
  102763:	89 e5                	mov    %esp,%ebp
  102765:	57                   	push   %edi
  102766:	56                   	push   %esi
  102767:	53                   	push   %ebx
  102768:	53                   	push   %ebx
  102769:	be a0 94 10 00       	mov    $0x1094a0,%esi
  10276e:	8b 45 08             	mov    0x8(%ebp),%eax
  102771:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  102774:	31 ff                	xor    %edi,%edi
  102776:	89 f1                	mov    %esi,%ecx
  102778:	81 e9 a0 94 10 00    	sub    $0x1094a0,%ecx
		if (!net_context_is_used(&contexts[i])) {
  10277e:	f6 46 39 01          	testb  $0x1,0x39(%esi)
  102782:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  102785:	74 05                	je     10278c <packet_received+0x2a>
		if (contexts[i].conn_handler == conn_handler) {
  102787:	3b 46 14             	cmp    0x14(%esi),%eax
  10278a:	74 22                	je     1027ae <packet_received+0x4c>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10278c:	47                   	inc    %edi
  10278d:	83 c6 40             	add    $0x40,%esi
  102790:	83 ff 06             	cmp    $0x6,%edi
  102793:	75 e1                	jne    102776 <packet_received+0x14>
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  102795:	89 d8                	mov    %ebx,%eax
  102797:	e8 d6 f4 ff ff       	call   101c72 <net_buf_user_data>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
  10279c:	ff 70 08             	pushl  0x8(%eax)
  10279f:	e8 ea f9 ff ff       	call   10218e <net_if_get_by_iface>
  1027a4:	58                   	pop    %eax
  1027a5:	c6 05 38 00 00 00 00 	movb   $0x0,0x38
  1027ac:	0f 0b                	ud2    
  1027ae:	89 d8                	mov    %ebx,%eax
  1027b0:	e8 bd f4 ff ff       	call   101c72 <net_buf_user_data>
  1027b5:	ff 70 08             	pushl  0x8(%eax)
  1027b8:	e8 d1 f9 ff ff       	call   10218e <net_if_get_by_iface>
  1027bd:	59                   	pop    %ecx
  1027be:	88 46 38             	mov    %al,0x38(%esi)
	((struct net_nbuf *)net_buf_user_data(buf))->context = ctx;
  1027c1:	89 d8                	mov    %ebx,%eax
  1027c3:	e8 aa f4 ff ff       	call   101c72 <net_buf_user_data>
	NET_ASSERT(net_nbuf_iface(buf));

	net_context_set_iface(context, net_nbuf_iface(buf));
	net_nbuf_set_context(buf, context);

	if (context->recv_cb) {
  1027c8:	89 fa                	mov    %edi,%edx
  1027ca:	c1 e2 06             	shl    $0x6,%edx
  1027cd:	89 30                	mov    %esi,(%eax)
	}

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	return NET_DROP;
  1027cf:	b8 02 00 00 00       	mov    $0x2,%eax
	if (context->recv_cb) {
  1027d4:	83 ba b8 94 10 00 00 	cmpl   $0x0,0x1094b8(%edx)
  1027db:	74 64                	je     102841 <packet_received+0xdf>
  1027dd:	89 d8                	mov    %ebx,%eax
  1027df:	31 c9                	xor    %ecx,%ecx
  1027e1:	85 c0                	test   %eax,%eax
  1027e3:	74 0a                	je     1027ef <packet_received+0x8d>
		bytes += buf->len;
  1027e5:	0f b7 50 14          	movzwl 0x14(%eax),%edx
		buf = buf->frags;
  1027e9:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  1027eb:	01 d1                	add    %edx,%ecx
  1027ed:	eb f2                	jmp    1027e1 <packet_received+0x7f>
	if (context->flags & NET_CONTEXT_PROTO) {
  1027ef:	f6 46 39 40          	testb  $0x40,0x39(%esi)
  1027f3:	75 1d                	jne    102812 <packet_received+0xb0>
	return ((struct net_nbuf *)net_buf_user_data(buf))->family;
  1027f5:	89 d8                	mov    %ebx,%eax
  1027f7:	e8 76 f4 ff ff       	call   101c72 <net_buf_user_data>
			if (net_nbuf_family(buf) == AF_INET6) {
  1027fc:	80 78 29 0a          	cmpb   $0xa,0x29(%eax)
  102800:	8b 03                	mov    (%ebx),%eax
  102802:	75 34                	jne    102838 <packet_received+0xd6>
						   NET_IPV6_BUF(buf)->nexthdr,
  102804:	8b 40 10             	mov    0x10(%eax),%eax
				set_appdata_values(buf,
  102807:	0f b6 50 06          	movzbl 0x6(%eax),%edx
				set_appdata_values(buf,
  10280b:	89 d8                	mov    %ebx,%eax
  10280d:	e8 a7 fe ff ff       	call   1026b9 <set_appdata_values>
		context->recv_cb(context, buf, 0, user_data);
  102812:	ff 75 10             	pushl  0x10(%ebp)
  102815:	c1 e7 06             	shl    $0x6,%edi
  102818:	6a 00                	push   $0x0
  10281a:	53                   	push   %ebx
  10281b:	56                   	push   %esi
  10281c:	ff 97 b8 94 10 00    	call   *0x1094b8(%edi)
  102822:	83 c4 10             	add    $0x10,%esp
		k_sem_give(&context->recv_data_wait);
  102825:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102828:	05 c8 94 10 00       	add    $0x1094c8,%eax
  10282d:	50                   	push   %eax
  10282e:	e8 c9 4b 00 00       	call   1073fc <k_sem_give>
  102833:	5a                   	pop    %edx
		return NET_OK;
  102834:	31 c0                	xor    %eax,%eax
  102836:	eb 09                	jmp    102841 <packet_received+0xdf>
						   NET_IPV4_BUF(buf)->proto,
  102838:	8b 40 10             	mov    0x10(%eax),%eax
				set_appdata_values(buf,
  10283b:	0f b6 50 09          	movzbl 0x9(%eax),%edx
  10283f:	eb ca                	jmp    10280b <packet_received+0xa9>
}
  102841:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102844:	5b                   	pop    %ebx
  102845:	5e                   	pop    %esi
  102846:	5f                   	pop    %edi
  102847:	5d                   	pop    %ebp
  102848:	c3                   	ret    

00102849 <net_context_get>:
{
  102849:	55                   	push   %ebp
  10284a:	89 e5                	mov    %esp,%ebp
  10284c:	57                   	push   %edi
  10284d:	56                   	push   %esi
  10284e:	53                   	push   %ebx
  10284f:	83 ec 08             	sub    $0x8,%esp
		return -EPFNOSUPPORT;
  102852:	bf d2 ff ff ff       	mov    $0xffffffd2,%edi
{
  102857:	8b 45 08             	mov    0x8(%ebp),%eax
  10285a:	8b 75 10             	mov    0x10(%ebp),%esi
	if (family == AF_INET6) {
  10285d:	66 83 f8 0a          	cmp    $0xa,%ax
  102861:	0f 84 b7 01 00 00    	je     102a1e <net_context_get+0x1d5>
	if (family != AF_INET && family != AF_INET6) {
  102867:	66 83 f8 02          	cmp    $0x2,%ax
		return -EAFNOSUPPORT;
  10286b:	bf d1 ff ff ff       	mov    $0xffffffd1,%edi
	if (family != AF_INET && family != AF_INET6) {
  102870:	0f 85 a8 01 00 00    	jne    102a1e <net_context_get+0x1d5>
	if (type != SOCK_DGRAM && type != SOCK_STREAM) {
  102876:	8b 45 0c             	mov    0xc(%ebp),%eax
		return -EPROTOTYPE;
  102879:	bf d7 ff ff ff       	mov    $0xffffffd7,%edi
	if (type != SOCK_DGRAM && type != SOCK_STREAM) {
  10287e:	48                   	dec    %eax
  10287f:	83 f8 01             	cmp    $0x1,%eax
  102882:	0f 87 96 01 00 00    	ja     102a1e <net_context_get+0x1d5>
	if (ip_proto != IPPROTO_UDP && ip_proto != IPPROTO_TCP) {
  102888:	83 fe 11             	cmp    $0x11,%esi
  10288b:	74 0e                	je     10289b <net_context_get+0x52>
		return -EPROTONOSUPPORT;
  10288d:	bf d5 ff ff ff       	mov    $0xffffffd5,%edi
	if (ip_proto != IPPROTO_UDP && ip_proto != IPPROTO_TCP) {
  102892:	83 fe 06             	cmp    $0x6,%esi
  102895:	0f 85 83 01 00 00    	jne    102a1e <net_context_get+0x1d5>
	if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
  10289b:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  10289f:	75 0e                	jne    1028af <net_context_get+0x66>
		return -EOPNOTSUPP;
  1028a1:	bf d3 ff ff ff       	mov    $0xffffffd3,%edi
	if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
  1028a6:	83 fe 11             	cmp    $0x11,%esi
  1028a9:	0f 84 6f 01 00 00    	je     102a1e <net_context_get+0x1d5>
  1028af:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  1028b3:	75 0e                	jne    1028c3 <net_context_get+0x7a>
		return -EOPNOTSUPP;
  1028b5:	bf d3 ff ff ff       	mov    $0xffffffd3,%edi
	if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
  1028ba:	83 fe 06             	cmp    $0x6,%esi
  1028bd:	0f 84 5b 01 00 00    	je     102a1e <net_context_get+0x1d5>
		return -EINVAL;
  1028c3:	bf ea ff ff ff       	mov    $0xffffffea,%edi
	if (!context) {
  1028c8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1028cc:	0f 84 4c 01 00 00    	je     102a1e <net_context_get+0x1d5>
	k_sem_take(&contexts_lock, K_FOREVER);
  1028d2:	6a ff                	push   $0xffffffff
  1028d4:	68 7c 94 10 00       	push   $0x10947c
  1028d9:	e8 97 4b 00 00       	call   107475 <k_sem_take>
  1028de:	5b                   	pop    %ebx
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  1028df:	31 d2                	xor    %edx,%edx
	k_sem_take(&contexts_lock, K_FOREVER);
  1028e1:	5f                   	pop    %edi
  1028e2:	bb a0 94 10 00       	mov    $0x1094a0,%ebx
  1028e7:	89 d8                	mov    %ebx,%eax
  1028e9:	2d a0 94 10 00       	sub    $0x1094a0,%eax
		if (net_context_is_used(&contexts[i])) {
  1028ee:	f6 43 39 01          	testb  $0x1,0x39(%ebx)
  1028f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1028f5:	74 13                	je     10290a <net_context_get+0xc1>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  1028f7:	42                   	inc    %edx
  1028f8:	83 c3 40             	add    $0x40,%ebx
  1028fb:	83 fa 06             	cmp    $0x6,%edx
  1028fe:	75 e7                	jne    1028e7 <net_context_get+0x9e>
	int i, ret = -ENOENT;
  102900:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
  102905:	e9 09 01 00 00       	jmp    102a13 <net_context_get+0x1ca>
		if (ip_proto == IPPROTO_TCP) {
  10290a:	83 fe 06             	cmp    $0x6,%esi
  10290d:	74 25                	je     102934 <net_context_get+0xeb>
		contexts[i].flags = 0;
  10290f:	89 d0                	mov    %edx,%eax
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  102911:	b9 01 00 00 00       	mov    $0x1,%ecx
  102916:	c1 e0 06             	shl    $0x6,%eax
  102919:	05 a0 94 10 00       	add    $0x1094a0,%eax
  10291e:	c6 40 39 00          	movb   $0x0,0x39(%eax)
  102922:	87 0b                	xchg   %ecx,(%ebx)
	context->flags &= ~NET_CONTEXT_FAMILY;
  102924:	80 60 39 ef          	andb   $0xef,0x39(%eax)
	if (type == SOCK_STREAM) {
  102928:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  10292c:	75 2c                	jne    10295a <net_context_get+0x111>
		context->flags |= NET_CONTEXT_TYPE;
  10292e:	80 4b 39 20          	orb    $0x20,0x39(%ebx)
  102932:	eb 2a                	jmp    10295e <net_context_get+0x115>
  102934:	89 55 ec             	mov    %edx,-0x14(%ebp)
			contexts[i].tcp = net_tcp_alloc(&contexts[i]);
  102937:	53                   	push   %ebx
  102938:	e8 5b 22 00 00       	call   104b98 <net_tcp_alloc>
  10293d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102940:	59                   	pop    %ecx
  102941:	89 d1                	mov    %edx,%ecx
  102943:	c1 e1 06             	shl    $0x6,%ecx
				return -ENOBUFS;
  102946:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
			if (!contexts[i].tcp) {
  10294b:	85 c0                	test   %eax,%eax
			contexts[i].tcp = net_tcp_alloc(&contexts[i]);
  10294d:	89 81 dc 94 10 00    	mov    %eax,0x1094dc(%ecx)
			if (!contexts[i].tcp) {
  102953:	75 ba                	jne    10290f <net_context_get+0xc6>
  102955:	e9 c4 00 00 00       	jmp    102a1e <net_context_get+0x1d5>
	context->flags &= ~NET_CONTEXT_TYPE;
  10295a:	80 63 39 df          	andb   $0xdf,0x39(%ebx)
	if (ip_proto == IPPROTO_TCP) {
  10295e:	83 fe 06             	cmp    $0x6,%esi
  102961:	75 06                	jne    102969 <net_context_get+0x120>
		context->flags |= NET_CONTEXT_PROTO;
  102963:	80 4b 39 40          	orb    $0x40,0x39(%ebx)
  102967:	eb 04                	jmp    10296d <net_context_get+0x124>
	context->flags &= ~NET_CONTEXT_PROTO;
  102969:	80 63 39 bf          	andb   $0xbf,0x39(%ebx)
		contexts[i].flags |= NET_CONTEXT_IN_USE;
  10296d:	c1 e2 06             	shl    $0x6,%edx
		memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
  102970:	8b 45 f0             	mov    -0x10(%ebp),%eax
		contexts[i].flags |= NET_CONTEXT_IN_USE;
  102973:	81 c2 a0 94 10 00    	add    $0x1094a0,%edx
		memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
  102979:	05 ac 94 10 00       	add    $0x1094ac,%eax
		contexts[i].flags |= NET_CONTEXT_IN_USE;
  10297e:	80 4a 39 01          	orb    $0x1,0x39(%edx)
		contexts[i].iface = 0;
  102982:	c6 42 38 00          	movb   $0x0,0x38(%edx)
		memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
  102986:	6a 08                	push   $0x8
  102988:	6a 00                	push   $0x0
  10298a:	50                   	push   %eax
  10298b:	e8 48 eb ff ff       	call   1014d8 <memset>
		memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
  102990:	8b 45 f0             	mov    -0x10(%ebp),%eax
		memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
  102993:	83 c4 0c             	add    $0xc,%esp
		memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
  102996:	8d b8 a4 94 10 00    	lea    0x1094a4(%eax),%edi
  10299c:	6a 08                	push   $0x8
  10299e:	6a 00                	push   $0x0
  1029a0:	57                   	push   %edi
  1029a1:	e8 32 eb ff ff       	call   1014d8 <memset>
	if (!net_sin(addr)->sin_port) {
  1029a6:	66 8b 77 02          	mov    0x2(%edi),%si
		memset(&contexts[i].local, 0, sizeof(struct sockaddr_ptr));
  1029aa:	83 c4 0c             	add    $0xc,%esp
	if (!net_sin(addr)->sin_port) {
  1029ad:	66 85 f6             	test   %si,%si
  1029b0:	75 2f                	jne    1029e1 <net_context_get+0x198>
			local_port = sys_rand32_get() | 0x8000;
  1029b2:	e8 ee df ff ff       	call   1009a5 <sys_rand32_get>
		} while (check_used_port(
  1029b7:	89 f9                	mov    %edi,%ecx
			local_port = sys_rand32_get() | 0x8000;
  1029b9:	89 c6                	mov    %eax,%esi
	if (context->flags & NET_CONTEXT_PROTO) {
  1029bb:	8a 43 39             	mov    0x39(%ebx),%al
  1029be:	66 81 ce 00 80       	or     $0x8000,%si
  1029c3:	83 e0 40             	and    $0x40,%eax
  1029c6:	66 c1 c6 08          	rol    $0x8,%si
		return IPPROTO_TCP;
  1029ca:	3c 01                	cmp    $0x1,%al
  1029cc:	19 c0                	sbb    %eax,%eax
  1029ce:	83 e0 0b             	and    $0xb,%eax
  1029d1:	83 c0 06             	add    $0x6,%eax
		} while (check_used_port(
  1029d4:	0f b7 d6             	movzwl %si,%edx
  1029d7:	e8 3f f9 ff ff       	call   10231b <check_used_port>
				 htons(local_port), addr) == -EEXIST);
  1029dc:	83 f8 ef             	cmp    $0xffffffef,%eax
  1029df:	eb cf                	jmp    1029b0 <net_context_get+0x167>
			if (!addr->sin_port) {
  1029e1:	66 85 f6             	test   %si,%si
			addr->sin_port = find_available_port(&contexts[i],
  1029e4:	66 89 77 02          	mov    %si,0x2(%edi)
				return -EADDRINUSE;
  1029e8:	bf d0 ff ff ff       	mov    $0xffffffd0,%edi
			if (!addr->sin_port) {
  1029ed:	74 2f                	je     102a1e <net_context_get+0x1d5>
		k_sem_init(&contexts[i].recv_data_wait, 0, UINT_MAX);
  1029ef:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1029f2:	6a ff                	push   $0xffffffff
  1029f4:	81 c6 c8 94 10 00    	add    $0x1094c8,%esi
  1029fa:	6a 00                	push   $0x0
  1029fc:	56                   	push   %esi
  1029fd:	e8 e1 49 00 00       	call   1073e3 <k_sem_init>
  102a02:	83 c4 0c             	add    $0xc,%esp
		ret = 0;
  102a05:	31 ff                	xor    %edi,%edi
		k_sem_give(&contexts[i].recv_data_wait);
  102a07:	56                   	push   %esi
  102a08:	e8 ef 49 00 00       	call   1073fc <k_sem_give>
		*context = &contexts[i];
  102a0d:	8b 45 14             	mov    0x14(%ebp),%eax
		k_sem_give(&contexts[i].recv_data_wait);
  102a10:	5a                   	pop    %edx
		*context = &contexts[i];
  102a11:	89 18                	mov    %ebx,(%eax)
	k_sem_give(&contexts_lock);
  102a13:	68 7c 94 10 00       	push   $0x10947c
  102a18:	e8 df 49 00 00       	call   1073fc <k_sem_give>
  102a1d:	58                   	pop    %eax
}
  102a1e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102a21:	89 f8                	mov    %edi,%eax
  102a23:	5b                   	pop    %ebx
  102a24:	5e                   	pop    %esi
  102a25:	5f                   	pop    %edi
  102a26:	5d                   	pop    %ebp
  102a27:	c3                   	ret    

00102a28 <net_context_ref>:
{
  102a28:	55                   	push   %ebp
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  102a29:	b8 01 00 00 00       	mov    $0x1,%eax
  102a2e:	89 e5                	mov    %esp,%ebp
  102a30:	8b 55 08             	mov    0x8(%ebp),%edx
  102a33:	f0 0f c1 02          	lock xadd %eax,(%edx)
	return old_rc + 1;
  102a37:	40                   	inc    %eax
}
  102a38:	5d                   	pop    %ebp
  102a39:	c3                   	ret    

00102a3a <net_context_unref>:
{
  102a3a:	55                   	push   %ebp
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  102a3b:	83 c8 ff             	or     $0xffffffff,%eax
  102a3e:	89 e5                	mov    %esp,%ebp
  102a40:	53                   	push   %ebx
  102a41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  102a44:	f0 0f c1 03          	lock xadd %eax,(%ebx)
	if (old_rc != 1) {
  102a48:	83 f8 01             	cmp    $0x1,%eax
  102a4b:	74 03                	je     102a50 <net_context_unref+0x16>
		return old_rc - 1;
  102a4d:	48                   	dec    %eax
  102a4e:	eb 3b                	jmp    102a8b <net_context_unref+0x51>
	k_sem_take(&contexts_lock, K_FOREVER);
  102a50:	6a ff                	push   $0xffffffff
  102a52:	68 7c 94 10 00       	push   $0x10947c
  102a57:	e8 19 4a 00 00       	call   107475 <k_sem_take>
  102a5c:	58                   	pop    %eax
	if (context->tcp) {
  102a5d:	8b 43 3c             	mov    0x3c(%ebx),%eax
	k_sem_take(&contexts_lock, K_FOREVER);
  102a60:	5a                   	pop    %edx
	if (context->tcp) {
  102a61:	85 c0                	test   %eax,%eax
  102a63:	74 07                	je     102a6c <net_context_unref+0x32>
		net_tcp_release(context->tcp);
  102a65:	50                   	push   %eax
  102a66:	e8 1a 22 00 00       	call   104c85 <net_tcp_release>
  102a6b:	59                   	pop    %ecx
	if (context->conn_handler) {
  102a6c:	8b 43 14             	mov    0x14(%ebx),%eax
  102a6f:	85 c0                	test   %eax,%eax
  102a71:	74 07                	je     102a7a <net_context_unref+0x40>
		net_conn_unregister(context->conn_handler);
  102a73:	50                   	push   %eax
  102a74:	e8 f1 28 00 00       	call   10536a <net_conn_unregister>
  102a79:	5a                   	pop    %edx
	context->flags &= ~NET_CONTEXT_IN_USE;
  102a7a:	80 63 39 fe          	andb   $0xfe,0x39(%ebx)
	k_sem_give(&contexts_lock);
  102a7e:	68 7c 94 10 00       	push   $0x10947c
  102a83:	e8 74 49 00 00       	call   1073fc <k_sem_give>
  102a88:	58                   	pop    %eax
  102a89:	31 c0                	xor    %eax,%eax
}
  102a8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102a8e:	c9                   	leave  
  102a8f:	c3                   	ret    

00102a90 <tcp_synack_received>:
NET_CONN_CB(tcp_synack_received)
  102a90:	55                   	push   %ebp
  102a91:	89 e5                	mov    %esp,%ebp
  102a93:	57                   	push   %edi
  102a94:	56                   	push   %esi
  102a95:	53                   	push   %ebx
  102a96:	83 ec 10             	sub    $0x10,%esp
  102a99:	8b 5d 10             	mov    0x10(%ebp),%ebx
  102a9c:	8b 75 0c             	mov    0xc(%ebp),%esi
  102a9f:	53                   	push   %ebx
  102aa0:	e8 83 ff ff ff       	call   102a28 <net_context_ref>
 *
 * @param tcp TCP context
 */
static inline enum net_tcp_state net_tcp_get_state(const struct net_tcp *tcp)
{
	return (enum net_tcp_state)tcp->state;
  102aa5:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102aa8:	59                   	pop    %ecx
  102aa9:	8b 40 7c             	mov    0x7c(%eax),%eax
  102aac:	c1 e8 0d             	shr    $0xd,%eax
  102aaf:	83 e0 0f             	and    $0xf,%eax
	switch (net_tcp_get_state(context->tcp)) {
  102ab2:	3c 02                	cmp    $0x2,%al
  102ab4:	0f 85 4d 01 00 00    	jne    102c07 <tcp_synack_received+0x177>
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  102aba:	89 f0                	mov    %esi,%eax
  102abc:	e8 b1 f1 ff ff       	call   101c72 <net_buf_user_data>
	context->iface = net_if_get_by_iface(iface);
  102ac1:	ff 70 08             	pushl  0x8(%eax)
  102ac4:	e8 c5 f6 ff ff       	call   10218e <net_if_get_by_iface>
  102ac9:	5a                   	pop    %edx
  102aca:	88 43 38             	mov    %al,0x38(%ebx)
	((struct net_nbuf *)net_buf_user_data(buf))->context = ctx;
  102acd:	89 f0                	mov    %esi,%eax
  102acf:	e8 9e f1 ff ff       	call   101c72 <net_buf_user_data>
  102ad4:	89 18                	mov    %ebx,(%eax)
	if (NET_TCP_FLAGS(buf) & NET_TCP_RST) {
  102ad6:	89 f0                	mov    %esi,%eax
  102ad8:	e8 93 f9 ff ff       	call   102470 <net_nbuf_tcp_data>
  102add:	8a 50 0d             	mov    0xd(%eax),%dl
  102ae0:	f6 c2 04             	test   $0x4,%dl
  102ae3:	74 15                	je     102afa <tcp_synack_received+0x6a>
		if (context->connect_cb) {
  102ae5:	8b 43 20             	mov    0x20(%ebx),%eax
  102ae8:	85 c0                	test   %eax,%eax
  102aea:	0f 84 17 01 00 00    	je     102c07 <tcp_synack_received+0x177>
			context->connect_cb(context, -ECONNREFUSED,
  102af0:	ff 73 24             	pushl  0x24(%ebx)
  102af3:	6a c3                	push   $0xffffffc3
  102af5:	e9 07 01 00 00       	jmp    102c01 <tcp_synack_received+0x171>
	if (NET_TCP_FLAGS(buf) & NET_TCP_SYN) {
  102afa:	80 e2 02             	and    $0x2,%dl
  102afd:	74 16                	je     102b15 <tcp_synack_received+0x85>
			sys_get_be32(NET_TCP_BUF(buf)->seq) + 1;
  102aff:	83 c0 04             	add    $0x4,%eax
		context->tcp->send_ack =
  102b02:	8b 7b 3c             	mov    0x3c(%ebx),%edi
			sys_get_be32(NET_TCP_BUF(buf)->seq) + 1;
  102b05:	e8 e5 f7 ff ff       	call   1022ef <sys_get_be32>
  102b0a:	40                   	inc    %eax
  102b0b:	89 47 74             	mov    %eax,0x74(%edi)
		context->tcp->recv_max_ack = context->tcp->send_seq + 1;
  102b0e:	8b 47 70             	mov    0x70(%edi),%eax
  102b11:	40                   	inc    %eax
  102b12:	89 47 6c             	mov    %eax,0x6c(%edi)
	if (NET_TCP_FLAGS(buf) == (NET_TCP_SYN | NET_TCP_ACK)) {
  102b15:	89 f0                	mov    %esi,%eax
  102b17:	e8 54 f9 ff ff       	call   102470 <net_nbuf_tcp_data>
  102b1c:	8a 40 0d             	mov    0xd(%eax),%al
  102b1f:	83 e0 3f             	and    $0x3f,%eax
  102b22:	3c 12                	cmp    $0x12,%al
  102b24:	0f 85 dd 00 00 00    	jne    102c07 <tcp_synack_received+0x177>
	return ((struct net_nbuf *)net_buf_user_data(buf))->family;
  102b2a:	89 f0                	mov    %esi,%eax
  102b2c:	e8 41 f1 ff ff       	call   101c72 <net_buf_user_data>
		if (net_nbuf_family(buf) == AF_INET) {
  102b31:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  102b35:	0f 85 cc 00 00 00    	jne    102c07 <tcp_synack_received+0x177>
			r4addr.sin_port = NET_TCP_BUF(buf)->src_port;
  102b3b:	89 f0                	mov    %esi,%eax
			r4addr.sin_family = AF_INET;
  102b3d:	66 c7 45 e4 02 00    	movw   $0x2,-0x1c(%ebp)
			r4addr.sin_port = NET_TCP_BUF(buf)->src_port;
  102b43:	e8 28 f9 ff ff       	call   102470 <net_nbuf_tcp_data>
  102b48:	66 8b 00             	mov    (%eax),%ax
			l4addr.sin_family = AF_INET;
  102b4b:	66 c7 45 ec 02 00    	movw   $0x2,-0x14(%ebp)
			r4addr.sin_port = NET_TCP_BUF(buf)->src_port;
  102b51:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	return buf->frags->data;
  102b55:	8b 06                	mov    (%esi),%eax
  102b57:	8b 78 10             	mov    0x10(%eax),%edi
			net_ipaddr_copy(&r4addr.sin_addr,
  102b5a:	8b 47 0c             	mov    0xc(%edi),%eax
  102b5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			l4addr.sin_port = NET_TCP_BUF(buf)->dst_port;
  102b60:	89 f0                	mov    %esi,%eax
  102b62:	e8 09 f9 ff ff       	call   102470 <net_nbuf_tcp_data>
  102b67:	66 8b 40 02          	mov    0x2(%eax),%ax
  102b6b:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
			net_ipaddr_copy(&l4addr.sin_addr,
  102b6f:	8b 47 10             	mov    0x10(%edi),%eax
	return net_conn_unregister(handle);
  102b72:	ff 73 14             	pushl  0x14(%ebx)
  102b75:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102b78:	e8 ed 27 00 00       	call   10536a <net_conn_unregister>
				       ntohs(NET_TCP_BUF(buf)->dst_port),
  102b7d:	89 f0                	mov    %esi,%eax
  102b7f:	5f                   	pop    %edi
  102b80:	e8 eb f8 ff ff       	call   102470 <net_nbuf_tcp_data>
		ret = net_tcp_register(raddr,
  102b85:	8d 4b 14             	lea    0x14(%ebx),%ecx
	return net_conn_register(IPPROTO_TCP, remote_addr, local_addr,
  102b88:	8d 75 e4             	lea    -0x1c(%ebp),%esi
				       ntohs(NET_TCP_BUF(buf)->dst_port),
  102b8b:	66 8b 50 02          	mov    0x2(%eax),%dx
				       ntohs(NET_TCP_BUF(buf)->src_port),
  102b8f:	66 8b 00             	mov    (%eax),%ax
				       ntohs(NET_TCP_BUF(buf)->dst_port),
  102b92:	86 f2                	xchg   %dh,%dl
				       ntohs(NET_TCP_BUF(buf)->src_port),
  102b94:	86 e0                	xchg   %ah,%al
		ret = net_tcp_register(raddr,
  102b96:	0f b7 d2             	movzwl %dx,%edx
  102b99:	0f b7 c0             	movzwl %ax,%eax
  102b9c:	51                   	push   %ecx
  102b9d:	53                   	push   %ebx
  102b9e:	68 1b 2c 10 00       	push   $0x102c1b
  102ba3:	52                   	push   %edx
  102ba4:	50                   	push   %eax
  102ba5:	8d 45 ec             	lea    -0x14(%ebp),%eax
  102ba8:	50                   	push   %eax
  102ba9:	56                   	push   %esi
  102baa:	6a 06                	push   $0x6
  102bac:	e8 e9 27 00 00       	call   10539a <net_conn_register>
  102bb1:	83 c4 20             	add    $0x20,%esp
		if (ret < 0) {
  102bb4:	85 c0                	test   %eax,%eax
  102bb6:	79 0c                	jns    102bc4 <tcp_synack_received+0x134>
			send_reset(context, raddr);
  102bb8:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102bbb:	89 f2                	mov    %esi,%edx
  102bbd:	e8 dd f7 ff ff       	call   10239f <send_reset.isra.11>
  102bc2:	eb 43                	jmp    102c07 <tcp_synack_received+0x177>
		net_tcp_change_state(context->tcp, NET_TCP_ESTABLISHED);
  102bc4:	6a 04                	push   $0x4
  102bc6:	ff 73 3c             	pushl  0x3c(%ebx)
  102bc9:	e8 54 23 00 00       	call   104f22 <net_tcp_change_state>
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
  102bce:	8a 43 39             	mov    0x39(%ebx),%al
  102bd1:	83 e0 f9             	and    $0xfffffff9,%eax
  102bd4:	5a                   	pop    %edx
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
  102bd5:	83 c8 04             	or     $0x4,%eax
  102bd8:	59                   	pop    %ecx
		send_ack(context, raddr);
  102bd9:	89 f2                	mov    %esi,%edx
  102bdb:	88 43 39             	mov    %al,0x39(%ebx)
  102bde:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102be1:	e8 41 f8 ff ff       	call   102427 <send_ack.isra.13>
		k_sem_give(&context->tcp->connect_wait);
  102be6:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102be9:	05 84 00 00 00       	add    $0x84,%eax
  102bee:	50                   	push   %eax
  102bef:	e8 08 48 00 00       	call   1073fc <k_sem_give>
		if (context->connect_cb) {
  102bf4:	8b 43 20             	mov    0x20(%ebx),%eax
		k_sem_give(&context->tcp->connect_wait);
  102bf7:	5e                   	pop    %esi
		if (context->connect_cb) {
  102bf8:	85 c0                	test   %eax,%eax
  102bfa:	74 0b                	je     102c07 <tcp_synack_received+0x177>
			context->connect_cb(context, 0, context->user_data);
  102bfc:	ff 73 24             	pushl  0x24(%ebx)
  102bff:	6a 00                	push   $0x0
  102c01:	53                   	push   %ebx
  102c02:	ff d0                	call   *%eax
  102c04:	83 c4 0c             	add    $0xc,%esp
NET_CONN_CB(tcp_synack_received)
  102c07:	53                   	push   %ebx
  102c08:	e8 2d fe ff ff       	call   102a3a <net_context_unref>
  102c0d:	58                   	pop    %eax
  102c0e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102c11:	b8 02 00 00 00       	mov    $0x2,%eax
  102c16:	5b                   	pop    %ebx
  102c17:	5e                   	pop    %esi
  102c18:	5f                   	pop    %edi
  102c19:	5d                   	pop    %ebp
  102c1a:	c3                   	ret    

00102c1b <tcp_established>:
NET_CONN_CB(tcp_established)
  102c1b:	55                   	push   %ebp
  102c1c:	89 e5                	mov    %esp,%ebp
  102c1e:	57                   	push   %edi
  102c1f:	56                   	push   %esi
  102c20:	53                   	push   %ebx
  102c21:	8b 5d 10             	mov    0x10(%ebp),%ebx
  102c24:	8b 75 0c             	mov    0xc(%ebp),%esi
  102c27:	53                   	push   %ebx
  102c28:	e8 fb fd ff ff       	call   102a28 <net_context_ref>
	return (enum net_tcp_state)tcp->state;
  102c2d:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102c30:	59                   	pop    %ecx
  102c31:	8b 40 7c             	mov    0x7c(%eax),%eax
  102c34:	c1 e8 0d             	shr    $0xd,%eax
  102c37:	83 e0 0f             	and    $0xf,%eax
	if (net_tcp_get_state(context->tcp) < NET_TCP_ESTABLISHED) {
  102c3a:	3c 03                	cmp    $0x3,%al
  102c3c:	77 0a                	ja     102c48 <tcp_established+0x2d>
		return NET_DROP;
  102c3e:	be 02 00 00 00       	mov    $0x2,%esi
  102c43:	e9 d0 00 00 00       	jmp    102d18 <tcp_established+0xfd>
	tcp_flags = NET_TCP_FLAGS(buf);
  102c48:	89 f0                	mov    %esi,%eax
  102c4a:	e8 21 f8 ff ff       	call   102470 <net_nbuf_tcp_data>
  102c4f:	0f b6 78 0d          	movzbl 0xd(%eax),%edi
	if (tcp_flags & NET_TCP_ACK) {
  102c53:	f7 c7 10 00 00 00    	test   $0x10,%edi
  102c59:	74 11                	je     102c6c <tcp_established+0x51>
				     sys_get_be32(NET_TCP_BUF(buf)->ack));
  102c5b:	83 c0 08             	add    $0x8,%eax
		net_tcp_ack_received(context,
  102c5e:	e8 8c f6 ff ff       	call   1022ef <sys_get_be32>
  102c63:	50                   	push   %eax
  102c64:	53                   	push   %ebx
  102c65:	e8 3b 25 00 00       	call   1051a5 <net_tcp_ack_received>
  102c6a:	58                   	pop    %eax
  102c6b:	5a                   	pop    %edx
	if (sys_get_be32(NET_TCP_BUF(buf)->seq) - context->tcp->send_ack) {
  102c6c:	89 f0                	mov    %esi,%eax
  102c6e:	e8 fd f7 ff ff       	call   102470 <net_nbuf_tcp_data>
  102c73:	83 c0 04             	add    $0x4,%eax
  102c76:	e8 74 f6 ff ff       	call   1022ef <sys_get_be32>
  102c7b:	8b 53 3c             	mov    0x3c(%ebx),%edx
  102c7e:	3b 42 74             	cmp    0x74(%edx),%eax
  102c81:	75 bb                	jne    102c3e <tcp_established+0x23>
  102c83:	89 f0                	mov    %esi,%eax
  102c85:	31 c9                	xor    %ecx,%ecx
	while (buf) {
  102c87:	85 c0                	test   %eax,%eax
  102c89:	74 0a                	je     102c95 <tcp_established+0x7a>
		bytes += buf->len;
  102c8b:	0f b7 50 14          	movzwl 0x14(%eax),%edx
		buf = buf->frags;
  102c8f:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  102c91:	01 d1                	add    %edx,%ecx
  102c93:	eb f2                	jmp    102c87 <tcp_established+0x6c>
	set_appdata_values(buf, IPPROTO_TCP, net_buf_frags_len(buf));
  102c95:	ba 06 00 00 00       	mov    $0x6,%edx
  102c9a:	89 f0                	mov    %esi,%eax
  102c9c:	e8 18 fa ff ff       	call   1026b9 <set_appdata_values>
	return ((struct net_nbuf *)net_buf_user_data(buf))->appdatalen;
  102ca1:	89 f0                	mov    %esi,%eax
  102ca3:	e8 ca ef ff ff       	call   101c72 <net_buf_user_data>
	context->tcp->send_ack += net_nbuf_appdatalen(buf);
  102ca8:	8b 53 3c             	mov    0x3c(%ebx),%edx
  102cab:	0f b7 40 24          	movzwl 0x24(%eax),%eax
  102caf:	01 42 74             	add    %eax,0x74(%edx)
	ret = packet_received(conn, buf, context->tcp->recv_user_data);
  102cb2:	ff 72 04             	pushl  0x4(%edx)
  102cb5:	56                   	push   %esi
  102cb6:	ff 75 08             	pushl  0x8(%ebp)
  102cb9:	e8 a4 fa ff ff       	call   102762 <packet_received>
  102cbe:	83 c4 0c             	add    $0xc,%esp
  102cc1:	89 c6                	mov    %eax,%esi
	if (tcp_flags & NET_TCP_FIN) {
  102cc3:	83 e7 01             	and    $0x1,%edi
  102cc6:	74 2b                	je     102cf3 <tcp_established+0xd8>
		context->tcp->fin_rcvd = 1;
  102cc8:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102ccb:	80 48 7e 08          	orb    $0x8,0x7e(%eax)
		net_tcp_change_state(context->tcp, NET_TCP_CLOSE_WAIT);
  102ccf:	6a 05                	push   $0x5
  102cd1:	50                   	push   %eax
  102cd2:	e8 4b 22 00 00       	call   104f22 <net_tcp_change_state>
		context->tcp->send_ack += 1;
  102cd7:	8b 43 3c             	mov    0x3c(%ebx),%eax
		if (context->recv_cb) {
  102cda:	8b 53 18             	mov    0x18(%ebx),%edx
		net_tcp_change_state(context->tcp, NET_TCP_CLOSE_WAIT);
  102cdd:	59                   	pop    %ecx
  102cde:	5f                   	pop    %edi
		context->tcp->send_ack += 1;
  102cdf:	ff 40 74             	incl   0x74(%eax)
		if (context->recv_cb) {
  102ce2:	85 d2                	test   %edx,%edx
  102ce4:	74 0d                	je     102cf3 <tcp_established+0xd8>
			context->recv_cb(context, NULL, 0,
  102ce6:	ff 70 04             	pushl  0x4(%eax)
  102ce9:	6a 00                	push   $0x0
  102ceb:	6a 00                	push   $0x0
  102ced:	53                   	push   %ebx
  102cee:	ff d2                	call   *%edx
  102cf0:	83 c4 10             	add    $0x10,%esp
	send_ack(context, &conn->remote_addr);
  102cf3:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102cf6:	8b 55 08             	mov    0x8(%ebp),%edx
  102cf9:	e8 29 f7 ff ff       	call   102427 <send_ack.isra.13>
	if (sys_slist_is_empty(&context->tcp->sent_list)
  102cfe:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102d01:	83 78 64 00          	cmpl   $0x0,0x64(%eax)
  102d05:	75 11                	jne    102d18 <tcp_established+0xfd>
	    && context->tcp->fin_sent) {
  102d07:	8a 40 7e             	mov    0x7e(%eax),%al
  102d0a:	83 e0 0c             	and    $0xc,%eax
  102d0d:	3c 0c                	cmp    $0xc,%al
  102d0f:	75 07                	jne    102d18 <tcp_established+0xfd>
		net_context_unref(context);
  102d11:	53                   	push   %ebx
  102d12:	e8 23 fd ff ff       	call   102a3a <net_context_unref>
  102d17:	5a                   	pop    %edx
NET_CONN_CB(tcp_established)
  102d18:	53                   	push   %ebx
  102d19:	e8 1c fd ff ff       	call   102a3a <net_context_unref>
  102d1e:	58                   	pop    %eax
  102d1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102d22:	89 f0                	mov    %esi,%eax
  102d24:	5b                   	pop    %ebx
  102d25:	5e                   	pop    %esi
  102d26:	5f                   	pop    %edi
  102d27:	5d                   	pop    %ebp
  102d28:	c3                   	ret    

00102d29 <net_context_put>:
{
  102d29:	55                   	push   %ebp
  102d2a:	89 e5                	mov    %esp,%ebp
  102d2c:	53                   	push   %ebx
  102d2d:	51                   	push   %ecx
  102d2e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!PART_OF_ARRAY(contexts, context)) {
  102d31:	85 db                	test   %ebx,%ebx
  102d33:	0f 94 c2             	sete   %dl
  102d36:	81 fb a0 94 10 00    	cmp    $0x1094a0,%ebx
  102d3c:	0f 92 c0             	setb   %al
  102d3f:	08 c2                	or     %al,%dl
  102d41:	75 44                	jne    102d87 <net_context_put+0x5e>
  102d43:	81 fb 20 96 10 00    	cmp    $0x109620,%ebx
  102d49:	73 3c                	jae    102d87 <net_context_put+0x5e>
  102d4b:	8a 43 39             	mov    0x39(%ebx),%al
	context->connect_cb = NULL;
  102d4e:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
	context->recv_cb = NULL;
  102d55:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	context->send_cb = NULL;
  102d5c:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	if (context->flags & NET_CONTEXT_PROTO) {
  102d63:	a8 40                	test   $0x40,%al
  102d65:	74 15                	je     102d7c <net_context_put+0x53>
	return (context->flags >> NET_CONTEXT_STATE_SHIFT) &
  102d67:	d0 e8                	shr    %al
		if ((net_context_get_state(context) == NET_CONTEXT_CONNECTED ||
  102d69:	83 e0 03             	and    $0x3,%eax
  102d6c:	83 e8 02             	sub    $0x2,%eax
  102d6f:	3c 01                	cmp    $0x1,%al
  102d71:	77 09                	ja     102d7c <net_context_put+0x53>
		    && !context->tcp->fin_rcvd) {
  102d73:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102d76:	f6 40 7e 08          	testb  $0x8,0x7e(%eax)
  102d7a:	74 12                	je     102d8e <net_context_put+0x65>
	net_context_unref(context);
  102d7c:	53                   	push   %ebx
  102d7d:	e8 b8 fc ff ff       	call   102a3a <net_context_unref>
		net_nbuf_unref(buf);
  102d82:	58                   	pop    %eax
			return 0;
  102d83:	31 c0                	xor    %eax,%eax
  102d85:	eb 4e                	jmp    102dd5 <net_context_put+0xac>
		return -EINVAL;
  102d87:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  102d8c:	eb 47                	jmp    102dd5 <net_context_put+0xac>
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
  102d8e:	8d 55 f8             	lea    -0x8(%ebp),%edx
	struct net_buf *buf = NULL;
  102d91:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
  102d98:	52                   	push   %edx
				      NULL, &ctx->remote, &buf);
  102d99:	8d 53 0c             	lea    0xc(%ebx),%edx
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
  102d9c:	52                   	push   %edx
  102d9d:	6a 00                	push   $0x0
  102d9f:	6a 00                	push   $0x0
  102da1:	6a 00                	push   $0x0
  102da3:	6a 01                	push   $0x1
  102da5:	50                   	push   %eax
  102da6:	e8 e8 21 00 00       	call   104f93 <net_tcp_prepare_segment>
  102dab:	83 c4 1c             	add    $0x1c,%esp
	if (ret || !buf) {
  102dae:	85 c0                	test   %eax,%eax
  102db0:	75 d1                	jne    102d83 <net_context_put+0x5a>
  102db2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102db5:	85 c0                	test   %eax,%eax
  102db7:	74 ca                	je     102d83 <net_context_put+0x5a>
	ctx->tcp->fin_queued = 1;
  102db9:	8b 53 3c             	mov    0x3c(%ebx),%edx
  102dbc:	80 4a 7e 02          	orb    $0x2,0x7e(%edx)
	ret = net_tcp_send_buf(buf);
  102dc0:	50                   	push   %eax
  102dc1:	e8 42 20 00 00       	call   104e08 <net_tcp_send_buf>
  102dc6:	5a                   	pop    %edx
	if (ret < 0) {
  102dc7:	85 c0                	test   %eax,%eax
  102dc9:	79 b8                	jns    102d83 <net_context_put+0x5a>
		net_nbuf_unref(buf);
  102dcb:	ff 75 f8             	pushl  -0x8(%ebp)
  102dce:	e8 89 05 00 00       	call   10335c <net_nbuf_unref>
  102dd3:	eb ad                	jmp    102d82 <net_context_put+0x59>
}
  102dd5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102dd8:	c9                   	leave  
  102dd9:	c3                   	ret    

00102dda <net_context_bind>:
{
  102dda:	55                   	push   %ebp
  102ddb:	89 e5                	mov    %esp,%ebp
  102ddd:	57                   	push   %edi
  102dde:	56                   	push   %esi
  102ddf:	53                   	push   %ebx
  102de0:	50                   	push   %eax
	return -EINVAL;
  102de1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
  102de6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  102de9:	8b 75 08             	mov    0x8(%ebp),%esi
	if (addr->family == AF_INET) {
  102dec:	66 83 3b 02          	cmpw   $0x2,(%ebx)
  102df0:	75 7c                	jne    102e6e <net_context_bind+0x94>
		if (addrlen < sizeof(struct sockaddr_in)) {
  102df2:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
  102df6:	76 76                	jbe    102e6e <net_context_bind+0x94>
		if (addr4->sin_addr.s_addr[0] == INADDR_ANY) {
  102df8:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  102dfc:	75 11                	jne    102e0f <net_context_bind+0x35>
			iface = net_if_get_default();
  102dfe:	e8 82 f1 ff ff       	call   101f85 <net_if_get_default>
  102e03:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
  102e06:	e8 e1 1b 00 00       	call   1049ec <net_ipv4_unspecified_address>
  102e0b:	89 c7                	mov    %eax,%edi
  102e0d:	eb 1d                	jmp    102e2c <net_context_bind+0x52>
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
  102e0f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  102e12:	50                   	push   %eax
  102e13:	8d 43 04             	lea    0x4(%ebx),%eax
  102e16:	50                   	push   %eax
  102e17:	e8 b7 f1 ff ff       	call   101fd3 <net_if_ipv4_addr_lookup>
  102e1c:	59                   	pop    %ecx
  102e1d:	5f                   	pop    %edi
  102e1e:	89 c7                	mov    %eax,%edi
				return -ENOENT;
  102e20:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
			if (!ifaddr) {
  102e25:	85 ff                	test   %edi,%edi
  102e27:	74 45                	je     102e6e <net_context_bind+0x94>
			ptr = &ifaddr->address.in_addr;
  102e29:	83 c7 08             	add    $0x8,%edi
		if (!iface) {
  102e2c:	8b 55 f0             	mov    -0x10(%ebp),%edx
			return -EADDRNOTAVAIL;
  102e2f:	b8 cf ff ff ff       	mov    $0xffffffcf,%eax
		if (!iface) {
  102e34:	85 d2                	test   %edx,%edx
  102e36:	74 36                	je     102e6e <net_context_bind+0x94>
	context->iface = net_if_get_by_iface(iface);
  102e38:	52                   	push   %edx
  102e39:	e8 50 f3 ff ff       	call   10218e <net_if_get_by_iface>
  102e3e:	5a                   	pop    %edx
  102e3f:	88 46 38             	mov    %al,0x38(%esi)
		if (addr4->sin_port) {
  102e42:	0f b7 53 02          	movzwl 0x2(%ebx),%edx
		return 0;
  102e46:	31 c0                	xor    %eax,%eax
		net_sin_ptr(&context->local)->sin_family = AF_INET;
  102e48:	66 c7 46 04 02 00    	movw   $0x2,0x4(%esi)
		if (addr4->sin_port) {
  102e4e:	66 85 d2             	test   %dx,%dx
		net_sin_ptr(&context->local)->sin_addr = ptr;
  102e51:	89 7e 08             	mov    %edi,0x8(%esi)
		if (addr4->sin_port) {
  102e54:	74 18                	je     102e6e <net_context_bind+0x94>
			ret = check_used_port(AF_INET, addr4->sin_port,
  102e56:	89 d9                	mov    %ebx,%ecx
  102e58:	b8 02 00 00 00       	mov    $0x2,%eax
  102e5d:	e8 b9 f4 ff ff       	call   10231b <check_used_port>
			if (!ret) {
  102e62:	85 c0                	test   %eax,%eax
  102e64:	75 08                	jne    102e6e <net_context_bind+0x94>
				net_sin_ptr(&context->local)->sin_port =
  102e66:	66 8b 53 02          	mov    0x2(%ebx),%dx
  102e6a:	66 89 56 06          	mov    %dx,0x6(%esi)
}
  102e6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102e71:	5b                   	pop    %ebx
  102e72:	5e                   	pop    %esi
  102e73:	5f                   	pop    %edi
  102e74:	5d                   	pop    %ebp
  102e75:	c3                   	ret    

00102e76 <net_context_connect>:
{
  102e76:	55                   	push   %ebp
		return -ENOENT;
  102e77:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
{
  102e7c:	89 e5                	mov    %esp,%ebp
  102e7e:	57                   	push   %edi
  102e7f:	56                   	push   %esi
  102e80:	53                   	push   %ebx
  102e81:	83 ec 08             	sub    $0x8,%esp
  102e84:	8b 5d 08             	mov    0x8(%ebp),%ebx
  102e87:	8b 75 0c             	mov    0xc(%ebp),%esi
  102e8a:	8a 53 39             	mov    0x39(%ebx),%dl
	if (!net_context_is_used(context)) {
  102e8d:	f6 c2 01             	test   $0x1,%dl
  102e90:	0f 84 39 01 00 00    	je     102fcf <net_context_connect+0x159>
	if (addr->family != net_context_get_family(context)) {
  102e96:	66 8b 0e             	mov    (%esi),%cx
		return AF_INET6;
  102e99:	bf 0a 00 00 00       	mov    $0xa,%edi
	if (context->flags & NET_CONTEXT_FAMILY) {
  102e9e:	f6 c2 10             	test   $0x10,%dl
  102ea1:	75 05                	jne    102ea8 <net_context_connect+0x32>
	return AF_INET;
  102ea3:	bf 02 00 00 00       	mov    $0x2,%edi
  102ea8:	66 39 f9             	cmp    %di,%cx
		return -EINVAL;
  102eab:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (addr->family != net_context_get_family(context)) {
  102eb0:	0f 85 19 01 00 00    	jne    102fcf <net_context_connect+0x159>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
  102eb6:	83 f2 06             	xor    $0x6,%edx
		return -EOPNOTSUPP;
  102eb9:	b8 d3 ff ff ff       	mov    $0xffffffd3,%eax
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
  102ebe:	80 e2 06             	and    $0x6,%dl
  102ec1:	0f 84 08 01 00 00    	je     102fcf <net_context_connect+0x159>
		if (addrlen < sizeof(struct sockaddr_in)) {
  102ec7:	66 83 f9 02          	cmp    $0x2,%cx
  102ecb:	75 63                	jne    102f30 <net_context_connect+0xba>
  102ecd:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
  102ed1:	76 5d                	jbe    102f30 <net_context_connect+0xba>
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
  102ed3:	8d 46 04             	lea    0x4(%esi),%eax
  102ed6:	6a 04                	push   $0x4
  102ed8:	50                   	push   %eax
  102ed9:	8d 43 10             	lea    0x10(%ebx),%eax
  102edc:	50                   	push   %eax
  102edd:	e8 8b e5 ff ff       	call   10146d <memcpy>
		addr4->sin_port = net_sin(addr)->sin_port;
  102ee2:	66 8b 46 02          	mov    0x2(%esi),%ax
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
  102ee6:	83 c4 0c             	add    $0xc,%esp
		addr4->sin_port = net_sin(addr)->sin_port;
  102ee9:	66 89 43 0e          	mov    %ax,0xe(%ebx)
		addr4->sin_family = AF_INET;
  102eed:	66 c7 43 0c 02 00    	movw   $0x2,0xc(%ebx)
		if (addr4->sin_addr.s_addr[0]) {
  102ef3:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  102ef7:	74 06                	je     102eff <net_context_connect+0x89>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
  102ef9:	80 4b 39 80          	orb    $0x80,0x39(%ebx)
  102efd:	eb 04                	jmp    102f03 <net_context_connect+0x8d>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
  102eff:	80 63 39 7f          	andb   $0x7f,0x39(%ebx)
		net_sin(&local_addr)->sin_port = lport =
  102f03:	66 8b 53 06          	mov    0x6(%ebx),%dx
		if (net_sin_ptr(&context->local)->sin_addr) {
  102f07:	8b 7b 08             	mov    0x8(%ebx),%edi
	struct sockaddr *laddr = NULL;
  102f0a:	31 c9                	xor    %ecx,%ecx
		net_sin_ptr(&context->local)->sin_family = AF_INET;
  102f0c:	66 c7 43 04 02 00    	movw   $0x2,0x4(%ebx)
		net_sin(&local_addr)->sin_family = AF_INET;
  102f12:	66 c7 45 ec 02 00    	movw   $0x2,-0x14(%ebp)
		net_sin(&local_addr)->sin_port = lport =
  102f18:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
		if (net_sin_ptr(&context->local)->sin_addr) {
  102f1c:	85 ff                	test   %edi,%edi
  102f1e:	74 08                	je     102f28 <net_context_connect+0xb2>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  102f20:	8b 0f                	mov    (%edi),%ecx
  102f22:	89 4d f0             	mov    %ecx,-0x10(%ebp)
			laddr = &local_addr;
  102f25:	8d 4d ec             	lea    -0x14(%ebp),%ecx
	if (context->flags & NET_CONTEXT_TYPE) {
  102f28:	f6 43 39 20          	testb  $0x20,0x39(%ebx)
  102f2c:	75 20                	jne    102f4e <net_context_connect+0xd8>
  102f2e:	eb 0a                	jmp    102f3a <net_context_connect+0xc4>
		return -EINVAL;
  102f30:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  102f35:	e9 95 00 00 00       	jmp    102fcf <net_context_connect+0x159>
		if (cb) {
  102f3a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  102f3e:	74 6d                	je     102fad <net_context_connect+0x137>
			cb(context, 0, user_data);
  102f40:	ff 75 1c             	pushl  0x1c(%ebp)
  102f43:	6a 00                	push   $0x0
  102f45:	53                   	push   %ebx
  102f46:	ff 55 14             	call   *0x14(%ebp)
  102f49:	83 c4 0c             	add    $0xc,%esp
  102f4c:	eb 5f                	jmp    102fad <net_context_connect+0x137>
			       ntohs(lport),
  102f4e:	86 f2                	xchg   %dh,%dl
			       ntohs(rport),
  102f50:	86 e0                	xchg   %ah,%al
	ret = net_tcp_register(addr,
  102f52:	0f b7 d2             	movzwl %dx,%edx
  102f55:	0f b7 c0             	movzwl %ax,%eax
  102f58:	8d 7b 14             	lea    0x14(%ebx),%edi
	return net_conn_register(IPPROTO_TCP, remote_addr, local_addr,
  102f5b:	57                   	push   %edi
  102f5c:	53                   	push   %ebx
  102f5d:	68 90 2a 10 00       	push   $0x102a90
  102f62:	52                   	push   %edx
  102f63:	50                   	push   %eax
  102f64:	51                   	push   %ecx
  102f65:	56                   	push   %esi
  102f66:	6a 06                	push   $0x6
  102f68:	e8 2d 24 00 00       	call   10539a <net_conn_register>
  102f6d:	83 c4 20             	add    $0x20,%esp
	if (ret < 0) {
  102f70:	85 c0                	test   %eax,%eax
  102f72:	78 5b                	js     102fcf <net_context_connect+0x159>
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
  102f74:	8a 43 39             	mov    0x39(%ebx),%al
  102f77:	83 e0 f9             	and    $0xfffffff9,%eax
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
  102f7a:	83 c8 02             	or     $0x2,%eax
  102f7d:	88 43 39             	mov    %al,0x39(%ebx)
	net_tcp_change_state(context->tcp, NET_TCP_SYN_SENT);
  102f80:	6a 02                	push   $0x2
  102f82:	ff 73 3c             	pushl  0x3c(%ebx)
  102f85:	e8 98 1f 00 00       	call   104f22 <net_tcp_change_state>
  102f8a:	5f                   	pop    %edi
	return send_control_segment(context, NULL, remote, NET_TCP_SYN, "SYN");
  102f8b:	31 d2                	xor    %edx,%edx
	net_tcp_change_state(context->tcp, NET_TCP_SYN_SENT);
  102f8d:	58                   	pop    %eax
	return send_control_segment(context, NULL, remote, NET_TCP_SYN, "SYN");
  102f8e:	89 f1                	mov    %esi,%ecx
  102f90:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102f93:	6a 02                	push   $0x2
  102f95:	e8 42 f4 ff ff       	call   1023dc <send_control_segment.isra.12>
  102f9a:	58                   	pop    %eax
	context->connect_cb = cb;
  102f9b:	8b 45 14             	mov    0x14(%ebp),%eax
  102f9e:	89 43 20             	mov    %eax,0x20(%ebx)
	context->user_data = user_data;
  102fa1:	8b 45 1c             	mov    0x1c(%ebp),%eax
  102fa4:	89 43 24             	mov    %eax,0x24(%ebx)
	if (timeout != 0 && k_sem_take(&context->tcp->connect_wait, timeout)) {
  102fa7:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  102fab:	75 04                	jne    102fb1 <net_context_connect+0x13b>
	return 0;
  102fad:	31 c0                	xor    %eax,%eax
  102faf:	eb 1e                	jmp    102fcf <net_context_connect+0x159>
	if (timeout != 0 && k_sem_take(&context->tcp->connect_wait, timeout)) {
  102fb1:	ff 75 18             	pushl  0x18(%ebp)
  102fb4:	8b 43 3c             	mov    0x3c(%ebx),%eax
  102fb7:	05 84 00 00 00       	add    $0x84,%eax
  102fbc:	50                   	push   %eax
  102fbd:	e8 b3 44 00 00       	call   107475 <k_sem_take>
  102fc2:	5a                   	pop    %edx
  102fc3:	89 c2                	mov    %eax,%edx
  102fc5:	59                   	pop    %ecx
		return -ETIMEDOUT;
  102fc6:	b8 c4 ff ff ff       	mov    $0xffffffc4,%eax
	if (timeout != 0 && k_sem_take(&context->tcp->connect_wait, timeout)) {
  102fcb:	85 d2                	test   %edx,%edx
  102fcd:	74 de                	je     102fad <net_context_connect+0x137>
}
  102fcf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102fd2:	5b                   	pop    %ebx
  102fd3:	5e                   	pop    %esi
  102fd4:	5f                   	pop    %edi
  102fd5:	5d                   	pop    %ebp
  102fd6:	c3                   	ret    

00102fd7 <net_context_send>:
{
  102fd7:	55                   	push   %ebp
  102fd8:	89 e5                	mov    %esp,%ebp
  102fda:	57                   	push   %edi
  102fdb:	56                   	push   %esi
  102fdc:	53                   	push   %ebx
  102fdd:	83 ec 08             	sub    $0x8,%esp
  102fe0:	8b 45 08             	mov    0x8(%ebp),%eax
  102fe3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  102fe6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102fe9:	8b 45 18             	mov    0x18(%ebp),%eax
  102fec:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return ((struct net_nbuf *)net_buf_user_data(buf))->context;
  102fef:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102ff2:	e8 7b ec ff ff       	call   101c72 <net_buf_user_data>
  102ff7:	8b 75 10             	mov    0x10(%ebp),%esi
  102ffa:	8b 7d 14             	mov    0x14(%ebp),%edi
  102ffd:	8b 10                	mov    (%eax),%edx
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
  102fff:	80 7a 39 00          	cmpb   $0x0,0x39(%edx)
  103003:	79 33                	jns    103038 <net_context_send+0x61>
  103005:	66 83 7a 0e 00       	cmpw   $0x0,0xe(%edx)
  10300a:	74 2c                	je     103038 <net_context_send+0x61>
		addrlen = 0;
  10300c:	31 c9                	xor    %ecx,%ecx
  10300e:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
	return sendto(buf, &context->remote, addrlen, cb, timeout, token,
  103012:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103015:	89 7d 10             	mov    %edi,0x10(%ebp)
		addrlen = 0;
  103018:	0f 94 c1             	sete   %cl
	return sendto(buf, &context->remote, addrlen, cb, timeout, token,
  10301b:	89 45 14             	mov    %eax,0x14(%ebp)
  10301e:	83 c2 0c             	add    $0xc,%edx
  103021:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103024:	89 75 0c             	mov    %esi,0xc(%ebp)
		addrlen = 0;
  103027:	c1 e1 03             	shl    $0x3,%ecx
	return sendto(buf, &context->remote, addrlen, cb, timeout, token,
  10302a:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  10302d:	5b                   	pop    %ebx
  10302e:	5e                   	pop    %esi
  10302f:	5b                   	pop    %ebx
  103030:	5e                   	pop    %esi
  103031:	5f                   	pop    %edi
  103032:	5d                   	pop    %ebp
	return sendto(buf, &context->remote, addrlen, cb, timeout, token,
  103033:	e9 91 f4 ff ff       	jmp    1024c9 <sendto>
}
  103038:	5a                   	pop    %edx
  103039:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
  10303e:	59                   	pop    %ecx
  10303f:	5b                   	pop    %ebx
  103040:	5e                   	pop    %esi
  103041:	5f                   	pop    %edi
  103042:	5d                   	pop    %ebp
  103043:	c3                   	ret    

00103044 <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     int32_t timeout,
		     void *user_data)
{
  103044:	55                   	push   %ebp
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
		return -ENOENT;
  103045:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
{
  10304a:	89 e5                	mov    %esp,%ebp
  10304c:	57                   	push   %edi
  10304d:	56                   	push   %esi
  10304e:	53                   	push   %ebx
  10304f:	83 ec 0c             	sub    $0xc,%esp
  103052:	8b 5d 08             	mov    0x8(%ebp),%ebx
  103055:	8b 75 0c             	mov    0xc(%ebp),%esi
  103058:	8a 53 39             	mov    0x39(%ebx),%dl
	if (!net_context_is_used(context)) {
  10305b:	f6 c2 01             	test   $0x1,%dl
  10305e:	0f 84 12 01 00 00    	je     103176 <net_context_recv+0x132>
	if (context->flags & NET_CONTEXT_PROTO) {
  103064:	f6 c2 40             	test   $0x40,%dl
  103067:	74 66                	je     1030cf <net_context_recv+0x8b>

#if defined(CONFIG_NET_TCP)
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		NET_ASSERT(context->tcp);

		if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
  103069:	8b 4b 3c             	mov    0x3c(%ebx),%ecx
			return -ESHUTDOWN;
  10306c:	b8 c6 ff ff ff       	mov    $0xffffffc6,%eax
		if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
  103071:	f6 41 7d 01          	testb  $0x1,0x7d(%ecx)
  103075:	0f 85 fb 00 00 00    	jne    103176 <net_context_recv+0x132>
	return (context->flags >> NET_CONTEXT_STATE_SHIFT) &
  10307b:	d0 ea                	shr    %dl
		} else if (net_context_get_state(context)
			   != NET_CONTEXT_CONNECTED) {
			return -ENOTCONN;
  10307d:	b8 c7 ff ff ff       	mov    $0xffffffc7,%eax
		} else if (net_context_get_state(context)
  103082:	83 e2 03             	and    $0x3,%edx
  103085:	80 fa 02             	cmp    $0x2,%dl
  103088:	0f 85 e8 00 00 00    	jne    103176 <net_context_recv+0x132>
		}

		context->recv_cb = cb;
		context->tcp->recv_user_data = user_data;
  10308e:	8b 45 14             	mov    0x14(%ebp),%eax
		context->recv_cb = cb;
  103091:	89 73 18             	mov    %esi,0x18(%ebx)
		context->tcp->recv_user_data = user_data;
  103094:	89 41 04             	mov    %eax,0x4(%ecx)
	{
		return -EPROTOTYPE;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (timeout) {
  103097:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10309b:	74 2b                	je     1030c8 <net_context_recv+0x84>
		/* Make sure we have the lock, then the packet_received()
		 * callback will release the semaphore when data has been
		 * received.
		 */
		while (k_sem_take(&context->recv_data_wait, K_NO_WAIT)) {
  10309d:	83 c3 28             	add    $0x28,%ebx
  1030a0:	6a 00                	push   $0x0
  1030a2:	53                   	push   %ebx
  1030a3:	e8 cd 43 00 00       	call   107475 <k_sem_take>
  1030a8:	5e                   	pop    %esi
  1030a9:	85 c0                	test   %eax,%eax
  1030ab:	5f                   	pop    %edi
  1030ac:	75 f2                	jne    1030a0 <net_context_recv+0x5c>
			;
		}

		if (!k_sem_take(&context->recv_data_wait, timeout)) {
  1030ae:	ff 75 10             	pushl  0x10(%ebp)
  1030b1:	53                   	push   %ebx
  1030b2:	e8 be 43 00 00       	call   107475 <k_sem_take>
  1030b7:	5a                   	pop    %edx
  1030b8:	89 c2                	mov    %eax,%edx
  1030ba:	59                   	pop    %ecx
			/* timeout */
			return -ETIMEDOUT;
  1030bb:	b8 c4 ff ff ff       	mov    $0xffffffc4,%eax
		if (!k_sem_take(&context->recv_data_wait, timeout)) {
  1030c0:	85 d2                	test   %edx,%edx
  1030c2:	0f 84 ae 00 00 00    	je     103176 <net_context_recv+0x132>
		}
	}
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

	return 0;
  1030c8:	31 c0                	xor    %eax,%eax
  1030ca:	e9 a7 00 00 00       	jmp    103176 <net_context_recv+0x132>
	struct sockaddr local_addr = {
  1030cf:	31 c0                	xor    %eax,%eax
  1030d1:	8d 7d ec             	lea    -0x14(%ebp),%edi
  1030d4:	b9 02 00 00 00       	mov    $0x2,%ecx
	if (context->flags & NET_CONTEXT_FAMILY) {
  1030d9:	80 e2 10             	and    $0x10,%dl
  1030dc:	f3 ab                	rep stos %eax,%es:(%edi)
	return AF_INET;
  1030de:	b8 02 00 00 00       	mov    $0x2,%eax
	if (context->flags & NET_CONTEXT_FAMILY) {
  1030e3:	75 73                	jne    103158 <net_context_recv+0x114>
  1030e5:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	if (context->conn_handler) {
  1030e9:	8b 43 14             	mov    0x14(%ebx),%eax
  1030ec:	85 c0                	test   %eax,%eax
  1030ee:	74 0e                	je     1030fe <net_context_recv+0xba>
		net_conn_unregister(context->conn_handler);
  1030f0:	50                   	push   %eax
  1030f1:	e8 74 22 00 00       	call   10536a <net_conn_unregister>
  1030f6:	58                   	pop    %eax
		context->conn_handler = NULL;
  1030f7:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
  1030fe:	8a 43 39             	mov    0x39(%ebx),%al
  103101:	a8 10                	test   $0x10,%al
  103103:	74 5a                	je     10315f <net_context_recv+0x11b>
	uint16_t lport = 0;
  103105:	31 d2                	xor    %edx,%edx
	struct sockaddr *laddr = NULL;
  103107:	31 c9                	xor    %ecx,%ecx
	ret = net_conn_register(net_context_get_ip_proto(context),
  103109:	86 f2                	xchg   %dh,%dl
	context->recv_cb = cb;
  10310b:	89 73 18             	mov    %esi,0x18(%ebx)
	ret = net_conn_register(net_context_get_ip_proto(context),
  10310e:	0f b7 f2             	movzwl %dx,%esi
				ntohs(net_sin(&context->remote)->sin_port),
  103111:	66 8b 53 0e          	mov    0xe(%ebx),%dx
	ret = net_conn_register(net_context_get_ip_proto(context),
  103115:	89 75 e8             	mov    %esi,-0x18(%ebp)
				ntohs(net_sin(&context->remote)->sin_port),
  103118:	86 f2                	xchg   %dh,%dl
	ret = net_conn_register(net_context_get_ip_proto(context),
  10311a:	31 f6                	xor    %esi,%esi
  10311c:	8d 7b 14             	lea    0x14(%ebx),%edi
  10311f:	84 c0                	test   %al,%al
  103121:	0f b7 d2             	movzwl %dx,%edx
  103124:	79 03                	jns    103129 <net_context_recv+0xe5>
  103126:	8d 73 0c             	lea    0xc(%ebx),%esi
  103129:	57                   	push   %edi
	if (context->flags & NET_CONTEXT_PROTO) {
  10312a:	83 e0 40             	and    $0x40,%eax
  10312d:	ff 75 14             	pushl  0x14(%ebp)
		return IPPROTO_TCP;
  103130:	3c 01                	cmp    $0x1,%al
  103132:	68 62 27 10 00       	push   $0x102762
  103137:	ff 75 e8             	pushl  -0x18(%ebp)
  10313a:	19 c0                	sbb    %eax,%eax
  10313c:	52                   	push   %edx
  10313d:	83 e0 0b             	and    $0xb,%eax
  103140:	51                   	push   %ecx
  103141:	83 c0 06             	add    $0x6,%eax
  103144:	56                   	push   %esi
  103145:	50                   	push   %eax
  103146:	e8 4f 22 00 00       	call   10539a <net_conn_register>
  10314b:	83 c4 20             	add    $0x20,%esp
		if (ret < 0) {
  10314e:	85 c0                	test   %eax,%eax
  103150:	0f 89 41 ff ff ff    	jns    103097 <net_context_recv+0x53>
  103156:	eb 1e                	jmp    103176 <net_context_recv+0x132>
		return AF_INET6;
  103158:	b8 0a 00 00 00       	mov    $0xa,%eax
  10315d:	eb 86                	jmp    1030e5 <net_context_recv+0xa1>
		if (net_sin_ptr(&context->local)->sin_addr) {
  10315f:	8b 53 08             	mov    0x8(%ebx),%edx
	struct sockaddr *laddr = NULL;
  103162:	31 c9                	xor    %ecx,%ecx
		if (net_sin_ptr(&context->local)->sin_addr) {
  103164:	85 d2                	test   %edx,%edx
  103166:	74 08                	je     103170 <net_context_recv+0x12c>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  103168:	8b 12                	mov    (%edx),%edx
			laddr = &local_addr;
  10316a:	8d 4d ec             	lea    -0x14(%ebp),%ecx
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  10316d:	89 55 f0             	mov    %edx,-0x10(%ebp)
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
  103170:	66 8b 53 06          	mov    0x6(%ebx),%dx
  103174:	eb 93                	jmp    103109 <net_context_recv+0xc5>
}
  103176:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103179:	5b                   	pop    %ebx
  10317a:	5e                   	pop    %esi
  10317b:	5f                   	pop    %edi
  10317c:	5d                   	pop    %ebp
  10317d:	c3                   	ret    

0010317e <net_context_init>:

	k_sem_give(&contexts_lock);
}

void net_context_init(void)
{
  10317e:	55                   	push   %ebp
  10317f:	89 e5                	mov    %esp,%ebp
	k_sem_init(&contexts_lock, 0, UINT_MAX);
  103181:	6a ff                	push   $0xffffffff
  103183:	6a 00                	push   $0x0
  103185:	68 7c 94 10 00       	push   $0x10947c
  10318a:	e8 54 42 00 00       	call   1073e3 <k_sem_init>
  10318f:	83 c4 0c             	add    $0xc,%esp

	k_sem_give(&contexts_lock);
  103192:	68 7c 94 10 00       	push   $0x10947c
  103197:	e8 60 42 00 00       	call   1073fc <k_sem_give>
  10319c:	58                   	pop    %eax
}
  10319d:	c9                   	leave  
  10319e:	c3                   	ret    

0010319f <net_nbuf_get_reserve>:
#else /* CONFIG_NET_DEBUG_NET_BUF */
static struct net_buf *net_nbuf_get_reserve(struct net_buf_pool *pool,
					    uint16_t reserve_head,
					    int32_t timeout)
#endif /* CONFIG_NET_DEBUG_NET_BUF */
{
  10319f:	55                   	push   %ebp
  1031a0:	89 e5                	mov    %esp,%ebp
  1031a2:	57                   	push   %edi
  1031a3:	89 c7                	mov    %eax,%edi
  1031a5:	56                   	push   %esi
  1031a6:	89 d6                	mov    %edx,%esi
  1031a8:	53                   	push   %ebx
  1031a9:	89 cb                	mov    %ecx,%ebx
	/*
	 * The reserve_head variable in the function will tell
	 * the size of the link layer headers if there are any.
	 */

	if (k_is_in_isr()) {
  1031ab:	e8 17 46 00 00       	call   1077c7 <k_is_in_isr>
  1031b0:	85 c0                	test   %eax,%eax
  1031b2:	74 04                	je     1031b8 <net_nbuf_get_reserve+0x19>
		buf = net_buf_alloc(pool, K_NO_WAIT);
  1031b4:	6a 00                	push   $0x0
  1031b6:	eb 01                	jmp    1031b9 <net_nbuf_get_reserve+0x1a>
	} else {
		buf = net_buf_alloc(pool, timeout);
  1031b8:	53                   	push   %ebx
  1031b9:	57                   	push   %edi
  1031ba:	e8 26 e8 ff ff       	call   1019e5 <net_buf_alloc>
  1031bf:	59                   	pop    %ecx
	}

	if (!buf) {
  1031c0:	85 c0                	test   %eax,%eax
		buf = net_buf_alloc(pool, timeout);
  1031c2:	5b                   	pop    %ebx
  1031c3:	89 c3                	mov    %eax,%ebx
	if (!buf) {
  1031c5:	74 28                	je     1031ef <net_nbuf_get_reserve+0x50>
		return NULL;
	}

	if (pool == &data_buffers) {
  1031c7:	81 ff 10 8d 10 00    	cmp    $0x108d10,%edi
  1031cd:	75 0e                	jne    1031dd <net_nbuf_get_reserve+0x3e>
		/* The buf->data will point to the start of the L3
		 * header (like IPv4 or IPv6 packet header).
		 */
		net_buf_reserve(buf, reserve_head);
  1031cf:	0f b7 f6             	movzwl %si,%esi
  1031d2:	56                   	push   %esi
  1031d3:	50                   	push   %eax
  1031d4:	e8 fb e8 ff ff       	call   101ad4 <net_buf_reserve>
  1031d9:	58                   	pop    %eax
  1031da:	5a                   	pop    %edx
  1031db:	eb 12                	jmp    1031ef <net_nbuf_get_reserve+0x50>
	} else {
		memset(net_buf_user_data(buf), 0, sizeof(struct net_nbuf));
  1031dd:	e8 a0 ea ff ff       	call   101c82 <net_buf_user_data>
  1031e2:	6a 30                	push   $0x30
  1031e4:	6a 00                	push   $0x0
  1031e6:	50                   	push   %eax
  1031e7:	e8 ec e2 ff ff       	call   1014d8 <memset>
  1031ec:	83 c4 0c             	add    $0xc,%esp
	NET_DBG("%s [%d] buf %p reserve %u ref %d (%s():%d)",
		pool2str(pool), get_frees(pool),
		buf, reserve_head, buf->ref, caller, line);

	return buf;
}
  1031ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1031f2:	89 d8                	mov    %ebx,%eax
  1031f4:	5b                   	pop    %ebx
  1031f5:	5e                   	pop    %esi
  1031f6:	5f                   	pop    %edi
  1031f7:	5d                   	pop    %ebp
  1031f8:	c3                   	ret    

001031f9 <net_nbuf_get>:
	struct in6_addr *addr6 = NULL;
	struct net_if *iface;
	struct net_buf *buf;
	uint16_t reserve;

	if (!context) {
  1031f9:	85 d2                	test   %edx,%edx
  1031fb:	0f 84 b6 00 00 00    	je     1032b7 <net_nbuf_get+0xbe>
{
  103201:	55                   	push   %ebp
  103202:	89 e5                	mov    %esp,%ebp
  103204:	57                   	push   %edi
  103205:	56                   	push   %esi
  103206:	53                   	push   %ebx
  103207:	83 ec 08             	sub    $0x8,%esp
  10320a:	89 c7                	mov    %eax,%edi
	return net_if_get_by_index(context->iface);
  10320c:	0f b6 42 38          	movzbl 0x38(%edx),%eax
  103210:	89 d3                	mov    %edx,%ebx
  103212:	50                   	push   %eax
  103213:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103216:	e8 56 ef ff ff       	call   102171 <net_if_get_by_index>
  10321b:	5e                   	pop    %esi
	if (context->flags & NET_CONTEXT_FAMILY) {
  10321c:	f6 43 39 10          	testb  $0x10,0x39(%ebx)
	return net_if_get_by_index(context->iface);
  103220:	89 c6                	mov    %eax,%esi
	iface = net_context_get_iface(context);

	NET_ASSERT(iface);

	if (net_context_get_family(context) == AF_INET6) {
		addr6 = &((struct sockaddr_in6 *) &context->remote)->sin6_addr;
  103222:	8d 43 10             	lea    0x10(%ebx),%eax
	if (context->flags & NET_CONTEXT_FAMILY) {
  103225:	75 02                	jne    103229 <net_nbuf_get+0x30>
	struct in6_addr *addr6 = NULL;
  103227:	31 c0                	xor    %eax,%eax
	return iface->l2->reserve(iface, (void *)dst_ip6);
  103229:	8b 56 08             	mov    0x8(%esi),%edx
  10322c:	50                   	push   %eax
  10322d:	56                   	push   %esi
  10322e:	ff 52 08             	call   *0x8(%edx)
  103231:	5a                   	pop    %edx
  103232:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  103236:	59                   	pop    %ecx
	reserve = net_if_get_ll_reserve(iface, addr6);

#if defined(CONFIG_NET_DEBUG_NET_BUF)
	buf = net_nbuf_get_reserve_debug(pool, reserve, timeout, caller, line);
#else
	buf = net_nbuf_get_reserve(pool, reserve, timeout);
  103237:	0f b7 d0             	movzwl %ax,%edx
  10323a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10323d:	89 f8                	mov    %edi,%eax
  10323f:	e8 5b ff ff ff       	call   10319f <net_nbuf_get_reserve>
  103244:	89 c1                	mov    %eax,%ecx
#endif
	if (!buf) {
  103246:	85 c0                	test   %eax,%eax
  103248:	75 04                	jne    10324e <net_nbuf_get+0x55>
		return NULL;
  10324a:	31 c9                	xor    %ecx,%ecx
  10324c:	eb 5f                	jmp    1032ad <net_nbuf_get+0xb4>
		return buf;
	}

	if (pool != &data_buffers) {
  10324e:	81 ff 10 8d 10 00    	cmp    $0x108d10,%edi
  103254:	74 57                	je     1032ad <net_nbuf_get+0xb4>
	((struct net_nbuf *)net_buf_user_data(buf))->context = ctx;
  103256:	e8 27 ea ff ff       	call   101c82 <net_buf_user_data>
  10325b:	89 18                	mov    %ebx,(%eax)
	((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve = len;
  10325d:	89 c8                	mov    %ecx,%eax
  10325f:	e8 1e ea ff ff       	call   101c82 <net_buf_user_data>
		net_nbuf_set_context(buf, context);
		net_nbuf_set_ll_reserve(buf, reserve);
  103264:	8a 55 f2             	mov    -0xe(%ebp),%dl
  103267:	88 50 28             	mov    %dl,0x28(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->iface = iface;
  10326a:	89 c8                	mov    %ecx,%eax
  10326c:	e8 11 ea ff ff       	call   101c82 <net_buf_user_data>
  103271:	89 70 08             	mov    %esi,0x8(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  103274:	89 c8                	mov    %ecx,%eax
  103276:	e8 07 ea ff ff       	call   101c82 <net_buf_user_data>
		iface->link_addr.type;
  10327b:	8a 56 15             	mov    0x15(%esi),%dl
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  10327e:	88 55 f2             	mov    %dl,-0xe(%ebp)
		return AF_INET6;
  103281:	be 0a 00 00 00       	mov    $0xa,%esi
  103286:	88 50 19             	mov    %dl,0x19(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst.type =
  103289:	89 c8                	mov    %ecx,%eax
  10328b:	e8 f2 e9 ff ff       	call   101c82 <net_buf_user_data>
  103290:	8a 55 f2             	mov    -0xe(%ebp),%dl
  103293:	88 50 21             	mov    %dl,0x21(%eax)
	if (context->flags & NET_CONTEXT_FAMILY) {
  103296:	f6 43 39 10          	testb  $0x10,0x39(%ebx)
  10329a:	75 05                	jne    1032a1 <net_nbuf_get+0xa8>
	return AF_INET;
  10329c:	be 02 00 00 00       	mov    $0x2,%esi
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  1032a1:	89 c8                	mov    %ecx,%eax
		net_nbuf_set_iface(buf, iface);

		if (context) {
			net_nbuf_set_family(buf,
  1032a3:	89 f3                	mov    %esi,%ebx
  1032a5:	e8 d8 e9 ff ff       	call   101c82 <net_buf_user_data>
  1032aa:	88 58 29             	mov    %bl,0x29(%eax)
					    net_context_get_family(context));
		}
	}

	return buf;
}
  1032ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1032b0:	89 c8                	mov    %ecx,%eax
  1032b2:	5b                   	pop    %ebx
  1032b3:	5e                   	pop    %esi
  1032b4:	5f                   	pop    %edi
  1032b5:	5d                   	pop    %ebp
  1032b6:	c3                   	ret    
		return NULL;
  1032b7:	31 c9                	xor    %ecx,%ecx
}
  1032b9:	89 c8                	mov    %ecx,%eax
  1032bb:	c3                   	ret    

001032bc <free_rx_bufs_func>:
  1032bc:	55                   	push   %ebp
  1032bd:	89 e5                	mov    %esp,%ebp
  1032bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1032c2:	50                   	push   %eax
  1032c3:	ff 70 0c             	pushl  0xc(%eax)
  1032c6:	e8 e4 3b 00 00       	call   106eaf <k_lifo_put>
  1032cb:	58                   	pop    %eax
  1032cc:	5a                   	pop    %edx
  1032cd:	c9                   	leave  
  1032ce:	c3                   	ret    

001032cf <free_data_bufs_func>:
{
  1032cf:	55                   	push   %ebp
  1032d0:	89 e5                	mov    %esp,%ebp
  1032d2:	8b 45 08             	mov    0x8(%ebp),%eax
	k_lifo_put(&buf->pool->free, buf);
  1032d5:	50                   	push   %eax
  1032d6:	ff 70 0c             	pushl  0xc(%eax)
  1032d9:	e8 d1 3b 00 00       	call   106eaf <k_lifo_put>
  1032de:	58                   	pop    %eax
  1032df:	5a                   	pop    %edx
}
  1032e0:	c9                   	leave  
  1032e1:	c3                   	ret    

001032e2 <free_tx_bufs_func>:
  1032e2:	55                   	push   %ebp
  1032e3:	89 e5                	mov    %esp,%ebp
  1032e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1032e8:	50                   	push   %eax
  1032e9:	ff 70 0c             	pushl  0xc(%eax)
  1032ec:	e8 be 3b 00 00       	call   106eaf <k_lifo_put>
  1032f1:	58                   	pop    %eax
  1032f2:	5a                   	pop    %edx
  1032f3:	c9                   	leave  
  1032f4:	c3                   	ret    

001032f5 <net_nbuf_get_reserve_rx>:
{
  1032f5:	55                   	push   %ebp
	return net_nbuf_get_reserve(&rx_buffers, reserve_head, timeout);
  1032f6:	b8 48 8d 10 00       	mov    $0x108d48,%eax
{
  1032fb:	89 e5                	mov    %esp,%ebp
	return net_nbuf_get_reserve(&rx_buffers, reserve_head, timeout);
  1032fd:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
  103301:	8b 4d 0c             	mov    0xc(%ebp),%ecx
}
  103304:	5d                   	pop    %ebp
	return net_nbuf_get_reserve(&rx_buffers, reserve_head, timeout);
  103305:	e9 95 fe ff ff       	jmp    10319f <net_nbuf_get_reserve>

0010330a <net_nbuf_get_reserve_tx>:
{
  10330a:	55                   	push   %ebp
	return net_nbuf_get_reserve(&tx_buffers, reserve_head, timeout);
  10330b:	b8 2c 8d 10 00       	mov    $0x108d2c,%eax
{
  103310:	89 e5                	mov    %esp,%ebp
	return net_nbuf_get_reserve(&tx_buffers, reserve_head, timeout);
  103312:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
  103316:	8b 4d 0c             	mov    0xc(%ebp),%ecx
}
  103319:	5d                   	pop    %ebp
	return net_nbuf_get_reserve(&tx_buffers, reserve_head, timeout);
  10331a:	e9 80 fe ff ff       	jmp    10319f <net_nbuf_get_reserve>

0010331f <net_nbuf_get_reserve_data>:
{
  10331f:	55                   	push   %ebp
	return net_nbuf_get_reserve(&data_buffers, reserve_head, timeout);
  103320:	b8 10 8d 10 00       	mov    $0x108d10,%eax
{
  103325:	89 e5                	mov    %esp,%ebp
	return net_nbuf_get_reserve(&data_buffers, reserve_head, timeout);
  103327:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
  10332b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
}
  10332e:	5d                   	pop    %ebp
	return net_nbuf_get_reserve(&data_buffers, reserve_head, timeout);
  10332f:	e9 6b fe ff ff       	jmp    10319f <net_nbuf_get_reserve>

00103334 <net_nbuf_get_tx>:

	return net_nbuf_get(&rx_buffers, context, timeout);
}

struct net_buf *net_nbuf_get_tx(struct net_context *context, int32_t timeout)
{
  103334:	55                   	push   %ebp
	NET_ASSERT_INFO(context, "TX context not set");

	return net_nbuf_get(&tx_buffers, context, timeout);
  103335:	b8 2c 8d 10 00       	mov    $0x108d2c,%eax
{
  10333a:	89 e5                	mov    %esp,%ebp
	return net_nbuf_get(&tx_buffers, context, timeout);
  10333c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10333f:	8b 55 08             	mov    0x8(%ebp),%edx
}
  103342:	5d                   	pop    %ebp
	return net_nbuf_get(&tx_buffers, context, timeout);
  103343:	e9 b1 fe ff ff       	jmp    1031f9 <net_nbuf_get>

00103348 <net_nbuf_get_data>:

struct net_buf *net_nbuf_get_data(struct net_context *context, int32_t timeout)
{
  103348:	55                   	push   %ebp
	NET_ASSERT_INFO(context, "Data context not set");

	return net_nbuf_get(&data_buffers, context, timeout);
  103349:	b8 10 8d 10 00       	mov    $0x108d10,%eax
{
  10334e:	89 e5                	mov    %esp,%ebp
	return net_nbuf_get(&data_buffers, context, timeout);
  103350:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103353:	8b 55 08             	mov    0x8(%ebp),%edx
}
  103356:	5d                   	pop    %ebp
	return net_nbuf_get(&data_buffers, context, timeout);
  103357:	e9 9d fe ff ff       	jmp    1031f9 <net_nbuf_get>

0010335c <net_nbuf_unref>:
{
	struct net_buf *frag;

#else
void net_nbuf_unref(struct net_buf *buf)
{
  10335c:	55                   	push   %ebp
  10335d:	89 e5                	mov    %esp,%ebp
  10335f:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* CONFIG_NET_DEBUG_NET_BUF */
	if (!buf) {
  103362:	85 c0                	test   %eax,%eax
  103364:	74 0c                	je     103372 <net_nbuf_unref+0x16>
		NET_DBG("*** ERROR *** buf %p (%s():%d)", buf, caller, line);
		return;
	}

	if (!buf->ref) {
  103366:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  10336a:	74 06                	je     103372 <net_nbuf_unref+0x16>
	}

done:
#endif /* CONFIG_NET_DEBUG_NET_BUF */
	net_buf_unref(buf);
}
  10336c:	5d                   	pop    %ebp
	net_buf_unref(buf);
  10336d:	e9 98 e7 ff ff       	jmp    101b0a <net_buf_unref>
}
  103372:	5d                   	pop    %ebp
  103373:	c3                   	ret    

00103374 <net_nbuf_ref>:
struct net_buf *net_nbuf_ref_debug(struct net_buf *buf, const char *caller,
				   int line)
#else
struct net_buf *net_nbuf_ref(struct net_buf *buf)
#endif /* CONFIG_NET_DEBUG_NET_BUF */
{
  103374:	55                   	push   %ebp
  103375:	89 e5                	mov    %esp,%ebp
  103377:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!buf) {
  10337a:	85 c0                	test   %eax,%eax
  10337c:	74 06                	je     103384 <net_nbuf_ref+0x10>
	NET_DBG("%s [%d] buf %p ref %d (%s():%d)",
		pool2str(buf->pool), get_frees(buf->pool),
		buf, buf->ref + 1, caller, line);

	return net_buf_ref(buf);
}
  10337e:	5d                   	pop    %ebp
	return net_buf_ref(buf);
  10337f:	e9 c8 e7 ff ff       	jmp    101b4c <net_buf_ref>
}
  103384:	31 c0                	xor    %eax,%eax
  103386:	5d                   	pop    %ebp
  103387:	c3                   	ret    

00103388 <net_nbuf_copy>:

struct net_buf *net_nbuf_copy(struct net_buf *orig, size_t amount,
			      size_t reserve, int32_t timeout)
{
  103388:	55                   	push   %ebp
  103389:	89 e5                	mov    %esp,%ebp
  10338b:	57                   	push   %edi
  10338c:	56                   	push   %esi
  10338d:	53                   	push   %ebx
  10338e:	83 ec 14             	sub    $0x14,%esp
  103391:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint16_t ll_reserve = net_buf_headroom(orig);
  103394:	8d 43 10             	lea    0x10(%ebx),%eax
  103397:	50                   	push   %eax
  103398:	e8 8c e8 ff ff       	call   101c29 <net_buf_simple_headroom>
  10339d:	5f                   	pop    %edi
	struct net_buf *frag, *first;

	if (!is_from_data_pool(orig)) {
  10339e:	81 7b 0c 10 8d 10 00 	cmpl   $0x108d10,0xc(%ebx)
  1033a5:	75 2d                	jne    1033d4 <net_nbuf_copy+0x4c>
		NET_ERR("Buffer %p is not a data fragment", orig);
		return NULL;
	}

	frag = net_nbuf_get_reserve_data(ll_reserve, timeout);
  1033a7:	ff 75 14             	pushl  0x14(%ebp)
  1033aa:	0f b7 c0             	movzwl %ax,%eax
  1033ad:	50                   	push   %eax
  1033ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1033b1:	e8 69 ff ff ff       	call   10331f <net_nbuf_get_reserve_data>
  1033b6:	59                   	pop    %ecx
	if (!frag) {
  1033b7:	85 c0                	test   %eax,%eax
	frag = net_nbuf_get_reserve_data(ll_reserve, timeout);
  1033b9:	5e                   	pop    %esi
  1033ba:	89 c6                	mov    %eax,%esi
	if (!frag) {
  1033bc:	74 16                	je     1033d4 <net_nbuf_copy+0x4c>
		return NULL;
	}

	if (reserve > net_buf_tailroom(frag)) {
  1033be:	8d 78 10             	lea    0x10(%eax),%edi
  1033c1:	57                   	push   %edi
  1033c2:	e8 71 e8 ff ff       	call   101c38 <net_buf_simple_tailroom>
  1033c7:	5a                   	pop    %edx
  1033c8:	3b 45 10             	cmp    0x10(%ebp),%eax
  1033cb:	73 0e                	jae    1033db <net_nbuf_copy+0x53>
		NET_ERR("Reserve %zu is too long, max is %zu",
			reserve, net_buf_tailroom(frag));
		net_nbuf_unref(frag);
  1033cd:	56                   	push   %esi
  1033ce:	e8 89 ff ff ff       	call   10335c <net_nbuf_unref>
  1033d3:	59                   	pop    %ecx
		return NULL;
  1033d4:	31 f6                	xor    %esi,%esi
  1033d6:	e9 ec 00 00 00       	jmp    1034c7 <net_nbuf_copy+0x13f>
	}

	net_buf_add(frag, reserve);
  1033db:	ff 75 10             	pushl  0x10(%ebp)
  1033de:	57                   	push   %edi
  1033df:	e8 01 e8 ff ff       	call   101be5 <net_buf_simple_add>
  1033e4:	58                   	pop    %eax
  1033e5:	5a                   	pop    %edx
	first = frag;

	NET_DBG("Copying frag %p with %zu bytes and reserving %zu bytes",
		first, amount, reserve);

	if (!orig->len) {
  1033e6:	66 83 7b 14 00       	cmpw   $0x0,0x14(%ebx)
  1033eb:	0f 84 d6 00 00 00    	je     1034c7 <net_nbuf_copy+0x13f>
  1033f1:	89 75 ec             	mov    %esi,-0x14(%ebp)
		/* No data in the first fragment in the original message */
		NET_DBG("Original buffer empty!");
		return frag;
	}

	while (orig && amount) {
  1033f4:	85 db                	test   %ebx,%ebx
  1033f6:	0f 84 cb 00 00 00    	je     1034c7 <net_nbuf_copy+0x13f>
  1033fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103400:	0f 84 c1 00 00 00    	je     1034c7 <net_nbuf_copy+0x13f>
		int left_len = net_buf_tailroom(frag);
  103406:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103409:	8d 48 10             	lea    0x10(%eax),%ecx
  10340c:	51                   	push   %ecx
  10340d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  103410:	e8 23 e8 ff ff       	call   101c38 <net_buf_simple_tailroom>
  103415:	5f                   	pop    %edi
  103416:	89 45 f0             	mov    %eax,-0x10(%ebp)
		int copy_len;

		if (amount > orig->len) {
			copy_len = orig->len;
		} else {
			copy_len = amount;
  103419:	8b 7d 0c             	mov    0xc(%ebp),%edi
		if (amount > orig->len) {
  10341c:	0f b7 43 14          	movzwl 0x14(%ebx),%eax
  103420:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  103423:	39 c7                	cmp    %eax,%edi
  103425:	76 02                	jbe    103429 <net_nbuf_copy+0xa1>
			copy_len = orig->len;
  103427:	89 c7                	mov    %eax,%edi
  103429:	8b 43 10             	mov    0x10(%ebx),%eax
		}

		if ((copy_len - left_len) >= 0) {
  10342c:	3b 7d f0             	cmp    -0x10(%ebp),%edi
  10342f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  103432:	78 67                	js     10349b <net_nbuf_copy+0x113>
			/* Just copy the data from original fragment
			 * to new fragment. The old data will fit the
			 * new fragment and there could be some space
			 * left in the new fragment.
			 */
			amount -= left_len;
  103434:	8b 45 f0             	mov    -0x10(%ebp),%eax

			memcpy(net_buf_add(frag, left_len), orig->data,
  103437:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10343a:	50                   	push   %eax
			amount -= left_len;
  10343b:	29 45 0c             	sub    %eax,0xc(%ebp)
			memcpy(net_buf_add(frag, left_len), orig->data,
  10343e:	51                   	push   %ecx
  10343f:	e8 a1 e7 ff ff       	call   101be5 <net_buf_simple_add>
  103444:	5f                   	pop    %edi
  103445:	5a                   	pop    %edx
  103446:	ff 75 f0             	pushl  -0x10(%ebp)
  103449:	ff 75 e4             	pushl  -0x1c(%ebp)
  10344c:	50                   	push   %eax
  10344d:	e8 1b e0 ff ff       	call   10146d <memcpy>
  103452:	83 c4 0c             	add    $0xc,%esp
			       left_len);

			if (!net_buf_tailroom(frag)) {
  103455:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  103458:	51                   	push   %ecx
  103459:	e8 da e7 ff ff       	call   101c38 <net_buf_simple_tailroom>
  10345e:	59                   	pop    %ecx
  10345f:	85 c0                	test   %eax,%eax
  103461:	75 25                	jne    103488 <net_nbuf_copy+0x100>
				/* There is no space left in copy fragment.
				 * We must allocate a new one.
				 */
				struct net_buf *new_frag =
  103463:	ff 75 14             	pushl  0x14(%ebp)
  103466:	ff 75 e8             	pushl  -0x18(%ebp)
  103469:	e8 b1 fe ff ff       	call   10331f <net_nbuf_get_reserve_data>
  10346e:	5a                   	pop    %edx
  10346f:	89 c7                	mov    %eax,%edi
  103471:	59                   	pop    %ecx
					net_nbuf_get_reserve_data(ll_reserve,
								  timeout);
				if (!new_frag) {
  103472:	85 c0                	test   %eax,%eax
  103474:	0f 84 53 ff ff ff    	je     1033cd <net_nbuf_copy+0x45>
					net_nbuf_unref(first);
					return NULL;
				}

				net_buf_frag_add(frag, new_frag);
  10347a:	50                   	push   %eax
  10347b:	ff 75 ec             	pushl  -0x14(%ebp)
  10347e:	e8 0b e7 ff ff       	call   101b8e <net_buf_frag_add>
  103483:	59                   	pop    %ecx
  103484:	89 7d ec             	mov    %edi,-0x14(%ebp)
  103487:	58                   	pop    %eax

				frag = new_frag;
			}

			net_buf_pull(orig, left_len);
  103488:	ff 75 f0             	pushl  -0x10(%ebp)
  10348b:	8d 43 10             	lea    0x10(%ebx),%eax
  10348e:	50                   	push   %eax
  10348f:	e8 82 e7 ff ff       	call   101c16 <net_buf_simple_pull>
  103494:	58                   	pop    %eax
  103495:	5a                   	pop    %edx

			continue;
  103496:	e9 59 ff ff ff       	jmp    1033f4 <net_nbuf_copy+0x6c>
			/* We should be at the end of the original buf
			 * fragment list.
			 */
			amount -= copy_len;

			memcpy(net_buf_add(frag, copy_len), orig->data,
  10349b:	57                   	push   %edi
			amount -= copy_len;
  10349c:	29 7d 0c             	sub    %edi,0xc(%ebp)
			memcpy(net_buf_add(frag, copy_len), orig->data,
  10349f:	51                   	push   %ecx
  1034a0:	e8 40 e7 ff ff       	call   101be5 <net_buf_simple_add>
  1034a5:	5a                   	pop    %edx
  1034a6:	59                   	pop    %ecx
  1034a7:	57                   	push   %edi
  1034a8:	ff 75 e4             	pushl  -0x1c(%ebp)
  1034ab:	50                   	push   %eax
  1034ac:	e8 bc df ff ff       	call   10146d <memcpy>
  1034b1:	83 c4 0c             	add    $0xc,%esp
			       copy_len);
			net_buf_pull(orig, copy_len);
  1034b4:	8d 43 10             	lea    0x10(%ebx),%eax
  1034b7:	57                   	push   %edi
  1034b8:	50                   	push   %eax
  1034b9:	e8 58 e7 ff ff       	call   101c16 <net_buf_simple_pull>
  1034be:	5f                   	pop    %edi
		}

		orig = orig->frags;
  1034bf:	8b 1b                	mov    (%ebx),%ebx
			net_buf_pull(orig, copy_len);
  1034c1:	58                   	pop    %eax
  1034c2:	e9 2d ff ff ff       	jmp    1033f4 <net_nbuf_copy+0x6c>
	}

	return first;
}
  1034c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1034ca:	89 f0                	mov    %esi,%eax
  1034cc:	5b                   	pop    %ebx
  1034cd:	5e                   	pop    %esi
  1034ce:	5f                   	pop    %edi
  1034cf:	5d                   	pop    %ebp
  1034d0:	c3                   	ret    

001034d1 <net_nbuf_linear_copy>:

int net_nbuf_linear_copy(struct net_buf *dst, struct net_buf *src,
			 uint16_t offset, uint16_t len)
{
  1034d1:	55                   	push   %ebp
  1034d2:	89 e5                	mov    %esp,%ebp
  1034d4:	57                   	push   %edi
  1034d5:	56                   	push   %esi
  1034d6:	53                   	push   %ebx
  1034d7:	50                   	push   %eax
	uint16_t to_copy;
	uint16_t copied;

	if (dst->size < len) {
  1034d8:	8b 7d 08             	mov    0x8(%ebp),%edi
{
  1034db:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1034de:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1034e1:	8b 45 10             	mov    0x10(%ebp),%eax
	if (dst->size < len) {
  1034e4:	66 39 4f 16          	cmp    %cx,0x16(%edi)
  1034e8:	89 ca                	mov    %ecx,%edx
  1034ea:	73 13                	jae    1034ff <net_nbuf_linear_copy+0x2e>
		return -ENOMEM;
  1034ec:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  1034f1:	eb 69                	jmp    10355c <net_nbuf_linear_copy+0x8b>
	}

	/* find the right fragment to start copying from */
	while (src && offset >= src->len) {
  1034f3:	8b 4b 14             	mov    0x14(%ebx),%ecx
  1034f6:	66 39 c8             	cmp    %cx,%ax
  1034f9:	72 0a                	jb     103505 <net_nbuf_linear_copy+0x34>
		offset -= src->len;
  1034fb:	29 c8                	sub    %ecx,%eax
		src = src->frags;
  1034fd:	8b 1b                	mov    (%ebx),%ebx
	while (src && offset >= src->len) {
  1034ff:	85 db                	test   %ebx,%ebx
  103501:	75 f0                	jne    1034f3 <net_nbuf_linear_copy+0x22>
  103503:	eb 47                	jmp    10354c <net_nbuf_linear_copy+0x7b>
  103505:	31 ff                	xor    %edi,%edi
	}

	/* traverse the fragment chain until len bytes are copied */
	copied = 0;
	while (src && len > 0) {
  103507:	85 db                	test   %ebx,%ebx
  103509:	74 43                	je     10354e <net_nbuf_linear_copy+0x7d>
  10350b:	66 85 d2             	test   %dx,%dx
  10350e:	74 3e                	je     10354e <net_nbuf_linear_copy+0x7d>
		to_copy = min(len, src->len - offset);
  103510:	0f b7 73 14          	movzwl 0x14(%ebx),%esi
  103514:	0f b7 c0             	movzwl %ax,%eax
  103517:	0f b7 ca             	movzwl %dx,%ecx
  10351a:	29 c6                	sub    %eax,%esi
  10351c:	39 ce                	cmp    %ecx,%esi
  10351e:	7e 02                	jle    103522 <net_nbuf_linear_copy+0x51>
  103520:	89 ce                	mov    %ecx,%esi
		memcpy(dst->data + copied, src->data + offset, to_copy);
  103522:	0f b7 ce             	movzwl %si,%ecx
  103525:	51                   	push   %ecx
  103526:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103529:	03 43 10             	add    0x10(%ebx),%eax
  10352c:	8b 55 08             	mov    0x8(%ebp),%edx
  10352f:	50                   	push   %eax
  103530:	0f b7 c7             	movzwl %di,%eax
  103533:	03 42 10             	add    0x10(%edx),%eax

		copied += to_copy;
  103536:	01 f7                	add    %esi,%edi
		memcpy(dst->data + copied, src->data + offset, to_copy);
  103538:	50                   	push   %eax
  103539:	e8 2f df ff ff       	call   10146d <memcpy>
		/* to_copy is always <= len */
		len -= to_copy;
  10353e:	8b 55 f0             	mov    -0x10(%ebp),%edx
		memcpy(dst->data + copied, src->data + offset, to_copy);
  103541:	83 c4 0c             	add    $0xc,%esp
		len -= to_copy;
  103544:	29 f2                	sub    %esi,%edx
		src = src->frags;
  103546:	8b 1b                	mov    (%ebx),%ebx
		/* after the first iteration, this value will be 0 */
		offset = 0;
  103548:	31 c0                	xor    %eax,%eax
  10354a:	eb bb                	jmp    103507 <net_nbuf_linear_copy+0x36>
  10354c:	31 ff                	xor    %edi,%edi
	}

	if (len > 0) {
  10354e:	66 85 d2             	test   %dx,%dx
  103551:	75 99                	jne    1034ec <net_nbuf_linear_copy+0x1b>
		return -ENOMEM;
	}

	dst->len = copied;
  103553:	8b 45 08             	mov    0x8(%ebp),%eax
  103556:	66 89 78 14          	mov    %di,0x14(%eax)

	return 0;
  10355a:	31 c0                	xor    %eax,%eax
}
  10355c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10355f:	5b                   	pop    %ebx
  103560:	5e                   	pop    %esi
  103561:	5f                   	pop    %edi
  103562:	5d                   	pop    %ebp
  103563:	c3                   	ret    

00103564 <net_nbuf_compact>:

	return false;
}

bool net_nbuf_compact(struct net_buf *buf)
{
  103564:	55                   	push   %ebp
	struct net_buf *prev;

	if (is_from_data_pool(buf)) {
		NET_DBG("Buffer %p is a data fragment", buf);
		return false;
  103565:	31 c0                	xor    %eax,%eax
{
  103567:	89 e5                	mov    %esp,%ebp
  103569:	57                   	push   %edi
  10356a:	56                   	push   %esi
  10356b:	53                   	push   %ebx
  10356c:	51                   	push   %ecx
  10356d:	8b 55 08             	mov    0x8(%ebp),%edx
	if (is_from_data_pool(buf)) {
  103570:	81 7a 0c 10 8d 10 00 	cmpl   $0x108d10,0xc(%edx)
  103577:	0f 84 a7 00 00 00    	je     103624 <net_nbuf_compact+0xc0>
	}

	NET_DBG("Compacting data to buf %p", buf);

	buf = buf->frags;
  10357d:	8b 3a                	mov    (%edx),%edi
	prev = NULL;
  10357f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	while (buf) {
  103586:	85 ff                	test   %edi,%edi
  103588:	0f 84 94 00 00 00    	je     103622 <net_nbuf_compact+0xbe>
		if (buf->frags) {
  10358e:	8b 07                	mov    (%edi),%eax
  103590:	85 c0                	test   %eax,%eax
  103592:	74 70                	je     103604 <net_nbuf_compact+0xa0>
			 * fragment.
			 */
			size_t copy_len;

			copy_len = buf->frags->len;
			if (copy_len > net_buf_tailroom(buf)) {
  103594:	8d 77 10             	lea    0x10(%edi),%esi
			copy_len = buf->frags->len;
  103597:	0f b7 58 14          	movzwl 0x14(%eax),%ebx
			if (copy_len > net_buf_tailroom(buf)) {
  10359b:	56                   	push   %esi
  10359c:	e8 97 e6 ff ff       	call   101c38 <net_buf_simple_tailroom>
  1035a1:	5a                   	pop    %edx
  1035a2:	39 c3                	cmp    %eax,%ebx
  1035a4:	76 09                	jbe    1035af <net_nbuf_compact+0x4b>
				copy_len = net_buf_tailroom(buf);
  1035a6:	56                   	push   %esi
  1035a7:	e8 8c e6 ff ff       	call   101c38 <net_buf_simple_tailroom>
  1035ac:	5b                   	pop    %ebx
  1035ad:	89 c3                	mov    %eax,%ebx
			}

			memcpy(net_buf_tail(buf), buf->frags->data, copy_len);
  1035af:	53                   	push   %ebx
  1035b0:	8b 07                	mov    (%edi),%eax
  1035b2:	ff 70 10             	pushl  0x10(%eax)
	return buf->data + buf->len;
  1035b5:	0f b7 47 14          	movzwl 0x14(%edi),%eax
  1035b9:	03 47 10             	add    0x10(%edi),%eax
  1035bc:	50                   	push   %eax
  1035bd:	e8 ab de ff ff       	call   10146d <memcpy>
  1035c2:	83 c4 0c             	add    $0xc,%esp
			net_buf_add(buf, copy_len);
  1035c5:	53                   	push   %ebx
  1035c6:	56                   	push   %esi
  1035c7:	e8 19 e6 ff ff       	call   101be5 <net_buf_simple_add>
  1035cc:	58                   	pop    %eax

			memmove(buf->frags->data,
				buf->frags->data + copy_len,
				buf->frags->len - copy_len);
  1035cd:	8b 07                	mov    (%edi),%eax
			net_buf_add(buf, copy_len);
  1035cf:	5a                   	pop    %edx
				buf->frags->data + copy_len,
  1035d0:	8b 48 10             	mov    0x10(%eax),%ecx
				buf->frags->len - copy_len);
  1035d3:	0f b7 40 14          	movzwl 0x14(%eax),%eax
			memmove(buf->frags->data,
  1035d7:	29 d8                	sub    %ebx,%eax
  1035d9:	50                   	push   %eax
				buf->frags->data + copy_len,
  1035da:	8d 04 19             	lea    (%ecx,%ebx,1),%eax
			memmove(buf->frags->data,
  1035dd:	50                   	push   %eax
  1035de:	51                   	push   %ecx
  1035df:	e8 51 de ff ff       	call   101435 <memmove>

			buf->frags->len -= copy_len;
  1035e4:	8b 07                	mov    (%edi),%eax
  1035e6:	66 29 58 14          	sub    %bx,0x14(%eax)
			memmove(buf->frags->data,
  1035ea:	83 c4 0c             	add    $0xc,%esp

			/* Is there any more space in this fragment */
			if (net_buf_tailroom(buf)) {
  1035ed:	56                   	push   %esi
  1035ee:	e8 45 e6 ff ff       	call   101c38 <net_buf_simple_tailroom>
  1035f3:	59                   	pop    %ecx
  1035f4:	85 c0                	test   %eax,%eax
  1035f6:	74 20                	je     103618 <net_nbuf_compact+0xb4>
				/* There is. This also means that the next
				 * fragment is empty as otherwise we could
				 * not have copied all data. Remove next
				 * fragment as there is no data in it any more.
				 */
				net_buf_frag_del(buf, buf->frags);
  1035f8:	ff 37                	pushl  (%edi)
  1035fa:	57                   	push   %edi
  1035fb:	e8 bd e5 ff ff       	call   101bbd <net_buf_frag_del>
  103600:	59                   	pop    %ecx
  103601:	5b                   	pop    %ebx

				/* Then check next fragment */
				continue;
  103602:	eb 82                	jmp    103586 <net_nbuf_compact+0x22>
			}
		} else {
			if (!buf->len) {
  103604:	66 83 7f 14 00       	cmpw   $0x0,0x14(%edi)
  103609:	75 0d                	jne    103618 <net_nbuf_compact+0xb4>
				/* Remove the last fragment because there is no
				 * data in it.
				 */
				net_buf_frag_del(prev, buf);
  10360b:	57                   	push   %edi
  10360c:	ff 75 f0             	pushl  -0x10(%ebp)
  10360f:	e8 a9 e5 ff ff       	call   101bbd <net_buf_frag_del>
  103614:	58                   	pop    %eax
  103615:	5a                   	pop    %edx
  103616:	eb 0a                	jmp    103622 <net_nbuf_compact+0xbe>
				break;
			}
		}

		prev = buf;
		buf = buf->frags;
  103618:	89 7d f0             	mov    %edi,-0x10(%ebp)
  10361b:	8b 3f                	mov    (%edi),%edi
  10361d:	e9 64 ff ff ff       	jmp    103586 <net_nbuf_compact+0x22>
	}

	return true;
  103622:	b0 01                	mov    $0x1,%al
}
  103624:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103627:	5b                   	pop    %ebx
  103628:	5e                   	pop    %esi
  103629:	5f                   	pop    %edi
  10362a:	5d                   	pop    %ebp
  10362b:	c3                   	ret    

0010362c <net_nbuf_append>:
	return false;
}

bool net_nbuf_append(struct net_buf *buf, uint16_t len, const uint8_t *data,
		     int32_t timeout)
{
  10362c:	55                   	push   %ebp
  10362d:	89 e5                	mov    %esp,%ebp
  10362f:	57                   	push   %edi
  103630:	56                   	push   %esi
  103631:	53                   	push   %ebx
  103632:	83 ec 0c             	sub    $0xc,%esp
  103635:	8b 5d 08             	mov    0x8(%ebp),%ebx
  103638:	8b 45 0c             	mov    0xc(%ebp),%eax
  10363b:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	struct net_buf *frag;

	if (!buf || !data) {
  10363f:	85 db                	test   %ebx,%ebx
  103641:	0f 84 bf 00 00 00    	je     103706 <net_nbuf_append+0xda>
  103647:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10364b:	0f 84 b5 00 00 00    	je     103706 <net_nbuf_append+0xda>
		return false;
	}

	if (is_from_data_pool(buf)) {
  103651:	81 7b 0c 10 8d 10 00 	cmpl   $0x108d10,0xc(%ebx)
  103658:	0f 84 a8 00 00 00    	je     103706 <net_nbuf_append+0xda>
		 */
		NET_DBG("Buffer %p is a data fragment", buf);
		return false;
	}

	if (!buf->frags) {
  10365e:	83 3b 00             	cmpl   $0x0,(%ebx)
  103661:	75 27                	jne    10368a <net_nbuf_append+0x5e>
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  103663:	89 d8                	mov    %ebx,%eax
  103665:	e8 18 e6 ff ff       	call   101c82 <net_buf_user_data>
		frag = net_nbuf_get_reserve_data(net_nbuf_ll_reserve(buf),
  10366a:	ff 75 14             	pushl  0x14(%ebp)
  10366d:	0f b6 40 28          	movzbl 0x28(%eax),%eax
  103671:	50                   	push   %eax
  103672:	e8 a8 fc ff ff       	call   10331f <net_nbuf_get_reserve_data>
  103677:	5a                   	pop    %edx
						 timeout);
		if (!frag) {
  103678:	85 c0                	test   %eax,%eax
		frag = net_nbuf_get_reserve_data(net_nbuf_ll_reserve(buf),
  10367a:	59                   	pop    %ecx
		if (!frag) {
  10367b:	0f 84 85 00 00 00    	je     103706 <net_nbuf_append+0xda>
			return false;
		}

		net_buf_frag_add(buf, frag);
  103681:	50                   	push   %eax
  103682:	53                   	push   %ebx
  103683:	e8 06 e5 ff ff       	call   101b8e <net_buf_frag_add>
  103688:	5e                   	pop    %esi
  103689:	5f                   	pop    %edi
	struct net_buf *frag = net_buf_frag_last(buf);
  10368a:	53                   	push   %ebx
  10368b:	e8 c7 e4 ff ff       	call   101b57 <net_buf_frag_last>
  103690:	89 c6                	mov    %eax,%esi
  103692:	89 d8                	mov    %ebx,%eax
  103694:	59                   	pop    %ecx
  103695:	e8 e8 e5 ff ff       	call   101c82 <net_buf_user_data>
		frag = net_nbuf_get_reserve_data(ll_reserve, timeout);
  10369a:	0f b6 40 28          	movzbl 0x28(%eax),%eax
  10369e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint16_t count = min(len, net_buf_tailroom(frag));
  1036a1:	83 c6 10             	add    $0x10,%esi
  1036a4:	56                   	push   %esi
  1036a5:	e8 8e e5 ff ff       	call   101c38 <net_buf_simple_tailroom>
  1036aa:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  1036ae:	5a                   	pop    %edx
  1036af:	39 c1                	cmp    %eax,%ecx
  1036b1:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
  1036b5:	72 09                	jb     1036c0 <net_nbuf_append+0x94>
  1036b7:	56                   	push   %esi
  1036b8:	e8 7b e5 ff ff       	call   101c38 <net_buf_simple_tailroom>
  1036bd:	5f                   	pop    %edi
  1036be:	89 c2                	mov    %eax,%edx
		void *data = net_buf_add(frag, count);
  1036c0:	0f b7 fa             	movzwl %dx,%edi
  1036c3:	57                   	push   %edi
  1036c4:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1036c7:	56                   	push   %esi
  1036c8:	e8 18 e5 ff ff       	call   101be5 <net_buf_simple_add>
  1036cd:	5a                   	pop    %edx
  1036ce:	59                   	pop    %ecx
		memcpy(data, value, count);
  1036cf:	57                   	push   %edi
  1036d0:	ff 75 10             	pushl  0x10(%ebp)
  1036d3:	50                   	push   %eax
  1036d4:	e8 94 dd ff ff       	call   10146d <memcpy>
		if (len == 0) {
  1036d9:	8b 55 e8             	mov    -0x18(%ebp),%edx
		memcpy(data, value, count);
  1036dc:	83 c4 0c             	add    $0xc,%esp
		value += count;
  1036df:	01 7d 10             	add    %edi,0x10(%ebp)
		if (len == 0) {
  1036e2:	66 29 55 f2          	sub    %dx,-0xe(%ebp)
  1036e6:	74 22                	je     10370a <net_nbuf_append+0xde>
		frag = net_nbuf_get_reserve_data(ll_reserve, timeout);
  1036e8:	ff 75 14             	pushl  0x14(%ebp)
  1036eb:	ff 75 ec             	pushl  -0x14(%ebp)
  1036ee:	e8 2c fc ff ff       	call   10331f <net_nbuf_get_reserve_data>
  1036f3:	59                   	pop    %ecx
		if (!frag) {
  1036f4:	85 c0                	test   %eax,%eax
		frag = net_nbuf_get_reserve_data(ll_reserve, timeout);
  1036f6:	5e                   	pop    %esi
  1036f7:	89 c6                	mov    %eax,%esi
		if (!frag) {
  1036f9:	74 0b                	je     103706 <net_nbuf_append+0xda>
		net_buf_frag_add(buf, frag);
  1036fb:	50                   	push   %eax
  1036fc:	53                   	push   %ebx
  1036fd:	e8 8c e4 ff ff       	call   101b8e <net_buf_frag_add>
  103702:	58                   	pop    %eax
  103703:	5a                   	pop    %edx
  103704:	eb 9b                	jmp    1036a1 <net_nbuf_append+0x75>
		return false;
  103706:	31 c0                	xor    %eax,%eax
  103708:	eb 02                	jmp    10370c <net_nbuf_append+0xe0>
			return true;
  10370a:	b0 01                	mov    $0x1,%al
	}

	return net_nbuf_append_bytes(buf, data, len, timeout);
}
  10370c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10370f:	5b                   	pop    %ebx
  103710:	5e                   	pop    %esi
  103711:	5f                   	pop    %edi
  103712:	5d                   	pop    %ebp
  103713:	c3                   	ret    

00103714 <net_nbuf_init>:
	NET_DBG("TX %d RX %d DATA %d", tx, rx, data);
}
#endif /* CONFIG_NET_DEBUG_NET_BUF */

void net_nbuf_init(void)
{
  103714:	55                   	push   %ebp
  103715:	89 e5                	mov    %esp,%ebp
	NET_DBG("Allocating %u RX (%zu bytes), %u TX (%zu bytes) "
		"and %u data (%zu bytes) buffers",
		NBUF_RX_COUNT, sizeof(rx_buffers_pool),
		NBUF_TX_COUNT, sizeof(tx_buffers_pool),
		NBUF_DATA_COUNT, sizeof(data_buffers_pool));
}
  103717:	5d                   	pop    %ebp
  103718:	c3                   	ret    

00103719 <calc_chksum>:
static uint16_t calc_chksum(uint16_t sum, const uint8_t *ptr, uint16_t len)
{
	uint16_t tmp;
	const uint8_t *end;

	end = ptr + len - 1;
  103719:	0f b7 c9             	movzwl %cx,%ecx
{
  10371c:	55                   	push   %ebp
  10371d:	89 e5                	mov    %esp,%ebp
  10371f:	56                   	push   %esi
  103720:	53                   	push   %ebx
	end = ptr + len - 1;
  103721:	8d 5c 0a ff          	lea    -0x1(%edx,%ecx,1),%ebx

	while (ptr < end) {
  103725:	39 da                	cmp    %ebx,%edx
  103727:	73 25                	jae    10374e <calc_chksum+0x35>
		tmp = (ptr[0] << 8) + ptr[1];
  103729:	0f b6 0a             	movzbl (%edx),%ecx
  10372c:	0f b6 72 01          	movzbl 0x1(%edx),%esi
  103730:	c1 e1 08             	shl    $0x8,%ecx
  103733:	01 f1                	add    %esi,%ecx
  103735:	31 f6                	xor    %esi,%esi
  103737:	66 01 c8             	add    %cx,%ax
  10373a:	73 05                	jae    103741 <calc_chksum+0x28>
  10373c:	be 01 00 00 00       	mov    $0x1,%esi
		sum += tmp;
		if (sum < tmp) {
			sum++;
  103741:	66 83 fe 01          	cmp    $0x1,%si
  103745:	66 83 d8 ff          	sbb    $0xffff,%ax
		}
		ptr += 2;
  103749:	83 c2 02             	add    $0x2,%edx
  10374c:	eb d7                	jmp    103725 <calc_chksum+0xc>
	}

	if (ptr == end) {
  10374e:	75 1a                	jne    10376a <calc_chksum+0x51>
		tmp = ptr[0] << 8;
  103750:	0f b6 12             	movzbl (%edx),%edx
  103753:	c1 e2 08             	shl    $0x8,%edx
  103756:	31 c9                	xor    %ecx,%ecx
  103758:	66 01 d0             	add    %dx,%ax
  10375b:	73 05                	jae    103762 <calc_chksum+0x49>
  10375d:	b9 01 00 00 00       	mov    $0x1,%ecx
		sum += tmp;
		if (sum < tmp) {
			sum++;
  103762:	66 83 f9 01          	cmp    $0x1,%cx
  103766:	66 83 d8 ff          	sbb    $0xffff,%ax
		}
	}

	return sum;
}
  10376a:	5b                   	pop    %ebx
  10376b:	5e                   	pop    %esi
  10376c:	5d                   	pop    %ebp
  10376d:	c3                   	ret    

0010376e <net_addr_pton>:
{
  10376e:	55                   	push   %ebp
  10376f:	89 e5                	mov    %esp,%ebp
  103771:	57                   	push   %edi
  103772:	56                   	push   %esi
  103773:	53                   	push   %ebx
  103774:	83 ec 0c             	sub    $0xc,%esp
  103777:	8b 45 08             	mov    0x8(%ebp),%eax
  10377a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (family == AF_INET) {
  10377d:	66 83 f8 02          	cmp    $0x2,%ax
  103781:	75 66                	jne    1037e9 <net_addr_pton+0x7b>
		len = strlen(src);
  103783:	53                   	push   %ebx
  103784:	e8 49 dc ff ff       	call   1013d2 <strlen>
  103789:	59                   	pop    %ecx
  10378a:	89 c7                	mov    %eax,%edi
		for (i = 0; i < len; i++) {
  10378c:	31 d2                	xor    %edx,%edx
  10378e:	39 fa                	cmp    %edi,%edx
  103790:	74 1e                	je     1037b0 <net_addr_pton+0x42>
			if (!(src[i] >= '0' && src[i] <= '9') &&
  103792:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  103795:	8d 71 d0             	lea    -0x30(%ecx),%esi
  103798:	89 f0                	mov    %esi,%eax
  10379a:	3c 09                	cmp    $0x9,%al
  10379c:	76 0f                	jbe    1037ad <net_addr_pton+0x3f>
  10379e:	80 f9 2e             	cmp    $0x2e,%cl
  1037a1:	74 0a                	je     1037ad <net_addr_pton+0x3f>
				return -EINVAL;
  1037a3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1037a8:	e9 b3 01 00 00       	jmp    103960 <net_addr_pton+0x1f2>
		for (i = 0; i < len; i++) {
  1037ad:	42                   	inc    %edx
  1037ae:	eb de                	jmp    10378e <net_addr_pton+0x20>
		memset(addr, 0, sizeof(struct in_addr));
  1037b0:	6a 04                	push   $0x4
  1037b2:	6a 00                	push   $0x0
  1037b4:	ff 75 10             	pushl  0x10(%ebp)
		for (i = 0; i < sizeof(struct in_addr); i++) {
  1037b7:	31 f6                	xor    %esi,%esi
		memset(addr, 0, sizeof(struct in_addr));
  1037b9:	e8 1a dd ff ff       	call   1014d8 <memset>
			addr->s4_addr[i] = strtol(src, &endptr, 10);
  1037be:	8d 7d f0             	lea    -0x10(%ebp),%edi
		memset(addr, 0, sizeof(struct in_addr));
  1037c1:	83 c4 0c             	add    $0xc,%esp
			addr->s4_addr[i] = strtol(src, &endptr, 10);
  1037c4:	6a 0a                	push   $0xa
  1037c6:	57                   	push   %edi
  1037c7:	53                   	push   %ebx
  1037c8:	e8 6e dd ff ff       	call   10153b <strtol>
  1037cd:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1037d0:	83 c4 0c             	add    $0xc,%esp
  1037d3:	88 04 31             	mov    %al,(%ecx,%esi,1)
			src = ++endptr;
  1037d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
		for (i = 0; i < sizeof(struct in_addr); i++) {
  1037d9:	46                   	inc    %esi
			src = ++endptr;
  1037da:	8d 58 01             	lea    0x1(%eax),%ebx
		for (i = 0; i < sizeof(struct in_addr); i++) {
  1037dd:	83 fe 04             	cmp    $0x4,%esi
  1037e0:	75 e2                	jne    1037c4 <net_addr_pton+0x56>
	return 0;
  1037e2:	31 c0                	xor    %eax,%eax
  1037e4:	e9 77 01 00 00       	jmp    103960 <net_addr_pton+0x1f2>
	} else if (family == AF_INET6) {
  1037e9:	66 83 f8 0a          	cmp    $0xa,%ax
  1037ed:	75 b4                	jne    1037a3 <net_addr_pton+0x35>
		int expected_groups = strchr(src, '.') ? 6 : 8;
  1037ef:	6a 2e                	push   $0x2e
  1037f1:	53                   	push   %ebx
  1037f2:	e8 a1 db ff ff       	call   101398 <strchr>
  1037f7:	5e                   	pop    %esi
  1037f8:	83 f8 01             	cmp    $0x1,%eax
  1037fb:	5f                   	pop    %edi
  1037fc:	19 f6                	sbb    %esi,%esi
			src++;
  1037fe:	31 c0                	xor    %eax,%eax
		int expected_groups = strchr(src, '.') ? 6 : 8;
  103800:	83 e6 02             	and    $0x2,%esi
  103803:	83 c6 06             	add    $0x6,%esi
			src++;
  103806:	80 3b 3a             	cmpb   $0x3a,(%ebx)
  103809:	0f 94 c0             	sete   %al
  10380c:	01 c3                	add    %eax,%ebx
		len = strlen(src);
  10380e:	53                   	push   %ebx
  10380f:	e8 be db ff ff       	call   1013d2 <strlen>
  103814:	5a                   	pop    %edx
  103815:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for (i = 0; i < len; i++) {
  103818:	31 d2                	xor    %edx,%edx
  10381a:	3b 55 ec             	cmp    -0x14(%ebp),%edx
  10381d:	7d 26                	jge    103845 <net_addr_pton+0xd7>
			if (!(src[i] >= '0' && src[i] <= '9') &&
  10381f:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  103822:	89 cf                	mov    %ecx,%edi
  103824:	83 e7 df             	and    $0xffffffdf,%edi
  103827:	83 ef 41             	sub    $0x41,%edi
  10382a:	89 f8                	mov    %edi,%eax
  10382c:	3c 05                	cmp    $0x5,%al
  10382e:	76 12                	jbe    103842 <net_addr_pton+0xd4>
  103830:	8d 79 d0             	lea    -0x30(%ecx),%edi
  103833:	89 f8                	mov    %edi,%eax
  103835:	3c 0a                	cmp    $0xa,%al
  103837:	76 09                	jbe    103842 <net_addr_pton+0xd4>
			    src[i] != '.' && src[i] != ':')
  103839:	80 f9 2e             	cmp    $0x2e,%cl
  10383c:	0f 85 61 ff ff ff    	jne    1037a3 <net_addr_pton+0x35>
		for (i = 0; i < len; i++) {
  103842:	42                   	inc    %edx
  103843:	eb d5                	jmp    10381a <net_addr_pton+0xac>
				if (!src && i < expected_groups - 1) {
  103845:	8d 46 ff             	lea    -0x1(%esi),%eax
  103848:	31 d2                	xor    %edx,%edx
  10384a:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (!src || *src == '\0') {
  10384d:	85 db                	test   %ebx,%ebx
  10384f:	0f 84 4e ff ff ff    	je     1037a3 <net_addr_pton+0x35>
  103855:	8a 03                	mov    (%ebx),%al
  103857:	84 c0                	test   %al,%al
  103859:	0f 84 44 ff ff ff    	je     1037a3 <net_addr_pton+0x35>
			if (*src != ':') {
  10385f:	3c 3a                	cmp    $0x3a,%al
  103861:	74 51                	je     1038b4 <net_addr_pton+0x146>
				addr->s6_addr16[i] = htons(strtol(src, NULL,
  103863:	6a 10                	push   $0x10
  103865:	89 55 e8             	mov    %edx,-0x18(%ebp)
  103868:	6a 00                	push   $0x0
  10386a:	53                   	push   %ebx
  10386b:	e8 cb dc ff ff       	call   10153b <strtol>
  103870:	83 c4 0c             	add    $0xc,%esp
  103873:	89 c7                	mov    %eax,%edi
  103875:	6a 10                	push   $0x10
  103877:	66 c1 ef 08          	shr    $0x8,%di
  10387b:	6a 00                	push   $0x0
  10387d:	53                   	push   %ebx
  10387e:	e8 b8 dc ff ff       	call   10153b <strtol>
  103883:	8b 4d 10             	mov    0x10(%ebp),%ecx
  103886:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103889:	c1 e0 08             	shl    $0x8,%eax
  10388c:	83 c4 0c             	add    $0xc,%esp
  10388f:	09 f8                	or     %edi,%eax
  103891:	66 89 04 51          	mov    %ax,(%ecx,%edx,2)
				src = strchr(src, ':');
  103895:	6a 3a                	push   $0x3a
  103897:	53                   	push   %ebx
  103898:	e8 fb da ff ff       	call   101398 <strchr>
  10389d:	59                   	pop    %ecx
				if (!src && i < expected_groups - 1) {
  10389e:	85 c0                	test   %eax,%eax
				src = strchr(src, ':');
  1038a0:	5b                   	pop    %ebx
				if (!src && i < expected_groups - 1) {
  1038a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1038a4:	75 09                	jne    1038af <net_addr_pton+0x141>
  1038a6:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  1038a9:	0f 8f f4 fe ff ff    	jg     1037a3 <net_addr_pton+0x35>
				src++;
  1038af:	8d 58 01             	lea    0x1(%eax),%ebx
				continue;
  1038b2:	eb 4e                	jmp    103902 <net_addr_pton+0x194>
			for (; i < expected_groups; i++) {
  1038b4:	39 f2                	cmp    %esi,%edx
  1038b6:	7d 0c                	jge    1038c4 <net_addr_pton+0x156>
				addr->s6_addr16[i] = 0;
  1038b8:	8b 45 10             	mov    0x10(%ebp),%eax
  1038bb:	66 c7 04 50 00 00    	movw   $0x0,(%eax,%edx,2)
			for (; i < expected_groups; i++) {
  1038c1:	42                   	inc    %edx
  1038c2:	eb f0                	jmp    1038b4 <net_addr_pton+0x146>
			tmp = strrchr(src, ':');
  1038c4:	6a 3a                	push   $0x3a
  1038c6:	53                   	push   %ebx
  1038c7:	e8 ee da ff ff       	call   1013ba <strrchr>
  1038cc:	5f                   	pop    %edi
			if (src == tmp && (expected_groups == 6 || !src[1])) {
  1038cd:	39 d8                	cmp    %ebx,%eax
			tmp = strrchr(src, ':');
  1038cf:	5a                   	pop    %edx
			if (src == tmp && (expected_groups == 6 || !src[1])) {
  1038d0:	75 10                	jne    1038e2 <net_addr_pton+0x174>
  1038d2:	83 fe 06             	cmp    $0x6,%esi
  1038d5:	74 06                	je     1038dd <net_addr_pton+0x16f>
  1038d7:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
  1038db:	75 0f                	jne    1038ec <net_addr_pton+0x17e>
				src++;
  1038dd:	8d 58 01             	lea    0x1(%eax),%ebx
				break;
  1038e0:	eb 29                	jmp    10390b <net_addr_pton+0x19d>
				tmp--;
  1038e2:	31 d2                	xor    %edx,%edx
  1038e4:	83 fe 06             	cmp    $0x6,%esi
  1038e7:	0f 94 c2             	sete   %dl
  1038ea:	29 d0                	sub    %edx,%eax
			i = expected_groups - 1;
  1038ec:	8d 56 ff             	lea    -0x1(%esi),%edx
  1038ef:	8d 7b ff             	lea    -0x1(%ebx),%edi
					i--;
  1038f2:	31 c9                	xor    %ecx,%ecx
  1038f4:	80 38 3a             	cmpb   $0x3a,(%eax)
  1038f7:	0f 94 c1             	sete   %cl
			} while (tmp-- != src);
  1038fa:	48                   	dec    %eax
					i--;
  1038fb:	29 ca                	sub    %ecx,%edx
			} while (tmp-- != src);
  1038fd:	39 c7                	cmp    %eax,%edi
  1038ff:	75 f1                	jne    1038f2 <net_addr_pton+0x184>
			src++;
  103901:	43                   	inc    %ebx
		for (i = 0; i < expected_groups; i++) {
  103902:	42                   	inc    %edx
  103903:	39 d6                	cmp    %edx,%esi
  103905:	0f 8f 42 ff ff ff    	jg     10384d <net_addr_pton+0xdf>
		if (expected_groups == 6) {
  10390b:	83 fe 06             	cmp    $0x6,%esi
  10390e:	0f 85 ce fe ff ff    	jne    1037e2 <net_addr_pton+0x74>
  103914:	31 f6                	xor    %esi,%esi
				if (!src || !*src) {
  103916:	85 db                	test   %ebx,%ebx
  103918:	0f 84 85 fe ff ff    	je     1037a3 <net_addr_pton+0x35>
  10391e:	80 3b 00             	cmpb   $0x0,(%ebx)
  103921:	0f 84 7c fe ff ff    	je     1037a3 <net_addr_pton+0x35>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
  103927:	6a 0a                	push   $0xa
  103929:	6a 00                	push   $0x0
  10392b:	53                   	push   %ebx
  10392c:	e8 0a dc ff ff       	call   10153b <strtol>
  103931:	8b 4d 10             	mov    0x10(%ebp),%ecx
  103934:	83 c4 0c             	add    $0xc,%esp
  103937:	88 44 31 0c          	mov    %al,0xc(%ecx,%esi,1)
				src = strchr(src, '.');
  10393b:	6a 2e                	push   $0x2e
  10393d:	53                   	push   %ebx
  10393e:	e8 55 da ff ff       	call   101398 <strchr>
  103943:	5a                   	pop    %edx
				if (!src && i < 3) {
  103944:	85 c0                	test   %eax,%eax
				src = strchr(src, '.');
  103946:	59                   	pop    %ecx
				if (!src && i < 3) {
  103947:	75 09                	jne    103952 <net_addr_pton+0x1e4>
  103949:	83 fe 02             	cmp    $0x2,%esi
  10394c:	0f 8e 51 fe ff ff    	jle    1037a3 <net_addr_pton+0x35>
			for (i = 0; i < 4; i++) {
  103952:	46                   	inc    %esi
				src++;
  103953:	8d 58 01             	lea    0x1(%eax),%ebx
			for (i = 0; i < 4; i++) {
  103956:	83 fe 04             	cmp    $0x4,%esi
  103959:	75 bb                	jne    103916 <net_addr_pton+0x1a8>
  10395b:	e9 82 fe ff ff       	jmp    1037e2 <net_addr_pton+0x74>
}
  103960:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103963:	5b                   	pop    %ebx
  103964:	5e                   	pop    %esi
  103965:	5f                   	pop    %edi
  103966:	5d                   	pop    %ebp
  103967:	c3                   	ret    

00103968 <net_calc_chksum>:

	return sum;
}

uint16_t net_calc_chksum(struct net_buf *buf, uint8_t proto)
{
  103968:	55                   	push   %ebp
				  2 * sizeof(struct in6_addr));
		break;
#endif
	default:
		NET_DBG("Unknown protocol family %d", net_nbuf_family(buf));
		return 0;
  103969:	31 c9                	xor    %ecx,%ecx
{
  10396b:	89 e5                	mov    %esp,%ebp
  10396d:	57                   	push   %edi
  10396e:	56                   	push   %esi
  10396f:	53                   	push   %ebx
  103970:	83 ec 08             	sub    $0x8,%esp
  103973:	8b 55 08             	mov    0x8(%ebp),%edx
  103976:	8b 45 0c             	mov    0xc(%ebp),%eax
  103979:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  10397c:	0f b7 42 16          	movzwl 0x16(%edx),%eax
  103980:	8d 44 02 1b          	lea    0x1b(%edx,%eax,1),%eax
  103984:	83 e0 fc             	and    $0xfffffffc,%eax
	switch (net_nbuf_family(buf)) {
  103987:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  10398b:	0f 85 a9 00 00 00    	jne    103a3a <net_calc_chksum+0xd2>
  103991:	8b 1a                	mov    (%edx),%ebx
			net_nbuf_ext_len(buf) -
  103993:	0f b6 78 2b          	movzbl 0x2b(%eax),%edi
	return buf->frags->data;
  103997:	8b 73 10             	mov    0x10(%ebx),%esi
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  10399a:	0f b6 40 2a          	movzbl 0x2a(%eax),%eax
			net_nbuf_ip_hdr_len(buf);
  10399e:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  1039a2:	89 c2                	mov    %eax,%edx
		upper_layer_len = (NET_IPV4_BUF(buf)->len[0] << 8) +
  1039a4:	0f b6 46 02          	movzbl 0x2(%esi),%eax
			NET_IPV4_BUF(buf)->len[1] -
  1039a8:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
		upper_layer_len = (NET_IPV4_BUF(buf)->len[0] << 8) +
  1039ac:	c1 e0 08             	shl    $0x8,%eax
  1039af:	01 c1                	add    %eax,%ecx
			NET_IPV4_BUF(buf)->len[1] -
  1039b1:	29 f9                	sub    %edi,%ecx
		upper_layer_len = (NET_IPV4_BUF(buf)->len[0] << 8) +
  1039b3:	66 2b 4d f2          	sub    -0xe(%ebp),%cx
		if (proto == IPPROTO_ICMP) {
  1039b7:	80 7d ec 01          	cmpb   $0x1,-0x14(%ebp)
  1039bb:	75 0e                	jne    1039cb <net_calc_chksum+0x63>
			return htons(calc_chksum(0, net_nbuf_ip_data(buf) +
  1039bd:	0f b7 c9             	movzwl %cx,%ecx
  1039c0:	01 f2                	add    %esi,%edx
  1039c2:	31 c0                	xor    %eax,%eax
  1039c4:	e8 50 fd ff ff       	call   103719 <calc_chksum>
  1039c9:	eb 6b                	jmp    103a36 <net_calc_chksum+0xce>
			sum = calc_chksum(upper_layer_len + proto,
  1039cb:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  1039cf:	01 c1                	add    %eax,%ecx
					  (uint8_t *)&NET_IPV4_BUF(buf)->src,
  1039d1:	8d 56 0c             	lea    0xc(%esi),%edx
			sum = calc_chksum(upper_layer_len + proto,
  1039d4:	0f b7 c1             	movzwl %cx,%eax
  1039d7:	b9 08 00 00 00       	mov    $0x8,%ecx
  1039dc:	e8 38 fd ff ff       	call   103719 <calc_chksum>
	}

	sum = calc_chksum_buf(sum, buf, upper_layer_len);

	sum = (sum == 0) ? 0xffff : htons(sum);
  1039e1:	83 c9 ff             	or     $0xffffffff,%ecx
	uint16_t proto_len = net_nbuf_ip_hdr_len(buf) + net_nbuf_ext_len(buf);
  1039e4:	66 03 7d f2          	add    -0xe(%ebp),%di
	uint8_t *ptr = frag->data + proto_len;
  1039e8:	0f b7 d7             	movzwl %di,%edx
  1039eb:	01 f2                	add    %esi,%edx
	if (len < 0) {
  1039ed:	8b 73 14             	mov    0x14(%ebx),%esi
  1039f0:	66 29 fe             	sub    %di,%si
  1039f3:	89 f7                	mov    %esi,%edi
  1039f5:	78 43                	js     103a3a <net_calc_chksum+0xd2>
		sum = calc_chksum(sum, ptr, len);
  1039f7:	0f b7 c0             	movzwl %ax,%eax
  1039fa:	0f b7 cf             	movzwl %di,%ecx
  1039fd:	e8 17 fd ff ff       	call   103719 <calc_chksum>
		frag = frag->frags;
  103a02:	8b 1b                	mov    (%ebx),%ebx
		if (!frag) {
  103a04:	85 db                	test   %ebx,%ebx
  103a06:	74 26                	je     103a2e <net_calc_chksum+0xc6>
		if (len % 2) {
  103a08:	83 e7 01             	and    $0x1,%edi
		ptr = frag->data;
  103a0b:	8b 53 10             	mov    0x10(%ebx),%edx
  103a0e:	8b 7b 14             	mov    0x14(%ebx),%edi
		if (len % 2) {
  103a11:	74 e4                	je     1039f7 <net_calc_chksum+0x8f>
			uint16_t tmp = *ptr;
  103a13:	0f b6 0a             	movzbl (%edx),%ecx
  103a16:	31 f6                	xor    %esi,%esi
  103a18:	66 01 c8             	add    %cx,%ax
  103a1b:	73 05                	jae    103a22 <net_calc_chksum+0xba>
  103a1d:	be 01 00 00 00       	mov    $0x1,%esi
				sum++;
  103a22:	66 83 fe 01          	cmp    $0x1,%si
  103a26:	66 83 d8 ff          	sbb    $0xffff,%ax
			len = frag->len - 1;
  103a2a:	4f                   	dec    %edi
			ptr++;
  103a2b:	42                   	inc    %edx
  103a2c:	eb c9                	jmp    1039f7 <net_calc_chksum+0x8f>
	sum = (sum == 0) ? 0xffff : htons(sum);
  103a2e:	83 c9 ff             	or     $0xffffffff,%ecx
  103a31:	66 85 c0             	test   %ax,%ax
  103a34:	74 04                	je     103a3a <net_calc_chksum+0xd2>
  103a36:	86 e0                	xchg   %ah,%al
  103a38:	89 c1                	mov    %eax,%ecx

	return sum;
}
  103a3a:	5a                   	pop    %edx
  103a3b:	89 c8                	mov    %ecx,%eax
  103a3d:	59                   	pop    %ecx
  103a3e:	5b                   	pop    %ebx
  103a3f:	5e                   	pop    %esi
  103a40:	5f                   	pop    %edi
  103a41:	5d                   	pop    %ebp
  103a42:	c3                   	ret    

00103a43 <net_calc_chksum_ipv4>:

#if defined(CONFIG_NET_IPV4)
uint16_t net_calc_chksum_ipv4(struct net_buf *buf)
{
  103a43:	55                   	push   %ebp
	uint16_t sum;

	sum = calc_chksum(0, (uint8_t *)NET_IPV4_BUF(buf), NET_IPV4H_LEN);
  103a44:	b9 14 00 00 00       	mov    $0x14,%ecx
{
  103a49:	89 e5                	mov    %esp,%ebp
	return buf->frags->data;
  103a4b:	8b 45 08             	mov    0x8(%ebp),%eax
  103a4e:	8b 00                	mov    (%eax),%eax
	sum = calc_chksum(0, (uint8_t *)NET_IPV4_BUF(buf), NET_IPV4H_LEN);
  103a50:	8b 50 10             	mov    0x10(%eax),%edx
  103a53:	31 c0                	xor    %eax,%eax
  103a55:	e8 bf fc ff ff       	call   103719 <calc_chksum>
  103a5a:	83 ca ff             	or     $0xffffffff,%edx

	sum = (sum == 0) ? 0xffff : htons(sum);
  103a5d:	66 85 c0             	test   %ax,%ax
  103a60:	74 04                	je     103a66 <net_calc_chksum_ipv4+0x23>
  103a62:	86 e0                	xchg   %ah,%al
  103a64:	89 c2                	mov    %eax,%edx

	return sum;
}
  103a66:	89 d0                	mov    %edx,%eax
  103a68:	5d                   	pop    %ebp
  103a69:	c3                   	ret    

00103a6a <net_eth_is_addr_broadcast>:
	struct net_eth_addr src;
	uint16_t type;
} __packed;

static inline bool net_eth_is_addr_broadcast(struct net_eth_addr *addr)
{
  103a6a:	55                   	push   %ebp
  103a6b:	89 e5                	mov    %esp,%ebp
	if (addr->addr[0] == 0xff &&
  103a6d:	80 38 ff             	cmpb   $0xff,(%eax)
  103a70:	75 25                	jne    103a97 <net_eth_is_addr_broadcast+0x2d>
  103a72:	89 c2                	mov    %eax,%edx
	    addr->addr[4] == 0xff &&
	    addr->addr[5] == 0xff) {
		return true;
	}

	return false;
  103a74:	31 c0                	xor    %eax,%eax
	if (addr->addr[0] == 0xff &&
  103a76:	80 7a 01 ff          	cmpb   $0xff,0x1(%edx)
  103a7a:	75 1d                	jne    103a99 <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[1] == 0xff &&
  103a7c:	80 7a 02 ff          	cmpb   $0xff,0x2(%edx)
  103a80:	75 17                	jne    103a99 <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[2] == 0xff &&
  103a82:	80 7a 03 ff          	cmpb   $0xff,0x3(%edx)
  103a86:	75 11                	jne    103a99 <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[3] == 0xff &&
  103a88:	80 7a 04 ff          	cmpb   $0xff,0x4(%edx)
  103a8c:	75 0b                	jne    103a99 <net_eth_is_addr_broadcast+0x2f>
	    addr->addr[4] == 0xff &&
  103a8e:	80 7a 05 ff          	cmpb   $0xff,0x5(%edx)
  103a92:	0f 94 c0             	sete   %al
  103a95:	eb 02                	jmp    103a99 <net_eth_is_addr_broadcast+0x2f>
	return false;
  103a97:	31 c0                	xor    %eax,%eax
}
  103a99:	5d                   	pop    %ebp
  103a9a:	c3                   	ret    

00103a9b <ethernet_reserve>:

	return NET_OK;
}

static inline uint16_t ethernet_reserve(struct net_if *iface, void *unused)
{
  103a9b:	55                   	push   %ebp
	ARG_UNUSED(iface);
	ARG_UNUSED(unused);

	return sizeof(struct net_eth_hdr);
}
  103a9c:	b8 0e 00 00 00       	mov    $0xe,%eax
{
  103aa1:	89 e5                	mov    %esp,%ebp
}
  103aa3:	5d                   	pop    %ebp
  103aa4:	c3                   	ret    

00103aa5 <net_nbuf_ll>:
{
  103aa5:	55                   	push   %ebp
  103aa6:	89 c1                	mov    %eax,%ecx
  103aa8:	89 e5                	mov    %esp,%ebp
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  103aaa:	e8 e3 e1 ff ff       	call   101c92 <net_buf_user_data>
}
  103aaf:	5d                   	pop    %ebp
	return buf->frags->data;
  103ab0:	8b 09                	mov    (%ecx),%ecx
	return net_nbuf_ip_data(buf) - net_nbuf_ll_reserve(buf);
  103ab2:	0f b6 50 28          	movzbl 0x28(%eax),%edx
  103ab6:	8b 41 10             	mov    0x10(%ecx),%eax
  103ab9:	29 d0                	sub    %edx,%eax
}
  103abb:	c3                   	ret    

00103abc <net_nbuf_ll>:
{
  103abc:	55                   	push   %ebp
  103abd:	89 c1                	mov    %eax,%ecx
  103abf:	89 e5                	mov    %esp,%ebp
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  103ac1:	e8 dc e1 ff ff       	call   101ca2 <net_buf_user_data>
}
  103ac6:	5d                   	pop    %ebp
	return buf->frags->data;
  103ac7:	8b 09                	mov    (%ecx),%ecx
	return net_nbuf_ip_data(buf) - net_nbuf_ll_reserve(buf);
  103ac9:	0f b6 50 28          	movzbl 0x28(%eax),%edx
  103acd:	8b 41 10             	mov    0x10(%ecx),%eax
  103ad0:	29 d0                	sub    %edx,%eax
}
  103ad2:	c3                   	ret    

00103ad3 <ethernet_send>:
{
  103ad3:	55                   	push   %ebp
  103ad4:	89 e5                	mov    %esp,%ebp
  103ad6:	57                   	push   %edi
  103ad7:	56                   	push   %esi
  103ad8:	53                   	push   %ebx
  103ad9:	56                   	push   %esi
  103ada:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return ((struct net_nbuf *)net_buf_user_data(buf))->family;
  103add:	89 d8                	mov    %ebx,%eax
  103adf:	e8 ae e1 ff ff       	call   101c92 <net_buf_user_data>
	if (net_nbuf_family(buf) == AF_INET) {
  103ae4:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  103ae8:	0f 85 a0 00 00 00    	jne    103b8e <ethernet_send+0xbb>
	struct net_eth_hdr *hdr = NET_ETH_BUF(buf);
  103aee:	89 d8                	mov    %ebx,%eax
  103af0:	e8 b0 ff ff ff       	call   103aa5 <net_nbuf_ll>
  103af5:	89 c6                	mov    %eax,%esi
	if (net_ipv4_addr_cmp(&NET_IPV4_BUF(buf)->dst,
  103af7:	e8 fa 0e 00 00       	call   1049f6 <net_ipv4_broadcast_address>
	return buf->frags->data;
  103afc:	8b 13                	mov    (%ebx),%edx
  103afe:	8b 00                	mov    (%eax),%eax
  103b00:	8b 52 10             	mov    0x10(%edx),%edx
  103b03:	39 42 10             	cmp    %eax,0x10(%edx)
  103b06:	75 28                	jne    103b30 <ethernet_send+0x5d>
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  103b08:	89 d8                	mov    %ebx,%eax
  103b0a:	e8 83 e1 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_dst(buf)->addr = (uint8_t *)broadcast_eth_addr.addr;
  103b0f:	c7 40 1c 64 81 10 00 	movl   $0x108164,0x1c(%eax)
  103b16:	89 d8                	mov    %ebx,%eax
  103b18:	e8 75 e1 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_dst(buf)->len = sizeof(struct net_eth_addr);
  103b1d:	c6 40 20 06          	movb   $0x6,0x20(%eax)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  103b21:	89 d8                	mov    %ebx,%eax
  103b23:	e8 6a e1 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_src(buf)->addr = net_if_get_link_addr(iface)->addr;
  103b28:	8b 7d 08             	mov    0x8(%ebp),%edi
  103b2b:	8b 57 10             	mov    0x10(%edi),%edx
  103b2e:	eb 4e                	jmp    103b7e <ethernet_send+0xab>
	} else if (NET_IPV4_BUF(buf)->dst.s4_addr[0] == 224) {
  103b30:	80 7a 10 e0          	cmpb   $0xe0,0x10(%edx)
  103b34:	0f 85 0e 01 00 00    	jne    103c48 <ethernet_send+0x175>
		hdr->dst.addr[0] = 0x01;
  103b3a:	c6 06 01             	movb   $0x1,(%esi)
		hdr->dst.addr[1] = 0x00;
  103b3d:	c6 46 01 00          	movb   $0x0,0x1(%esi)
		hdr->dst.addr[2] = 0x5e;
  103b41:	c6 46 02 5e          	movb   $0x5e,0x2(%esi)
	return buf->frags->data;
  103b45:	8b 03                	mov    (%ebx),%eax
		hdr->dst.addr[3] = NET_IPV4_BUF(buf)->dst.s4_addr[1];
  103b47:	8b 40 10             	mov    0x10(%eax),%eax
  103b4a:	8a 40 11             	mov    0x11(%eax),%al
  103b4d:	88 46 03             	mov    %al,0x3(%esi)
  103b50:	8b 03                	mov    (%ebx),%eax
		hdr->dst.addr[4] = NET_IPV4_BUF(buf)->dst.s4_addr[2];
  103b52:	8b 40 10             	mov    0x10(%eax),%eax
  103b55:	8a 40 12             	mov    0x12(%eax),%al
  103b58:	88 46 04             	mov    %al,0x4(%esi)
  103b5b:	8b 03                	mov    (%ebx),%eax
		hdr->dst.addr[5] = NET_IPV4_BUF(buf)->dst.s4_addr[3];
  103b5d:	8b 40 10             	mov    0x10(%eax),%eax
  103b60:	8a 40 13             	mov    0x13(%eax),%al
  103b63:	88 46 05             	mov    %al,0x5(%esi)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  103b66:	89 d8                	mov    %ebx,%eax
  103b68:	e8 25 e1 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_dst(buf)->len = sizeof(struct net_eth_addr);
  103b6d:	c6 40 20 06          	movb   $0x6,0x20(%eax)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  103b71:	89 d8                	mov    %ebx,%eax
  103b73:	e8 1a e1 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_src(buf)->addr = net_if_get_link_addr(iface)->addr;
  103b78:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103b7b:	8b 51 10             	mov    0x10(%ecx),%edx
  103b7e:	89 50 14             	mov    %edx,0x14(%eax)
  103b81:	89 d8                	mov    %ebx,%eax
  103b83:	e8 0a e1 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_src(buf)->len = sizeof(struct net_eth_addr);
  103b88:	c6 40 18 06          	movb   $0x6,0x18(%eax)
  103b8c:	eb 53                	jmp    103be1 <ethernet_send+0x10e>
					net_nbuf_ll_src(buf)->addr) ||
  103b8e:	8b 70 14             	mov    0x14(%eax),%esi
  103b91:	89 c7                	mov    %eax,%edi
	if (net_eth_is_addr_broadcast((struct net_eth_addr *)
  103b93:	89 f0                	mov    %esi,%eax
  103b95:	e8 d0 fe ff ff       	call   103a6a <net_eth_is_addr_broadcast>
  103b9a:	84 c0                	test   %al,%al
  103b9c:	75 0b                	jne    103ba9 <ethernet_send+0xd6>

static inline bool net_eth_is_addr_multicast(struct net_eth_addr *addr)
{
	if (addr->addr[0] == 0x33 &&
  103b9e:	80 3e 33             	cmpb   $0x33,(%esi)
  103ba1:	75 1f                	jne    103bc2 <ethernet_send+0xef>
  103ba3:	80 7e 01 33          	cmpb   $0x33,0x1(%esi)
  103ba7:	75 19                	jne    103bc2 <ethernet_send+0xef>
		net_nbuf_ll_src(buf)->addr = net_nbuf_ll_if(buf)->addr;
  103ba9:	8b 47 08             	mov    0x8(%edi),%eax
  103bac:	8b 40 10             	mov    0x10(%eax),%eax
  103baf:	89 47 14             	mov    %eax,0x14(%edi)
  103bb2:	89 d8                	mov    %ebx,%eax
  103bb4:	e8 d9 e0 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_src(buf)->len = net_nbuf_ll_if(buf)->len;
  103bb9:	8b 50 08             	mov    0x8(%eax),%edx
  103bbc:	8a 52 14             	mov    0x14(%edx),%dl
  103bbf:	88 50 18             	mov    %dl,0x18(%eax)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  103bc2:	89 d8                	mov    %ebx,%eax
  103bc4:	e8 c9 e0 ff ff       	call   101c92 <net_buf_user_data>
	if (!net_nbuf_ll_dst(buf)->addr) {
  103bc9:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
  103bcd:	75 12                	jne    103be1 <ethernet_send+0x10e>
			net_nbuf_ll_dst(buf)->addr =
  103bcf:	c7 40 1c 64 81 10 00 	movl   $0x108164,0x1c(%eax)
  103bd6:	89 d8                	mov    %ebx,%eax
  103bd8:	e8 b5 e0 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_dst(buf)->len = sizeof(struct net_eth_addr);
  103bdd:	c6 40 20 06          	movb   $0x6,0x20(%eax)
	return ((struct net_nbuf *)net_buf_user_data(buf))->family;
  103be1:	89 d8                	mov    %ebx,%eax
  103be3:	e8 aa e0 ff ff       	call   101c92 <net_buf_user_data>
		ptype = htons(NET_ETH_PTYPE_IP);
  103be8:	b9 08 00 00 00       	mov    $0x8,%ecx
	if (net_nbuf_family(buf) == AF_INET) {
  103bed:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  103bf1:	74 05                	je     103bf8 <ethernet_send+0x125>
		ptype = htons(NET_ETH_PTYPE_IPV6);
  103bf3:	b9 86 dd ff ff       	mov    $0xffffdd86,%ecx
	frag = buf->frags;
  103bf8:	8b 3b                	mov    (%ebx),%edi
	while (frag) {
  103bfa:	85 ff                	test   %edi,%edi
  103bfc:	0f 84 97 00 00 00    	je     103c99 <ethernet_send+0x1c6>
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  103c02:	89 d8                	mov    %ebx,%eax
  103c04:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  103c07:	e8 86 e0 ff ff       	call   101c92 <net_buf_user_data>
		hdr = (struct net_eth_hdr *)(frag->data -
  103c0c:	8b 4f 10             	mov    0x10(%edi),%ecx
					     net_nbuf_ll_reserve(buf));
  103c0f:	0f b6 70 28          	movzbl 0x28(%eax),%esi
		memcpy(&hdr->dst, net_nbuf_ll_dst(buf)->addr,
  103c13:	6a 06                	push   $0x6
		hdr = (struct net_eth_hdr *)(frag->data -
  103c15:	29 f1                	sub    %esi,%ecx
		memcpy(&hdr->dst, net_nbuf_ll_dst(buf)->addr,
  103c17:	ff 70 1c             	pushl  0x1c(%eax)
  103c1a:	51                   	push   %ecx
		hdr = (struct net_eth_hdr *)(frag->data -
  103c1b:	89 ce                	mov    %ecx,%esi
		memcpy(&hdr->dst, net_nbuf_ll_dst(buf)->addr,
  103c1d:	e8 4b d8 ff ff       	call   10146d <memcpy>
  103c22:	83 c4 0c             	add    $0xc,%esp
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  103c25:	89 d8                	mov    %ebx,%eax
  103c27:	e8 66 e0 ff ff       	call   101c92 <net_buf_user_data>
		memcpy(&hdr->src, net_nbuf_ll_src(buf)->addr,
  103c2c:	6a 06                	push   $0x6
  103c2e:	ff 70 14             	pushl  0x14(%eax)
  103c31:	8d 46 06             	lea    0x6(%esi),%eax
  103c34:	50                   	push   %eax
  103c35:	e8 33 d8 ff ff       	call   10146d <memcpy>
		hdr->type = ptype;
  103c3a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		memcpy(&hdr->src, net_nbuf_ll_src(buf)->addr,
  103c3d:	83 c4 0c             	add    $0xc,%esp
		hdr->type = ptype;
  103c40:	66 89 4e 0c          	mov    %cx,0xc(%esi)
		frag = frag->frags;
  103c44:	8b 3f                	mov    (%edi),%edi
  103c46:	eb b2                	jmp    103bfa <ethernet_send+0x127>
		arp_buf = net_arp_prepare(buf);
  103c48:	53                   	push   %ebx
  103c49:	e8 ef 03 00 00       	call   10403d <net_arp_prepare>
  103c4e:	89 c3                	mov    %eax,%ebx
  103c50:	5a                   	pop    %edx
			return NET_DROP;
  103c51:	b8 02 00 00 00       	mov    $0x2,%eax
		if (!arp_buf) {
  103c56:	85 db                	test   %ebx,%ebx
  103c58:	74 50                	je     103caa <ethernet_send+0x1d7>
  103c5a:	89 d8                	mov    %ebx,%eax
  103c5c:	e8 31 e0 ff ff       	call   101c92 <net_buf_user_data>
  103c61:	89 c6                	mov    %eax,%esi
		net_nbuf_ll_src(buf)->addr = (uint8_t *)&NET_ETH_BUF(buf)->src;
  103c63:	89 d8                	mov    %ebx,%eax
  103c65:	e8 3b fe ff ff       	call   103aa5 <net_nbuf_ll>
  103c6a:	83 c0 06             	add    $0x6,%eax
  103c6d:	89 46 14             	mov    %eax,0x14(%esi)
  103c70:	89 d8                	mov    %ebx,%eax
  103c72:	e8 1b e0 ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_src(buf)->len = sizeof(struct net_eth_addr);
  103c77:	c6 40 18 06          	movb   $0x6,0x18(%eax)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  103c7b:	89 d8                	mov    %ebx,%eax
  103c7d:	e8 10 e0 ff ff       	call   101c92 <net_buf_user_data>
  103c82:	89 c6                	mov    %eax,%esi
		net_nbuf_ll_dst(buf)->addr = (uint8_t *)&NET_ETH_BUF(buf)->dst;
  103c84:	89 d8                	mov    %ebx,%eax
  103c86:	e8 1a fe ff ff       	call   103aa5 <net_nbuf_ll>
  103c8b:	89 46 1c             	mov    %eax,0x1c(%esi)
  103c8e:	89 d8                	mov    %ebx,%eax
  103c90:	e8 fd df ff ff       	call   101c92 <net_buf_user_data>
		net_nbuf_ll_dst(buf)->len = sizeof(struct net_eth_addr);
  103c95:	c6 40 20 06          	movb   $0x6,0x20(%eax)
	net_buf_put(&iface->tx_queue, buf);
  103c99:	8b 45 08             	mov    0x8(%ebp),%eax
  103c9c:	53                   	push   %ebx
  103c9d:	8d 78 1c             	lea    0x1c(%eax),%edi
  103ca0:	57                   	push   %edi
  103ca1:	e8 3f de ff ff       	call   101ae5 <net_buf_put>
  103ca6:	59                   	pop    %ecx
	return NET_OK;
  103ca7:	31 c0                	xor    %eax,%eax
  103ca9:	5b                   	pop    %ebx
}
  103caa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103cad:	5b                   	pop    %ebx
  103cae:	5e                   	pop    %esi
  103caf:	5f                   	pop    %edi
  103cb0:	5d                   	pop    %ebp
  103cb1:	c3                   	ret    

00103cb2 <ethernet_recv>:
{
  103cb2:	55                   	push   %ebp
  103cb3:	89 e5                	mov    %esp,%ebp
  103cb5:	57                   	push   %edi
  103cb6:	56                   	push   %esi
  103cb7:	53                   	push   %ebx
  103cb8:	83 ec 0c             	sub    $0xc,%esp
  103cbb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  103cbe:	8b 75 08             	mov    0x8(%ebp),%esi
	struct net_eth_hdr *hdr = NET_ETH_BUF(buf);
  103cc1:	89 d8                	mov    %ebx,%eax
  103cc3:	e8 dd fd ff ff       	call   103aa5 <net_nbuf_ll>
  103cc8:	89 c7                	mov    %eax,%edi
	switch (ntohs(hdr->type)) {
  103cca:	66 8b 40 0c          	mov    0xc(%eax),%ax
  103cce:	86 e0                	xchg   %ah,%al
  103cd0:	66 3d 06 08          	cmp    $0x806,%ax
  103cd4:	74 10                	je     103ce6 <ethernet_recv+0x34>
  103cd6:	66 3d dd 86          	cmp    $0x86dd,%ax
  103cda:	74 1d                	je     103cf9 <ethernet_recv+0x47>
  103cdc:	66 3d 00 08          	cmp    $0x800,%ax
  103ce0:	0f 85 2c 01 00 00    	jne    103e12 <ethernet_recv+0x160>
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  103ce6:	89 d8                	mov    %ebx,%eax
  103ce8:	e8 a5 df ff ff       	call   101c92 <net_buf_user_data>
		family = AF_INET;
  103ced:	66 c7 45 ee 02 00    	movw   $0x2,-0x12(%ebp)
  103cf3:	c6 40 29 02          	movb   $0x2,0x29(%eax)
  103cf7:	eb 11                	jmp    103d0a <ethernet_recv+0x58>
  103cf9:	89 d8                	mov    %ebx,%eax
  103cfb:	e8 92 df ff ff       	call   101c92 <net_buf_user_data>
		family = AF_INET6;
  103d00:	66 c7 45 ee 0a 00    	movw   $0xa,-0x12(%ebp)
  103d06:	c6 40 29 0a          	movb   $0xa,0x29(%eax)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  103d0a:	89 d8                	mov    %ebx,%eax
  103d0c:	e8 81 df ff ff       	call   101c92 <net_buf_user_data>
  103d11:	89 45 f0             	mov    %eax,-0x10(%ebp)
	lladdr->addr = ((struct net_eth_hdr *)net_nbuf_ll(buf))->src.addr;
  103d14:	89 d8                	mov    %ebx,%eax
  103d16:	e8 8a fd ff ff       	call   103aa5 <net_nbuf_ll>
  103d1b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103d1e:	83 c0 06             	add    $0x6,%eax
	lladdr->len = sizeof(struct net_eth_addr);
  103d21:	c6 42 18 06          	movb   $0x6,0x18(%edx)
	lladdr->addr = ((struct net_eth_hdr *)net_nbuf_ll(buf))->src.addr;
  103d25:	89 42 14             	mov    %eax,0x14(%edx)
	lladdr->type = NET_LINK_ETHERNET;
  103d28:	c6 42 19 03          	movb   $0x3,0x19(%edx)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  103d2c:	89 d8                	mov    %ebx,%eax
  103d2e:	e8 5f df ff ff       	call   101c92 <net_buf_user_data>
  103d33:	89 45 e8             	mov    %eax,-0x18(%ebp)
	lladdr->addr = ((struct net_eth_hdr *)net_nbuf_ll(buf))->dst.addr;
  103d36:	89 d8                	mov    %ebx,%eax
  103d38:	e8 68 fd ff ff       	call   103aa5 <net_nbuf_ll>
  103d3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
	lladdr->len = sizeof(struct net_eth_addr);
  103d40:	c6 42 20 06          	movb   $0x6,0x20(%edx)
	lladdr->type = NET_LINK_ETHERNET;
  103d44:	c6 42 21 03          	movb   $0x3,0x21(%edx)
	lladdr->addr = ((struct net_eth_hdr *)net_nbuf_ll(buf))->dst.addr;
  103d48:	89 42 1c             	mov    %eax,0x1c(%edx)
  103d4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
  103d4e:	e8 17 fd ff ff       	call   103a6a <net_eth_is_addr_broadcast>
  103d53:	84 c0                	test   %al,%al
  103d55:	74 2d                	je     103d84 <ethernet_recv+0xd2>
	((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve = len;
  103d57:	89 d8                	mov    %ebx,%eax
  103d59:	e8 34 df ff ff       	call   101c92 <net_buf_user_data>
  103d5e:	c6 40 28 0e          	movb   $0xe,0x28(%eax)
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  103d62:	89 d8                	mov    %ebx,%eax
  103d64:	e8 29 df ff ff       	call   101c92 <net_buf_user_data>
	net_buf_pull(buf->frags, net_nbuf_ll_reserve(buf));
  103d69:	0f b6 40 28          	movzbl 0x28(%eax),%eax
  103d6d:	50                   	push   %eax
  103d6e:	8b 03                	mov    (%ebx),%eax
  103d70:	83 c0 10             	add    $0x10,%eax
  103d73:	50                   	push   %eax
  103d74:	e8 9d de ff ff       	call   101c16 <net_buf_simple_pull>
  103d79:	58                   	pop    %eax
  103d7a:	5a                   	pop    %edx
	if (family == AF_INET && hdr->type == htons(NET_ETH_PTYPE_ARP)) {
  103d7b:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%ebp)
  103d80:	75 29                	jne    103dab <ethernet_recv+0xf9>
  103d82:	eb 10                	jmp    103d94 <ethernet_recv+0xe2>
  103d84:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d87:	80 38 33             	cmpb   $0x33,(%eax)
  103d8a:	75 7b                	jne    103e07 <ethernet_recv+0x155>
  103d8c:	80 78 01 33          	cmpb   $0x33,0x1(%eax)
  103d90:	75 75                	jne    103e07 <ethernet_recv+0x155>
  103d92:	eb c3                	jmp    103d57 <ethernet_recv+0xa5>
  103d94:	66 81 7f 0c 08 06    	cmpw   $0x608,0xc(%edi)
  103d9a:	75 0f                	jne    103dab <ethernet_recv+0xf9>
		return net_arp_input(buf);
  103d9c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  103d9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103da2:	5b                   	pop    %ebx
  103da3:	5e                   	pop    %esi
  103da4:	5f                   	pop    %edi
  103da5:	5d                   	pop    %ebp
		return net_arp_input(buf);
  103da6:	e9 93 04 00 00       	jmp    10423e <net_arp_input>
	return ((struct net_nbuf *)net_buf_user_data(buf))->family;
  103dab:	89 d8                	mov    %ebx,%eax
  103dad:	e8 e0 de ff ff       	call   101c92 <net_buf_user_data>
	if (net_nbuf_family(buf) == AF_INET) {
  103db2:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  103db6:	8b 03                	mov    (%ebx),%eax
  103db8:	75 12                	jne    103dcc <ethernet_recv+0x11a>
	return buf->frags->data;
  103dba:	8b 50 10             	mov    0x10(%eax),%edx
		len = ((NET_IPV4_BUF(buf)->len[0] << 8) +
  103dbd:	0f b6 42 02          	movzbl 0x2(%edx),%eax
		       NET_IPV4_BUF(buf)->len[1]);
  103dc1:	0f b6 52 03          	movzbl 0x3(%edx),%edx
		len = ((NET_IPV4_BUF(buf)->len[0] << 8) +
  103dc5:	c1 e0 08             	shl    $0x8,%eax
  103dc8:	01 d0                	add    %edx,%eax
  103dca:	eb 12                	jmp    103dde <ethernet_recv+0x12c>
  103dcc:	8b 40 10             	mov    0x10(%eax),%eax
		       NET_IPV6_BUF(buf)->len[1]) +
  103dcf:	0f b6 50 05          	movzbl 0x5(%eax),%edx
		len = ((NET_IPV6_BUF(buf)->len[0] << 8) +
  103dd3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
  103dd7:	c1 e0 08             	shl    $0x8,%eax
  103dda:	8d 44 02 28          	lea    0x28(%edx,%eax,1),%eax
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
  103dde:	66 83 f8 2d          	cmp    $0x2d,%ax
  103de2:	76 07                	jbe    103deb <ethernet_recv+0x139>
	return NET_CONTINUE;
  103de4:	b8 01 00 00 00       	mov    $0x1,%eax
  103de9:	eb 48                	jmp    103e33 <ethernet_recv+0x181>
		for (frag = buf->frags; frag; frag = frag->frags) {
  103deb:	8b 13                	mov    (%ebx),%edx
  103ded:	85 d2                	test   %edx,%edx
  103def:	74 f3                	je     103de4 <ethernet_recv+0x132>
			if (frag->len < len) {
  103df1:	8b 4a 14             	mov    0x14(%edx),%ecx
  103df4:	66 39 c1             	cmp    %ax,%cx
  103df7:	73 04                	jae    103dfd <ethernet_recv+0x14b>
				len -= frag->len;
  103df9:	29 c8                	sub    %ecx,%eax
  103dfb:	eb 06                	jmp    103e03 <ethernet_recv+0x151>
				frag->len = len;
  103dfd:	66 89 42 14          	mov    %ax,0x14(%edx)
				len = 0;
  103e01:	31 c0                	xor    %eax,%eax
		for (frag = buf->frags; frag; frag = frag->frags) {
  103e03:	8b 12                	mov    (%edx),%edx
  103e05:	eb e6                	jmp    103ded <ethernet_recv+0x13b>
 * @return True if the addresses are the same, false otherwise.
 */
static inline bool net_linkaddr_cmp(struct net_linkaddr *lladdr1,
				    struct net_linkaddr *lladdr2)
{
	if (!lladdr1 || !lladdr2) {
  103e07:	83 fe f0             	cmp    $0xfffffff0,%esi
  103e0a:	74 06                	je     103e12 <ethernet_recv+0x160>
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
  103e0c:	80 7e 14 06          	cmpb   $0x6,0x14(%esi)
  103e10:	74 07                	je     103e19 <ethernet_recv+0x167>
		return NET_DROP;
  103e12:	b8 02 00 00 00       	mov    $0x2,%eax
  103e17:	eb 1a                	jmp    103e33 <ethernet_recv+0x181>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
  103e19:	6a 06                	push   $0x6
  103e1b:	ff 75 f0             	pushl  -0x10(%ebp)
  103e1e:	ff 76 10             	pushl  0x10(%esi)
  103e21:	e8 e2 d5 ff ff       	call   101408 <memcmp>
  103e26:	83 c4 0c             	add    $0xc,%esp
	    !net_eth_is_addr_multicast((struct net_eth_addr *)lladdr->addr) &&
  103e29:	85 c0                	test   %eax,%eax
  103e2b:	0f 84 26 ff ff ff    	je     103d57 <ethernet_recv+0xa5>
  103e31:	eb df                	jmp    103e12 <ethernet_recv+0x160>
}
  103e33:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103e36:	5b                   	pop    %ebx
  103e37:	5e                   	pop    %esi
  103e38:	5f                   	pop    %edi
  103e39:	5d                   	pop    %ebp
  103e3a:	c3                   	ret    

00103e3b <net_nbuf_iface>:
{
  103e3b:	55                   	push   %ebp
  103e3c:	89 e5                	mov    %esp,%ebp
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  103e3e:	e8 5f de ff ff       	call   101ca2 <net_buf_user_data>
}
  103e43:	5d                   	pop    %ebp
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  103e44:	8b 40 08             	mov    0x8(%eax),%eax
}
  103e47:	c3                   	ret    

00103e48 <net_nbuf_set_iface>:
{
  103e48:	55                   	push   %ebp
  103e49:	89 c1                	mov    %eax,%ecx
  103e4b:	89 e5                	mov    %esp,%ebp
  103e4d:	53                   	push   %ebx
  103e4e:	89 d3                	mov    %edx,%ebx
	((struct net_nbuf *)net_buf_user_data(buf))->iface = iface;
  103e50:	e8 4d de ff ff       	call   101ca2 <net_buf_user_data>
  103e55:	89 58 08             	mov    %ebx,0x8(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  103e58:	89 c8                	mov    %ecx,%eax
  103e5a:	e8 43 de ff ff       	call   101ca2 <net_buf_user_data>
		iface->link_addr.type;
  103e5f:	8a 5b 15             	mov    0x15(%ebx),%bl
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  103e62:	88 58 19             	mov    %bl,0x19(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst.type =
  103e65:	89 c8                	mov    %ecx,%eax
  103e67:	e8 36 de ff ff       	call   101ca2 <net_buf_user_data>
  103e6c:	88 58 21             	mov    %bl,0x21(%eax)
}
  103e6f:	5b                   	pop    %ebx
  103e70:	5d                   	pop    %ebp
  103e71:	c3                   	ret    

00103e72 <net_nbuf_set_iface>:
{
  103e72:	55                   	push   %ebp
  103e73:	89 c1                	mov    %eax,%ecx
  103e75:	89 e5                	mov    %esp,%ebp
  103e77:	53                   	push   %ebx
  103e78:	89 d3                	mov    %edx,%ebx
	((struct net_nbuf *)net_buf_user_data(buf))->iface = iface;
  103e7a:	e8 33 de ff ff       	call   101cb2 <net_buf_user_data>
  103e7f:	89 58 08             	mov    %ebx,0x8(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  103e82:	89 c8                	mov    %ecx,%eax
  103e84:	e8 29 de ff ff       	call   101cb2 <net_buf_user_data>
		iface->link_addr.type;
  103e89:	8a 5b 15             	mov    0x15(%ebx),%bl
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src.type =
  103e8c:	88 58 19             	mov    %bl,0x19(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst.type =
  103e8f:	89 c8                	mov    %ecx,%eax
  103e91:	e8 1c de ff ff       	call   101cb2 <net_buf_user_data>
  103e96:	88 58 21             	mov    %bl,0x21(%eax)
}
  103e99:	5b                   	pop    %ebx
  103e9a:	5d                   	pop    %ebp
  103e9b:	c3                   	ret    

00103e9c <if_get_addr>:

	return NULL;
}

static inline struct in_addr *if_get_addr(struct net_if *iface)
{
  103e9c:	55                   	push   %ebp
  103e9d:	89 e5                	mov    %esp,%ebp
	int i;

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (iface->ipv4.unicast[i].is_used &&
  103e9f:	80 b8 dc 04 00 00 00 	cmpb   $0x0,0x4dc(%eax)
  103ea6:	74 1f                	je     103ec7 <if_get_addr+0x2b>
  103ea8:	89 c2                	mov    %eax,%edx
		    iface->ipv4.unicast[i].addr_state == NET_ADDR_PREFERRED) {
			return &iface->ipv4.unicast[i].address.in_addr;
		}
	}

	return NULL;
  103eaa:	31 c0                	xor    %eax,%eax
		if (iface->ipv4.unicast[i].is_used &&
  103eac:	66 83 ba e0 04 00 00 	cmpw   $0x2,0x4e0(%edx)
  103eb3:	02 
  103eb4:	75 13                	jne    103ec9 <if_get_addr+0x2d>
		    iface->ipv4.unicast[i].address.family == AF_INET &&
  103eb6:	83 ba ec 04 00 00 01 	cmpl   $0x1,0x4ec(%edx)
  103ebd:	75 0a                	jne    103ec9 <if_get_addr+0x2d>
			return &iface->ipv4.unicast[i].address.in_addr;
  103ebf:	8d 82 e4 04 00 00    	lea    0x4e4(%edx),%eax
  103ec5:	eb 02                	jmp    103ec9 <if_get_addr+0x2d>
	return NULL;
  103ec7:	31 c0                	xor    %eax,%eax
}
  103ec9:	5d                   	pop    %ebp
  103eca:	c3                   	ret    

00103ecb <prepare_arp>:

static inline struct net_buf *prepare_arp(struct net_if *iface,
					  struct in_addr *next_addr,
					  struct arp_entry *entry,
					  struct net_buf *pending)
{
  103ecb:	55                   	push   %ebp
  103ecc:	89 e5                	mov    %esp,%ebp
  103ece:	57                   	push   %edi
  103ecf:	56                   	push   %esi
  103ed0:	53                   	push   %ebx
  103ed1:	83 ec 10             	sub    $0x10,%esp
  103ed4:	89 cf                	mov    %ecx,%edi
  103ed6:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103ed9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	struct net_buf *buf, *frag;
	struct net_arp_hdr *hdr;
	struct net_eth_hdr *eth;
	struct in_addr *my_addr;

	buf = net_nbuf_get_reserve_tx(0, K_FOREVER);
  103edc:	6a ff                	push   $0xffffffff
  103ede:	6a 00                	push   $0x0
  103ee0:	e8 25 f4 ff ff       	call   10330a <net_nbuf_get_reserve_tx>
  103ee5:	5b                   	pop    %ebx
	if (!buf) {
  103ee6:	85 c0                	test   %eax,%eax
	buf = net_nbuf_get_reserve_tx(0, K_FOREVER);
  103ee8:	5e                   	pop    %esi
  103ee9:	89 c6                	mov    %eax,%esi
	if (!buf) {
  103eeb:	0f 84 30 01 00 00    	je     104021 <prepare_arp+0x156>
		goto fail;
	}

	frag = net_nbuf_get_reserve_data(sizeof(struct net_eth_hdr),
  103ef1:	6a ff                	push   $0xffffffff
  103ef3:	6a 0e                	push   $0xe
  103ef5:	e8 25 f4 ff ff       	call   10331f <net_nbuf_get_reserve_data>
  103efa:	5a                   	pop    %edx
  103efb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103efe:	59                   	pop    %ecx
					 K_FOREVER);
	if (!frag) {
  103eff:	85 c0                	test   %eax,%eax
  103f01:	0f 84 1a 01 00 00    	je     104021 <prepare_arp+0x156>
		goto fail;
	}

	net_buf_frag_add(buf, frag);
  103f07:	50                   	push   %eax
  103f08:	56                   	push   %esi
  103f09:	e8 80 dc ff ff       	call   101b8e <net_buf_frag_add>
	net_nbuf_set_iface(buf, iface);
  103f0e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103f11:	89 f0                	mov    %esi,%eax
	net_buf_frag_add(buf, frag);
  103f13:	59                   	pop    %ecx
  103f14:	5b                   	pop    %ebx
	net_nbuf_set_iface(buf, iface);
  103f15:	e8 2e ff ff ff       	call   103e48 <net_nbuf_set_iface>
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  103f1a:	89 f0                	mov    %esi,%eax
  103f1c:	e8 81 dd ff ff       	call   101ca2 <net_buf_user_data>
  103f21:	c6 40 29 02          	movb   $0x2,0x29(%eax)
	((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve = len;
  103f25:	89 f0                	mov    %esi,%eax
  103f27:	e8 76 dd ff ff       	call   101ca2 <net_buf_user_data>
  103f2c:	c6 40 28 0e          	movb   $0xe,0x28(%eax)
	return buf->frags->data;
  103f30:	8b 06                	mov    (%esi),%eax
  103f32:	8b 58 10             	mov    0x10(%eax),%ebx
	net_nbuf_set_family(buf, AF_INET);
	net_nbuf_set_ll_reserve(buf, sizeof(struct net_eth_hdr));

	hdr = NET_ARP_BUF(buf);
	eth = NET_ETH_BUF(buf);
  103f35:	89 f0                	mov    %esi,%eax
  103f37:	e8 80 fb ff ff       	call   103abc <net_nbuf_ll>
	/* If entry is not set, then we are just about to send
	 * an ARP request using the data in pending net_buf.
	 * This can happen if there is already a pending ARP
	 * request and we want to send it again.
	 */
	if (entry) {
  103f3c:	85 ff                	test   %edi,%edi
	eth = NET_ETH_BUF(buf);
  103f3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (entry) {
  103f41:	74 22                	je     103f65 <prepare_arp+0x9a>
		entry->pending = net_nbuf_ref(pending);
  103f43:	ff 75 08             	pushl  0x8(%ebp)
  103f46:	e8 29 f4 ff ff       	call   103374 <net_nbuf_ref>
  103f4b:	5a                   	pop    %edx
  103f4c:	89 47 08             	mov    %eax,0x8(%edi)
		entry->iface = net_nbuf_iface(buf);
  103f4f:	89 f0                	mov    %esi,%eax
  103f51:	e8 e5 fe ff ff       	call   103e3b <net_nbuf_iface>

		net_ipaddr_copy(&entry->ip, next_addr);
  103f56:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  103f59:	8b 11                	mov    (%ecx),%edx
		entry->iface = net_nbuf_iface(buf);
  103f5b:	89 47 04             	mov    %eax,0x4(%edi)
		net_ipaddr_copy(&entry->ip, next_addr);
  103f5e:	89 57 0c             	mov    %edx,0xc(%edi)

		memcpy(&eth->src.addr,
  103f61:	6a 06                	push   $0x6
  103f63:	eb 05                	jmp    103f6a <prepare_arp+0x9f>
		       net_if_get_link_addr(entry->iface)->addr,
		       sizeof(struct net_eth_addr));
	} else {
		memcpy(&eth->src.addr,
  103f65:	6a 06                	push   $0x6
  103f67:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103f6a:	ff 70 10             	pushl  0x10(%eax)
  103f6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103f70:	83 c0 06             	add    $0x6,%eax
  103f73:	50                   	push   %eax
  103f74:	e8 f4 d4 ff ff       	call   10146d <memcpy>
  103f79:	83 c4 0c             	add    $0xc,%esp
		       net_if_get_link_addr(iface)->addr,
		       sizeof(struct net_eth_addr));
	}

	eth->type = htons(NET_ETH_PTYPE_ARP);
  103f7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103f7f:	66 c7 40 0c 08 06    	movw   $0x608,0xc(%eax)
	memset(&eth->dst.addr, 0xff, sizeof(struct net_eth_addr));
  103f85:	6a 06                	push   $0x6
  103f87:	68 ff 00 00 00       	push   $0xff
  103f8c:	50                   	push   %eax
  103f8d:	e8 46 d5 ff ff       	call   1014d8 <memset>
  103f92:	83 c4 0c             	add    $0xc,%esp

	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
  103f95:	66 c7 03 00 01       	movw   $0x100,(%ebx)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
  103f9a:	66 c7 43 02 08 00    	movw   $0x8,0x2(%ebx)
	hdr->hwlen = sizeof(struct net_eth_addr);
  103fa0:	c6 43 04 06          	movb   $0x6,0x4(%ebx)
	hdr->protolen = sizeof(struct in_addr);
  103fa4:	c6 43 05 04          	movb   $0x4,0x5(%ebx)
	hdr->opcode = htons(NET_ARP_REQUEST);
  103fa8:	66 c7 43 06 00 01    	movw   $0x100,0x6(%ebx)

	memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
  103fae:	8d 43 12             	lea    0x12(%ebx),%eax
  103fb1:	6a 06                	push   $0x6
  103fb3:	6a 00                	push   $0x0
  103fb5:	50                   	push   %eax
  103fb6:	e8 1d d5 ff ff       	call   1014d8 <memset>

	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
  103fbb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
  103fbe:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
  103fc1:	8b 00                	mov    (%eax),%eax
  103fc3:	89 43 18             	mov    %eax,0x18(%ebx)

	memcpy(hdr->src_hwaddr.addr, eth->src.addr,
  103fc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103fc9:	83 c0 06             	add    $0x6,%eax
  103fcc:	6a 06                	push   $0x6
  103fce:	50                   	push   %eax
  103fcf:	8d 43 08             	lea    0x8(%ebx),%eax
  103fd2:	50                   	push   %eax
  103fd3:	e8 95 d4 ff ff       	call   10146d <memcpy>
  103fd8:	83 c4 0c             	add    $0xc,%esp
	       sizeof(struct net_eth_addr));

	if (entry) {
  103fdb:	85 ff                	test   %edi,%edi
  103fdd:	74 0a                	je     103fe9 <prepare_arp+0x11e>
		my_addr = if_get_addr(entry->iface);
  103fdf:	8b 47 04             	mov    0x4(%edi),%eax
  103fe2:	e8 b5 fe ff ff       	call   103e9c <if_get_addr>
  103fe7:	eb 0b                	jmp    103ff4 <prepare_arp+0x129>
  103fe9:	8b 45 08             	mov    0x8(%ebp),%eax
  103fec:	8b 00                	mov    (%eax),%eax
	} else {
		my_addr = &NET_IPV4_BUF(pending)->src;
  103fee:	8b 40 10             	mov    0x10(%eax),%eax
  103ff1:	83 c0 0c             	add    $0xc,%eax
	}

	if (my_addr) {
  103ff4:	85 c0                	test   %eax,%eax
  103ff6:	74 07                	je     103fff <prepare_arp+0x134>
		net_ipaddr_copy(&hdr->src_ipaddr, my_addr);
  103ff8:	8b 00                	mov    (%eax),%eax
  103ffa:	89 43 0e             	mov    %eax,0xe(%ebx)
  103ffd:	eb 10                	jmp    10400f <prepare_arp+0x144>
	} else {
		memset(&hdr->src_ipaddr, 0, sizeof(struct in_addr));
  103fff:	83 c3 0e             	add    $0xe,%ebx
  104002:	6a 04                	push   $0x4
  104004:	6a 00                	push   $0x0
  104006:	53                   	push   %ebx
  104007:	e8 cc d4 ff ff       	call   1014d8 <memset>
  10400c:	83 c4 0c             	add    $0xc,%esp
	}

	net_buf_add(frag, sizeof(struct net_arp_hdr));
  10400f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104012:	6a 1c                	push   $0x1c
  104014:	83 c0 10             	add    $0x10,%eax
  104017:	50                   	push   %eax
  104018:	e8 c8 db ff ff       	call   101be5 <net_buf_simple_add>
  10401d:	59                   	pop    %ecx
  10401e:	5b                   	pop    %ebx

	return buf;
  10401f:	eb 12                	jmp    104033 <prepare_arp+0x168>

fail:
	net_nbuf_unref(buf);
  104021:	56                   	push   %esi
  104022:	e8 35 f3 ff ff       	call   10335c <net_nbuf_unref>
  104027:	58                   	pop    %eax
	net_nbuf_unref(pending);
	return NULL;
  104028:	31 f6                	xor    %esi,%esi
	net_nbuf_unref(pending);
  10402a:	ff 75 08             	pushl  0x8(%ebp)
  10402d:	e8 2a f3 ff ff       	call   10335c <net_nbuf_unref>
  104032:	5a                   	pop    %edx
}
  104033:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104036:	89 f0                	mov    %esi,%eax
  104038:	5b                   	pop    %ebx
  104039:	5e                   	pop    %esi
  10403a:	5f                   	pop    %edi
  10403b:	5d                   	pop    %ebp
  10403c:	c3                   	ret    

0010403d <net_arp_prepare>:

struct net_buf *net_arp_prepare(struct net_buf *buf)
{
  10403d:	55                   	push   %ebp
  10403e:	89 e5                	mov    %esp,%ebp
  104040:	57                   	push   %edi
  104041:	56                   	push   %esi
  104042:	53                   	push   %ebx
  104043:	83 ec 08             	sub    $0x8,%esp
  104046:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct arp_entry *entry, *free_entry = NULL, *non_pending = NULL;
	struct net_linkaddr *ll;
	struct net_eth_hdr *hdr;
	struct in_addr *addr;

	if (!buf || !buf->frags) {
  104049:	85 db                	test   %ebx,%ebx
  10404b:	0f 84 e3 01 00 00    	je     104234 <net_arp_prepare+0x1f7>
  104051:	83 3b 00             	cmpl   $0x0,(%ebx)
  104054:	0f 84 d8 01 00 00    	je     104232 <net_arp_prepare+0x1f5>
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  10405a:	89 d8                	mov    %ebx,%eax
  10405c:	e8 41 dc ff ff       	call   101ca2 <net_buf_user_data>
		return NULL;
	}

	if (net_nbuf_ll_reserve(buf) != sizeof(struct net_eth_hdr)) {
  104061:	80 78 28 0e          	cmpb   $0xe,0x28(%eax)
  104065:	74 6e                	je     1040d5 <net_arp_prepare+0x98>
	((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve = len;
  104067:	c6 40 28 0e          	movb   $0xe,0x28(%eax)
		struct net_buf *header;
		struct net_linkaddr *ll;

		net_nbuf_set_ll_reserve(buf, sizeof(struct net_eth_hdr));

		header = net_nbuf_get_reserve_data(sizeof(struct net_eth_hdr),
  10406b:	6a ff                	push   $0xffffffff
  10406d:	6a 0e                	push   $0xe
  10406f:	e8 ab f2 ff ff       	call   10331f <net_nbuf_get_reserve_data>
  104074:	5e                   	pop    %esi
  104075:	5f                   	pop    %edi
  104076:	89 c7                	mov    %eax,%edi
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  104078:	89 d8                	mov    %ebx,%eax
  10407a:	e8 23 dc ff ff       	call   101ca2 <net_buf_user_data>
						   K_FOREVER);

		hdr = (struct net_eth_hdr *)(header->data -
  10407f:	8b 77 10             	mov    0x10(%edi),%esi
					     net_nbuf_ll_reserve(buf));
  104082:	0f b6 40 28          	movzbl 0x28(%eax),%eax
		hdr = (struct net_eth_hdr *)(header->data -
  104086:	29 c6                	sub    %eax,%esi
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  104088:	89 d8                	mov    %ebx,%eax

		hdr->type = htons(NET_ETH_PTYPE_IP);
  10408a:	66 c7 46 0c 08 00    	movw   $0x8,0xc(%esi)
  104090:	e8 0d dc ff ff       	call   101ca2 <net_buf_user_data>

		ll = net_nbuf_ll_dst(buf);
		if (ll->addr) {
  104095:	8b 40 1c             	mov    0x1c(%eax),%eax
  104098:	85 c0                	test   %eax,%eax
  10409a:	74 0c                	je     1040a8 <net_arp_prepare+0x6b>
			memcpy(&hdr->dst.addr, ll->addr,
  10409c:	6a 06                	push   $0x6
  10409e:	50                   	push   %eax
  10409f:	56                   	push   %esi
  1040a0:	e8 c8 d3 ff ff       	call   10146d <memcpy>
  1040a5:	83 c4 0c             	add    $0xc,%esp
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  1040a8:	89 d8                	mov    %ebx,%eax
  1040aa:	e8 f3 db ff ff       	call   101ca2 <net_buf_user_data>
			       sizeof(struct net_eth_addr));
		}

		ll = net_nbuf_ll_src(buf);
		if (ll->addr) {
  1040af:	8b 40 14             	mov    0x14(%eax),%eax
  1040b2:	85 c0                	test   %eax,%eax
  1040b4:	74 0f                	je     1040c5 <net_arp_prepare+0x88>
			memcpy(&hdr->src.addr, ll->addr,
  1040b6:	83 c6 06             	add    $0x6,%esi
  1040b9:	6a 06                	push   $0x6
  1040bb:	50                   	push   %eax
  1040bc:	56                   	push   %esi
  1040bd:	e8 ab d3 ff ff       	call   10146d <memcpy>
  1040c2:	83 c4 0c             	add    $0xc,%esp
			       sizeof(struct net_eth_addr));
		}

		net_buf_frag_insert(buf, header);
  1040c5:	57                   	push   %edi
  1040c6:	53                   	push   %ebx
  1040c7:	e8 9d da ff ff       	call   101b69 <net_buf_frag_insert>
  1040cc:	58                   	pop    %eax
  1040cd:	5a                   	pop    %edx

		net_nbuf_compact(buf);
  1040ce:	53                   	push   %ebx
  1040cf:	e8 90 f4 ff ff       	call   103564 <net_nbuf_compact>
  1040d4:	59                   	pop    %ecx
	hdr = (struct net_eth_hdr *)net_nbuf_ll(buf);

	/* Is the destination in the local network, if not route via
	 * the gateway address.
	 */
	if (!net_if_ipv4_addr_mask_cmp(net_nbuf_iface(buf),
  1040d5:	89 d8                	mov    %ebx,%eax
  1040d7:	e8 5f fd ff ff       	call   103e3b <net_nbuf_iface>
	return buf->frags->data;
  1040dc:	8b 13                	mov    (%ebx),%edx
  1040de:	8b 52 10             	mov    0x10(%edx),%edx
  1040e1:	83 c2 10             	add    $0x10,%edx
  1040e4:	52                   	push   %edx
  1040e5:	50                   	push   %eax
  1040e6:	e8 a4 de ff ff       	call   101f8f <net_if_ipv4_addr_mask_cmp>
  1040eb:	5e                   	pop    %esi
  1040ec:	84 c0                	test   %al,%al
  1040ee:	5f                   	pop    %edi
  1040ef:	75 0f                	jne    104100 <net_arp_prepare+0xc3>
				       &NET_IPV4_BUF(buf)->dst)) {
		addr = &net_nbuf_iface(buf)->ipv4.gw;
  1040f1:	89 d8                	mov    %ebx,%eax
  1040f3:	e8 43 fd ff ff       	call   103e3b <net_nbuf_iface>
  1040f8:	8d 90 28 05 00 00    	lea    0x528(%eax),%edx
  1040fe:	eb 08                	jmp    104108 <net_arp_prepare+0xcb>
  104100:	8b 03                	mov    (%ebx),%eax
	} else {
		addr = &NET_IPV4_BUF(buf)->dst;
  104102:	8b 50 10             	mov    0x10(%eax),%edx
  104105:	83 c2 10             	add    $0x10,%edx
	}

	/* If the destination address is already known, we do not need
	 * to send any ARP packet.
	 */
	entry = find_entry(net_nbuf_iface(buf),
  104108:	89 d8                	mov    %ebx,%eax
  10410a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10410d:	e8 29 fd ff ff       	call   103e3b <net_nbuf_iface>
		if (arp_table[i].iface == iface &&
  104112:	8b 55 ec             	mov    -0x14(%ebp),%edx
	entry = find_entry(net_nbuf_iface(buf),
  104115:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (arp_table[i].iface == iface &&
  104118:	a1 24 96 10 00       	mov    0x109624,%eax
  10411d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  104120:	75 0a                	jne    10412c <net_arp_prepare+0xef>
  104122:	8b 0d 2c 96 10 00    	mov    0x10962c,%ecx
  104128:	39 0a                	cmp    %ecx,(%edx)
  10412a:	74 3c                	je     104168 <net_arp_prepare+0x12b>
		if (!*free_entry && !arp_table[i].pending &&
  10412c:	8b 3d 28 96 10 00    	mov    0x109628,%edi
  104132:	85 c0                	test   %eax,%eax
  104134:	75 09                	jne    10413f <net_arp_prepare+0x102>
			*free_entry = &arp_table[i];
  104136:	b8 20 96 10 00       	mov    $0x109620,%eax
		if (!*free_entry && !arp_table[i].pending &&
  10413b:	85 ff                	test   %edi,%edi
  10413d:	74 02                	je     104141 <net_arp_prepare+0x104>
  10413f:	31 c0                	xor    %eax,%eax
			*non_pending = &arp_table[i];
  104141:	b9 20 96 10 00       	mov    $0x109620,%ecx
		if (!*non_pending && !arp_table[i].pending) {
  104146:	85 ff                	test   %edi,%edi
  104148:	74 02                	je     10414c <net_arp_prepare+0x10f>
  10414a:	31 c9                	xor    %ecx,%ecx
		if (arp_table[i].iface == iface &&
  10414c:	8b 3d 3c 96 10 00    	mov    0x10963c,%edi
  104152:	39 7d f0             	cmp    %edi,-0x10(%ebp)
  104155:	75 2f                	jne    104186 <net_arp_prepare+0x149>
  104157:	8b 32                	mov    (%edx),%esi
  104159:	39 35 44 96 10 00    	cmp    %esi,0x109644
  10415f:	75 25                	jne    104186 <net_arp_prepare+0x149>
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
  104161:	bf 01 00 00 00       	mov    $0x1,%edi
  104166:	eb 02                	jmp    10416a <net_arp_prepare+0x12d>
  104168:	31 ff                	xor    %edi,%edi
			if (arp_table[i].pending) {
  10416a:	6b ff 18             	imul   $0x18,%edi,%edi
  10416d:	83 bf 28 96 10 00 00 	cmpl   $0x0,0x109628(%edi)
  104174:	75 40                	jne    1041b6 <net_arp_prepare+0x179>
						 net_nbuf_ll_reserve(buf));
		hdr->type = htons(NET_ETH_PTYPE_IP);

		memcpy(&hdr->src.addr, ll->addr,
		       sizeof(struct net_eth_addr));
		memcpy(&hdr->dst.addr, &entry->eth.addr,
  104176:	8d 87 30 96 10 00    	lea    0x109630(%edi),%eax
	frag = buf->frags;
  10417c:	8b 33                	mov    (%ebx),%esi
		memcpy(&hdr->dst.addr, &entry->eth.addr,
  10417e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	while (frag) {
  104181:	e9 a6 00 00 00       	jmp    10422c <net_arp_prepare+0x1ef>
		if (!*free_entry && !arp_table[i].pending &&
  104186:	85 c0                	test   %eax,%eax
  104188:	75 12                	jne    10419c <net_arp_prepare+0x15f>
  10418a:	83 3d 40 96 10 00 00 	cmpl   $0x0,0x109640
  104191:	75 09                	jne    10419c <net_arp_prepare+0x15f>
  104193:	85 ff                	test   %edi,%edi
  104195:	75 05                	jne    10419c <net_arp_prepare+0x15f>
			*free_entry = &arp_table[i];
  104197:	b8 38 96 10 00       	mov    $0x109638,%eax
		if (!*non_pending && !arp_table[i].pending) {
  10419c:	85 c9                	test   %ecx,%ecx
  10419e:	75 0e                	jne    1041ae <net_arp_prepare+0x171>
  1041a0:	83 3d 40 96 10 00 00 	cmpl   $0x0,0x109640
  1041a7:	75 05                	jne    1041ae <net_arp_prepare+0x171>
			*non_pending = &arp_table[i];
  1041a9:	b9 38 96 10 00       	mov    $0x109638,%ecx
		if (!free_entry) {
  1041ae:	85 c0                	test   %eax,%eax
  1041b0:	75 1e                	jne    1041d0 <net_arp_prepare+0x193>
			if (!non_pending) {
  1041b2:	85 c9                	test   %ecx,%ecx
  1041b4:	75 1c                	jne    1041d2 <net_arp_prepare+0x195>
				req = prepare_arp(net_nbuf_iface(buf),
  1041b6:	31 c9                	xor    %ecx,%ecx
  1041b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041bb:	53                   	push   %ebx
  1041bc:	e8 0a fd ff ff       	call   103ecb <prepare_arp>
  1041c1:	89 c6                	mov    %eax,%esi
				net_nbuf_unref(buf);
  1041c3:	89 1c 24             	mov    %ebx,(%esp)
  1041c6:	e8 91 f1 ff ff       	call   10335c <net_nbuf_unref>
				return req;
  1041cb:	89 f3                	mov    %esi,%ebx
				net_nbuf_unref(buf);
  1041cd:	59                   	pop    %ecx
				return req;
  1041ce:	eb 64                	jmp    104234 <net_arp_prepare+0x1f7>
  1041d0:	89 c1                	mov    %eax,%ecx
		return prepare_arp(net_nbuf_iface(buf), addr, free_entry, buf);
  1041d2:	89 5d 08             	mov    %ebx,0x8(%ebp)
  1041d5:	8b 45 f0             	mov    -0x10(%ebp),%eax

		frag = frag->frags;
	}

	return buf;
}
  1041d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1041db:	5b                   	pop    %ebx
  1041dc:	5e                   	pop    %esi
  1041dd:	5f                   	pop    %edi
  1041de:	5d                   	pop    %ebp
		return prepare_arp(net_nbuf_iface(buf), addr, free_entry, buf);
  1041df:	e9 e7 fc ff ff       	jmp    103ecb <prepare_arp>
		if (!net_buf_headroom(frag)) {
  1041e4:	8d 46 10             	lea    0x10(%esi),%eax
  1041e7:	50                   	push   %eax
  1041e8:	e8 3c da ff ff       	call   101c29 <net_buf_simple_headroom>
  1041ed:	5a                   	pop    %edx
  1041ee:	85 c0                	test   %eax,%eax
  1041f0:	74 38                	je     10422a <net_arp_prepare+0x1ed>
	return ((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve;
  1041f2:	89 d8                	mov    %ebx,%eax
  1041f4:	e8 a9 da ff ff       	call   101ca2 <net_buf_user_data>
		hdr = (struct net_eth_hdr *)(frag->data -
  1041f9:	8b 7e 10             	mov    0x10(%esi),%edi
						 net_nbuf_ll_reserve(buf));
  1041fc:	0f b6 40 28          	movzbl 0x28(%eax),%eax
		hdr = (struct net_eth_hdr *)(frag->data -
  104200:	29 c7                	sub    %eax,%edi
		memcpy(&hdr->src.addr, ll->addr,
  104202:	8b 45 f0             	mov    -0x10(%ebp),%eax
		hdr->type = htons(NET_ETH_PTYPE_IP);
  104205:	66 c7 47 0c 08 00    	movw   $0x8,0xc(%edi)
		memcpy(&hdr->src.addr, ll->addr,
  10420b:	6a 06                	push   $0x6
  10420d:	ff 70 10             	pushl  0x10(%eax)
  104210:	8d 47 06             	lea    0x6(%edi),%eax
  104213:	50                   	push   %eax
  104214:	e8 54 d2 ff ff       	call   10146d <memcpy>
  104219:	83 c4 0c             	add    $0xc,%esp
		memcpy(&hdr->dst.addr, &entry->eth.addr,
  10421c:	6a 06                	push   $0x6
  10421e:	ff 75 ec             	pushl  -0x14(%ebp)
  104221:	57                   	push   %edi
  104222:	e8 46 d2 ff ff       	call   10146d <memcpy>
  104227:	83 c4 0c             	add    $0xc,%esp
		frag = frag->frags;
  10422a:	8b 36                	mov    (%esi),%esi
	while (frag) {
  10422c:	85 f6                	test   %esi,%esi
  10422e:	75 b4                	jne    1041e4 <net_arp_prepare+0x1a7>
  104230:	eb 02                	jmp    104234 <net_arp_prepare+0x1f7>
		return NULL;
  104232:	31 db                	xor    %ebx,%ebx
}
  104234:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104237:	89 d8                	mov    %ebx,%eax
  104239:	5b                   	pop    %ebx
  10423a:	5e                   	pop    %esi
  10423b:	5f                   	pop    %edi
  10423c:	5d                   	pop    %ebp
  10423d:	c3                   	ret    

0010423e <net_arp_input>:
	net_nbuf_unref(buf);
	return NULL;
}

enum net_verdict net_arp_input(struct net_buf *buf)
{
  10423e:	55                   	push   %ebp
  10423f:	89 e5                	mov    %esp,%ebp
  104241:	57                   	push   %edi
  104242:	56                   	push   %esi
  104243:	53                   	push   %ebx
  104244:	83 ec 10             	sub    $0x10,%esp
	size_t bytes = 0;
  104247:	31 ff                	xor    %edi,%edi
  104249:	8b 75 08             	mov    0x8(%ebp),%esi
  10424c:	89 f0                	mov    %esi,%eax
	while (buf) {
  10424e:	85 c0                	test   %eax,%eax
  104250:	74 0a                	je     10425c <net_arp_input+0x1e>
		bytes += buf->len;
  104252:	0f b7 50 14          	movzwl 0x14(%eax),%edx
		buf = buf->frags;
  104256:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  104258:	01 d7                	add    %edx,%edi
  10425a:	eb f2                	jmp    10424e <net_arp_input+0x10>
  10425c:	89 f0                	mov    %esi,%eax
  10425e:	e8 3f da ff ff       	call   101ca2 <net_buf_user_data>
	struct net_arp_hdr *arp_hdr;
	struct net_buf *reply;

	if (net_buf_frags_len(buf) < (sizeof(struct net_arp_hdr) -
				       net_nbuf_ll_reserve(buf))) {
  104263:	0f b6 50 28          	movzbl 0x28(%eax),%edx
	if (net_buf_frags_len(buf) < (sizeof(struct net_arp_hdr) -
  104267:	b8 1c 00 00 00       	mov    $0x1c,%eax
  10426c:	29 d0                	sub    %edx,%eax
  10426e:	39 f8                	cmp    %edi,%eax
  104270:	0f 87 0f 02 00 00    	ja     104485 <net_arp_input+0x247>
	return buf->frags->data;
  104276:	8b 06                	mov    (%esi),%eax
  104278:	8b 58 10             	mov    0x10(%eax),%ebx
		return NET_DROP;
	}

	arp_hdr = NET_ARP_BUF(buf);

	switch (ntohs(arp_hdr->opcode)) {
  10427b:	66 8b 43 06          	mov    0x6(%ebx),%ax
  10427f:	86 e0                	xchg   %ah,%al
  104281:	66 83 f8 01          	cmp    $0x1,%ax
  104285:	74 0f                	je     104296 <net_arp_input+0x58>
  104287:	66 83 f8 02          	cmp    $0x2,%ax
  10428b:	0f 84 36 01 00 00    	je     1043c7 <net_arp_input+0x189>
  104291:	e9 ef 01 00 00       	jmp    104485 <net_arp_input+0x247>
	case NET_ARP_REQUEST:
		/* Someone wants to know our ll address */
		if (!net_ipv4_addr_cmp(&arp_hdr->dst_ipaddr,
				       if_get_addr(net_nbuf_iface(buf)))) {
  104296:	89 f0                	mov    %esi,%eax
  104298:	e8 9e fb ff ff       	call   103e3b <net_nbuf_iface>
  10429d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1042a0:	e8 f7 fb ff ff       	call   103e9c <if_get_addr>
		if (!net_ipv4_addr_cmp(&arp_hdr->dst_ipaddr,
  1042a5:	8b 4b 18             	mov    0x18(%ebx),%ecx
  1042a8:	39 08                	cmp    %ecx,(%eax)
  1042aa:	0f 85 d5 01 00 00    	jne    104485 <net_arp_input+0x247>
	buf = net_nbuf_get_reserve_tx(0, K_FOREVER);
  1042b0:	6a ff                	push   $0xffffffff
  1042b2:	6a 00                	push   $0x0
  1042b4:	e8 51 f0 ff ff       	call   10330a <net_nbuf_get_reserve_tx>
  1042b9:	59                   	pop    %ecx
	if (!buf) {
  1042ba:	85 c0                	test   %eax,%eax
	buf = net_nbuf_get_reserve_tx(0, K_FOREVER);
  1042bc:	5b                   	pop    %ebx
  1042bd:	89 c3                	mov    %eax,%ebx
	if (!buf) {
  1042bf:	0f 84 b9 01 00 00    	je     10447e <net_arp_input+0x240>
	frag = net_nbuf_get_reserve_data(sizeof(struct net_eth_hdr),
  1042c5:	6a ff                	push   $0xffffffff
  1042c7:	6a 0e                	push   $0xe
  1042c9:	e8 51 f0 ff ff       	call   10331f <net_nbuf_get_reserve_data>
  1042ce:	5f                   	pop    %edi
  1042cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1042d2:	5a                   	pop    %edx
	if (!frag) {
  1042d3:	85 c0                	test   %eax,%eax
  1042d5:	0f 84 a3 01 00 00    	je     10447e <net_arp_input+0x240>
	net_buf_frag_add(buf, frag);
  1042db:	50                   	push   %eax
  1042dc:	53                   	push   %ebx
  1042dd:	e8 ac d8 ff ff       	call   101b8e <net_buf_frag_add>
	net_nbuf_set_iface(buf, iface);
  1042e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1042e5:	89 d8                	mov    %ebx,%eax
	net_buf_frag_add(buf, frag);
  1042e7:	59                   	pop    %ecx
  1042e8:	5f                   	pop    %edi
	net_nbuf_set_iface(buf, iface);
  1042e9:	e8 5a fb ff ff       	call   103e48 <net_nbuf_set_iface>
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  1042ee:	89 d8                	mov    %ebx,%eax
  1042f0:	e8 ad d9 ff ff       	call   101ca2 <net_buf_user_data>
  1042f5:	c6 40 29 02          	movb   $0x2,0x29(%eax)
	((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve = len;
  1042f9:	89 d8                	mov    %ebx,%eax
  1042fb:	e8 a2 d9 ff ff       	call   101ca2 <net_buf_user_data>
  104300:	c6 40 28 0e          	movb   $0xe,0x28(%eax)
	return buf->frags->data;
  104304:	8b 03                	mov    (%ebx),%eax
  104306:	8b 50 10             	mov    0x10(%eax),%edx
	eth = NET_ETH_BUF(buf);
  104309:	89 d8                	mov    %ebx,%eax
  10430b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10430e:	e8 a9 f7 ff ff       	call   103abc <net_nbuf_ll>
  104313:	89 c7                	mov    %eax,%edi
  104315:	8b 06                	mov    (%esi),%eax
  104317:	8b 48 10             	mov    0x10(%eax),%ecx
	eth_query = NET_ETH_BUF(req);
  10431a:	89 f0                	mov    %esi,%eax
  10431c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10431f:	e8 98 f7 ff ff       	call   103abc <net_nbuf_ll>
	eth->type = htons(NET_ETH_PTYPE_ARP);
  104324:	66 c7 47 0c 08 06    	movw   $0x608,0xc(%edi)
	memcpy(&eth->dst.addr, &eth_query->src.addr,
  10432a:	6a 06                	push   $0x6
  10432c:	8d 70 06             	lea    0x6(%eax),%esi
  10432f:	56                   	push   %esi
  104330:	57                   	push   %edi
  104331:	e8 37 d1 ff ff       	call   10146d <memcpy>
  104336:	83 c4 0c             	add    $0xc,%esp
	memcpy(&eth->src.addr, net_if_get_link_addr(iface)->addr,
  104339:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10433c:	6a 06                	push   $0x6
  10433e:	83 c7 06             	add    $0x6,%edi
  104341:	ff 70 10             	pushl  0x10(%eax)
  104344:	57                   	push   %edi
  104345:	e8 23 d1 ff ff       	call   10146d <memcpy>
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
  10434a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	memcpy(&eth->src.addr, net_if_get_link_addr(iface)->addr,
  10434d:	83 c4 0c             	add    $0xc,%esp
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
  104350:	89 55 f0             	mov    %edx,-0x10(%ebp)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
  104353:	66 c7 02 00 01       	movw   $0x100,(%edx)
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
  104358:	66 c7 42 02 08 00    	movw   $0x8,0x2(%edx)
	hdr->hwlen = sizeof(struct net_eth_addr);
  10435e:	c6 42 04 06          	movb   $0x6,0x4(%edx)
	hdr->protolen = sizeof(struct in_addr);
  104362:	c6 42 05 04          	movb   $0x4,0x5(%edx)
	hdr->opcode = htons(NET_ARP_REPLY);
  104366:	66 c7 42 06 00 02    	movw   $0x200,0x6(%edx)
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
  10436c:	8d 42 12             	lea    0x12(%edx),%eax
  10436f:	6a 06                	push   $0x6
  104371:	56                   	push   %esi
  104372:	50                   	push   %eax
  104373:	e8 f5 d0 ff ff       	call   10146d <memcpy>
	memcpy(&hdr->src_hwaddr.addr, &eth->src.addr,
  104378:	8b 55 f0             	mov    -0x10(%ebp),%edx
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
  10437b:	83 c4 0c             	add    $0xc,%esp
	memcpy(&hdr->src_hwaddr.addr, &eth->src.addr,
  10437e:	8d 42 08             	lea    0x8(%edx),%eax
  104381:	6a 06                	push   $0x6
  104383:	57                   	push   %edi
  104384:	50                   	push   %eax
  104385:	e8 e3 d0 ff ff       	call   10146d <memcpy>
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
  10438a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10438d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104390:	8b 41 0e             	mov    0xe(%ecx),%eax
	memcpy(&hdr->src_hwaddr.addr, &eth->src.addr,
  104393:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
  104396:	89 42 18             	mov    %eax,0x18(%edx)
	net_ipaddr_copy(&hdr->src_ipaddr, &query->dst_ipaddr);
  104399:	8b 41 18             	mov    0x18(%ecx),%eax
  10439c:	89 42 0e             	mov    %eax,0xe(%edx)
	net_buf_add(frag, sizeof(struct net_arp_hdr));
  10439f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1043a2:	83 c0 10             	add    $0x10,%eax
  1043a5:	6a 1c                	push   $0x1c
  1043a7:	50                   	push   %eax
  1043a8:	e8 38 d8 ff ff       	call   101be5 <net_buf_simple_add>
  1043ad:	58                   	pop    %eax
#endif /* CONFIG_NET_DEBUG_ARP */

		/* Send reply */
		reply = prepare_arp_reply(net_nbuf_iface(buf), buf);
		if (reply) {
			net_if_queue_tx(net_nbuf_iface(reply), reply);
  1043ae:	89 d8                	mov    %ebx,%eax
	net_buf_add(frag, sizeof(struct net_arp_hdr));
  1043b0:	5a                   	pop    %edx
			net_if_queue_tx(net_nbuf_iface(reply), reply);
  1043b1:	e8 85 fa ff ff       	call   103e3b <net_nbuf_iface>
  1043b6:	83 c0 1c             	add    $0x1c,%eax
  1043b9:	53                   	push   %ebx
  1043ba:	50                   	push   %eax
  1043bb:	e8 25 d7 ff ff       	call   101ae5 <net_buf_put>
  1043c0:	59                   	pop    %ecx
  1043c1:	5b                   	pop    %ebx
  1043c2:	e9 be 00 00 00       	jmp    104485 <net_arp_input+0x247>
		}
		break;

	case NET_ARP_REPLY:
		if (net_is_my_ipv4_addr(&arp_hdr->dst_ipaddr)) {
  1043c7:	8d 43 18             	lea    0x18(%ebx),%eax
	return net_if_ipv4_addr_lookup(addr, NULL) != NULL;
  1043ca:	6a 00                	push   $0x0
  1043cc:	50                   	push   %eax
  1043cd:	e8 01 dc ff ff       	call   101fd3 <net_if_ipv4_addr_lookup>
  1043d2:	5f                   	pop    %edi
  1043d3:	85 c0                	test   %eax,%eax
  1043d5:	5a                   	pop    %edx
  1043d6:	0f 84 a9 00 00 00    	je     104485 <net_arp_input+0x247>
			arp_update(net_nbuf_iface(buf), &arp_hdr->src_ipaddr,
  1043dc:	89 f0                	mov    %esi,%eax
  1043de:	e8 58 fa ff ff       	call   103e3b <net_nbuf_iface>
  1043e3:	89 c6                	mov    %eax,%esi
		if (arp_table[i].iface == iface &&
  1043e5:	39 05 24 96 10 00    	cmp    %eax,0x109624
  1043eb:	75 0a                	jne    1043f7 <net_arp_input+0x1b9>
  1043ed:	a1 2c 96 10 00       	mov    0x10962c,%eax
  1043f2:	39 43 0e             	cmp    %eax,0xe(%ebx)
  1043f5:	74 1e                	je     104415 <net_arp_input+0x1d7>
  1043f7:	3b 35 3c 96 10 00    	cmp    0x10963c,%esi
  1043fd:	0f 85 82 00 00 00    	jne    104485 <net_arp_input+0x247>
  104403:	8b 43 0e             	mov    0xe(%ebx),%eax
  104406:	39 05 44 96 10 00    	cmp    %eax,0x109644
  10440c:	75 77                	jne    104485 <net_arp_input+0x247>
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
  10440e:	b8 01 00 00 00       	mov    $0x1,%eax
  104413:	eb 02                	jmp    104417 <net_arp_input+0x1d9>
  104415:	31 c0                	xor    %eax,%eax
			if (arp_table[i].pending) {
  104417:	6b c0 18             	imul   $0x18,%eax,%eax
  10441a:	8d b8 20 96 10 00    	lea    0x109620(%eax),%edi
  104420:	83 b8 28 96 10 00 00 	cmpl   $0x0,0x109628(%eax)
  104427:	74 5c                	je     104485 <net_arp_input+0x247>
			arp_update(net_nbuf_iface(buf), &arp_hdr->src_ipaddr,
  104429:	83 c3 08             	add    $0x8,%ebx
				memcpy(&arp_table[i].eth, hwaddr,
  10442c:	05 30 96 10 00       	add    $0x109630,%eax
  104431:	6a 06                	push   $0x6
  104433:	53                   	push   %ebx
  104434:	50                   	push   %eax
  104435:	e8 33 d0 ff ff       	call   10146d <memcpy>
				net_nbuf_ll_dst(arp_table[i].pending)->len =
  10443a:	8b 5f 08             	mov    0x8(%edi),%ebx
				memcpy(&arp_table[i].eth, hwaddr,
  10443d:	83 c4 0c             	add    $0xc,%esp
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  104440:	89 d8                	mov    %ebx,%eax
  104442:	e8 5b d8 ff ff       	call   101ca2 <net_buf_user_data>
				net_nbuf_ll_dst(arp_table[i].pending)->len =
  104447:	c6 40 20 06          	movb   $0x6,0x20(%eax)
  10444b:	89 d8                	mov    %ebx,%eax
  10444d:	e8 50 d8 ff ff       	call   101ca2 <net_buf_user_data>
  104452:	89 45 f0             	mov    %eax,-0x10(%ebp)
					&NET_ETH_BUF(arp_table[i].pending)->dst.addr;
  104455:	89 d8                	mov    %ebx,%eax
  104457:	e8 60 f6 ff ff       	call   103abc <net_nbuf_ll>
				net_nbuf_ll_dst(arp_table[i].pending)->addr =
  10445c:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10445f:	89 42 1c             	mov    %eax,0x1c(%edx)
	*buf = NULL;
  104462:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	if (net_if_send_data(iface, pending) == NET_DROP) {
  104469:	53                   	push   %ebx
  10446a:	56                   	push   %esi
  10446b:	e8 46 dc ff ff       	call   1020b6 <net_if_send_data>
  104470:	59                   	pop    %ecx
  104471:	83 f8 02             	cmp    $0x2,%eax
  104474:	5e                   	pop    %esi
  104475:	75 07                	jne    10447e <net_arp_input+0x240>
		net_nbuf_unref(pending);
  104477:	53                   	push   %ebx
  104478:	e8 df ee ff ff       	call   10335c <net_nbuf_unref>
  10447d:	5a                   	pop    %edx
	net_nbuf_unref(pending);
  10447e:	53                   	push   %ebx
  10447f:	e8 d8 ee ff ff       	call   10335c <net_nbuf_unref>
  104484:	58                   	pop    %eax
		}
		break;
	}

	return NET_DROP;
}
  104485:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104488:	b8 02 00 00 00       	mov    $0x2,%eax
  10448d:	5b                   	pop    %ebx
  10448e:	5e                   	pop    %esi
  10448f:	5f                   	pop    %edi
  104490:	5d                   	pop    %ebp
  104491:	c3                   	ret    

00104492 <net_arp_init>:

void net_arp_init(void)
{
  104492:	55                   	push   %ebp
  104493:	89 e5                	mov    %esp,%ebp
	memset(&arp_table, 0, sizeof(arp_table));
  104495:	6a 30                	push   $0x30
  104497:	6a 00                	push   $0x0
  104499:	68 20 96 10 00       	push   $0x109620
  10449e:	e8 35 d0 ff ff       	call   1014d8 <memset>
  1044a3:	83 c4 0c             	add    $0xc,%esp
}
  1044a6:	c9                   	leave  
  1044a7:	c3                   	ret    

001044a8 <net_nbuf_icmp_data>:
{
  1044a8:	55                   	push   %ebp
  1044a9:	89 c1                	mov    %eax,%ecx
  1044ab:	89 e5                	mov    %esp,%ebp
	return ((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len;
  1044ad:	e8 00 d8 ff ff       	call   101cb2 <net_buf_user_data>
}
  1044b2:	5d                   	pop    %ebp
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1044b3:	0f b6 50 2a          	movzbl 0x2a(%eax),%edx
				 net_nbuf_ext_len(buf)];
  1044b7:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1044bb:	8b 09                	mov    (%ecx),%ecx
  1044bd:	01 d0                	add    %edx,%eax
  1044bf:	03 41 10             	add    0x10(%ecx),%eax
}
  1044c2:	c3                   	ret    

001044c3 <setup_ipv4_header>:
#define NET_ICMPV4_UNUSED_LEN 4

static inline void setup_ipv4_header(struct net_buf *buf, uint8_t extra_len,
				     uint8_t ttl, uint8_t icmp_type,
				     uint8_t icmp_code)
{
  1044c3:	55                   	push   %ebp
	NET_IPV4_BUF(buf)->vhl = 0x45;
	NET_IPV4_BUF(buf)->tos = 0x00;
	NET_IPV4_BUF(buf)->len[0] = 0;
	NET_IPV4_BUF(buf)->len[1] = sizeof(struct net_ipv4_hdr) +
		NET_ICMPH_LEN + extra_len + NET_ICMPV4_UNUSED_LEN;
  1044c4:	83 c2 1c             	add    $0x1c,%edx
{
  1044c7:	89 e5                	mov    %esp,%ebp
  1044c9:	57                   	push   %edi
  1044ca:	56                   	push   %esi
  1044cb:	53                   	push   %ebx
  1044cc:	53                   	push   %ebx
  1044cd:	89 c3                	mov    %eax,%ebx
  1044cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  1044d2:	8b 7d 08             	mov    0x8(%ebp),%edi
  1044d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return buf->frags->data;
  1044d8:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->vhl = 0x45;
  1044da:	8b 40 10             	mov    0x10(%eax),%eax
  1044dd:	c6 00 45             	movb   $0x45,(%eax)
  1044e0:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->tos = 0x00;
  1044e2:	8b 40 10             	mov    0x10(%eax),%eax
  1044e5:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  1044e9:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->len[0] = 0;
  1044eb:	8b 40 10             	mov    0x10(%eax),%eax
  1044ee:	c6 40 02 00          	movb   $0x0,0x2(%eax)
  1044f2:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->len[1] = sizeof(struct net_ipv4_hdr) +
  1044f4:	8b 40 10             	mov    0x10(%eax),%eax
		NET_ICMPH_LEN + extra_len + NET_ICMPV4_UNUSED_LEN;
  1044f7:	88 50 03             	mov    %dl,0x3(%eax)
  1044fa:	8b 03                	mov    (%ebx),%eax

	NET_IPV4_BUF(buf)->proto = IPPROTO_ICMP;
  1044fc:	8b 40 10             	mov    0x10(%eax),%eax
  1044ff:	c6 40 09 01          	movb   $0x1,0x9(%eax)
  104503:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->ttl = ttl;
  104505:	8b 40 10             	mov    0x10(%eax),%eax
  104508:	88 48 08             	mov    %cl,0x8(%eax)
  10450b:	8b 03                	mov    (%ebx),%eax
  10450d:	8b 40 10             	mov    0x10(%eax),%eax
	NET_IPV4_BUF(buf)->offset[0] = NET_IPV4_BUF(buf)->offset[1] = 0;
  104510:	c6 40 07 00          	movb   $0x0,0x7(%eax)
  104514:	c6 40 06 00          	movb   $0x0,0x6(%eax)
  104518:	8b 03                	mov    (%ebx),%eax
  10451a:	8b 40 10             	mov    0x10(%eax),%eax
	NET_IPV4_BUF(buf)->id[0] = NET_IPV4_BUF(buf)->id[1] = 0;
  10451d:	c6 40 05 00          	movb   $0x0,0x5(%eax)
  104521:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len = len;
  104525:	89 d8                	mov    %ebx,%eax
  104527:	e8 86 d7 ff ff       	call   101cb2 <net_buf_user_data>
  10452c:	c6 40 2a 14          	movb   $0x14,0x2a(%eax)
	return buf->frags->data;
  104530:	8b 03                	mov    (%ebx),%eax

	net_nbuf_set_ip_hdr_len(buf, sizeof(struct net_ipv4_hdr));

	NET_IPV4_BUF(buf)->chksum = 0;
  104532:	8b 40 10             	mov    0x10(%eax),%eax
  104535:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  10453b:	8b 03                	mov    (%ebx),%eax
  10453d:	8b 70 10             	mov    0x10(%eax),%esi
	NET_IPV4_BUF(buf)->chksum = ~net_calc_chksum_ipv4(buf);
  104540:	53                   	push   %ebx
  104541:	e8 fd f4 ff ff       	call   103a43 <net_calc_chksum_ipv4>
  104546:	5a                   	pop    %edx
  104547:	f7 d0                	not    %eax
  104549:	66 89 46 0a          	mov    %ax,0xa(%esi)

	NET_ICMP_BUF(buf)->type = icmp_type;
  10454d:	89 d8                	mov    %ebx,%eax
  10454f:	e8 54 ff ff ff       	call   1044a8 <net_nbuf_icmp_data>
  104554:	89 f9                	mov    %edi,%ecx
  104556:	88 08                	mov    %cl,(%eax)
	NET_ICMP_BUF(buf)->code = icmp_code;
  104558:	89 d8                	mov    %ebx,%eax
  10455a:	e8 49 ff ff ff       	call   1044a8 <net_nbuf_icmp_data>
  10455f:	8a 55 f0             	mov    -0x10(%ebp),%dl
  104562:	88 50 01             	mov    %dl,0x1(%eax)

	memset(net_nbuf_icmp_data(buf) + sizeof(struct net_icmp_hdr), 0,
  104565:	89 d8                	mov    %ebx,%eax
  104567:	e8 3c ff ff ff       	call   1044a8 <net_nbuf_icmp_data>
  10456c:	6a 04                	push   $0x4
  10456e:	83 c0 04             	add    $0x4,%eax
  104571:	6a 00                	push   $0x0
  104573:	50                   	push   %eax
  104574:	e8 5f cf ff ff       	call   1014d8 <memset>
  104579:	83 c4 0c             	add    $0xc,%esp
	       NET_ICMPV4_UNUSED_LEN);
}
  10457c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10457f:	5b                   	pop    %ebx
  104580:	5e                   	pop    %esi
  104581:	5f                   	pop    %edi
  104582:	5d                   	pop    %ebp
  104583:	c3                   	ret    

00104584 <net_icmpv4_input>:
	return -EIO;
}

enum net_verdict net_icmpv4_input(struct net_buf *buf, uint16_t len,
				  uint8_t type, uint8_t code)
{
  104584:	55                   	push   %ebp
	switch (type) {
	case NET_ICMPV4_ECHO_REQUEST:
		return handle_echo_request(buf);
	}

	return NET_DROP;
  104585:	b8 02 00 00 00       	mov    $0x2,%eax
{
  10458a:	89 e5                	mov    %esp,%ebp
  10458c:	56                   	push   %esi
  10458d:	53                   	push   %ebx
	switch (type) {
  10458e:	80 7d 10 08          	cmpb   $0x8,0x10(%ebp)
{
  104592:	8b 5d 08             	mov    0x8(%ebp),%ebx
	switch (type) {
  104595:	75 5d                	jne    1045f4 <net_icmpv4_input+0x70>
  104597:	8b 03                	mov    (%ebx),%eax
  104599:	8b 40 10             	mov    0x10(%eax),%eax
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->src,
  10459c:	8b 48 10             	mov    0x10(%eax),%ecx
	net_ipaddr_copy(&addr, &NET_IPV4_BUF(buf)->src);
  10459f:	8b 50 0c             	mov    0xc(%eax),%edx
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->src,
  1045a2:	89 48 0c             	mov    %ecx,0xc(%eax)
  1045a5:	8b 03                	mov    (%ebx),%eax
  1045a7:	8b 40 10             	mov    0x10(%eax),%eax
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->dst, &addr);
  1045aa:	89 50 10             	mov    %edx,0x10(%eax)
	NET_ICMP_BUF(buf)->type = NET_ICMPV4_ECHO_REPLY;
  1045ad:	89 d8                	mov    %ebx,%eax
  1045af:	e8 f4 fe ff ff       	call   1044a8 <net_nbuf_icmp_data>
  1045b4:	c6 00 00             	movb   $0x0,(%eax)
	NET_ICMP_BUF(buf)->code = 0;
  1045b7:	89 d8                	mov    %ebx,%eax
  1045b9:	e8 ea fe ff ff       	call   1044a8 <net_nbuf_icmp_data>
  1045be:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	NET_ICMP_BUF(buf)->chksum = 0;
  1045c2:	89 d8                	mov    %ebx,%eax
  1045c4:	e8 df fe ff ff       	call   1044a8 <net_nbuf_icmp_data>
  1045c9:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	NET_ICMP_BUF(buf)->chksum = ~net_calc_chksum_icmpv4(buf);
  1045cf:	89 d8                	mov    %ebx,%eax
  1045d1:	e8 d2 fe ff ff       	call   1044a8 <net_nbuf_icmp_data>
	return net_calc_chksum(buf, IPPROTO_ICMPV6);
}

static inline uint16_t net_calc_chksum_icmpv4(struct net_buf *buf)
{
	return net_calc_chksum(buf, IPPROTO_ICMP);
  1045d6:	6a 01                	push   $0x1
  1045d8:	89 c6                	mov    %eax,%esi
  1045da:	53                   	push   %ebx
  1045db:	e8 88 f3 ff ff       	call   103968 <net_calc_chksum>
  1045e0:	5a                   	pop    %edx
  1045e1:	f7 d0                	not    %eax
  1045e3:	59                   	pop    %ecx
  1045e4:	66 89 46 02          	mov    %ax,0x2(%esi)
	if (net_send_data(buf) < 0) {
  1045e8:	53                   	push   %ebx
  1045e9:	e8 72 d8 ff ff       	call   101e60 <net_send_data>
	return NET_OK;
  1045ee:	c1 e8 1f             	shr    $0x1f,%eax
	if (net_send_data(buf) < 0) {
  1045f1:	5b                   	pop    %ebx
	return NET_OK;
  1045f2:	01 c0                	add    %eax,%eax
}
  1045f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1045f7:	5b                   	pop    %ebx
  1045f8:	5e                   	pop    %esi
  1045f9:	5d                   	pop    %ebp
  1045fa:	c3                   	ret    

001045fb <net_icmpv4_send_error>:

int net_icmpv4_send_error(struct net_buf *orig, uint8_t type, uint8_t code)
{
  1045fb:	55                   	push   %ebp
  1045fc:	89 e5                	mov    %esp,%ebp
  1045fe:	57                   	push   %edi
  1045ff:	56                   	push   %esi
  104600:	53                   	push   %ebx
  104601:	83 ec 14             	sub    $0x14,%esp
  104604:	8b 45 0c             	mov    0xc(%ebp),%eax
  104607:	8b 75 08             	mov    0x8(%ebp),%esi
  10460a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10460d:	8b 45 10             	mov    0x10(%ebp),%eax
  104610:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  104613:	89 f0                	mov    %esi,%eax
  104615:	e8 98 d6 ff ff       	call   101cb2 <net_buf_user_data>
  10461a:	89 c3                	mov    %eax,%ebx
	return buf->frags->data;
  10461c:	8b 06                	mov    (%esi),%eax
	struct net_buf *buf, *frag;
	struct net_if *iface = net_nbuf_iface(orig);
	size_t extra_len, reserve;
	struct in_addr addr, *src, *dst;

	if (NET_IPV4_BUF(orig)->proto == IPPROTO_ICMP) {
  10461e:	8b 40 10             	mov    0x10(%eax),%eax
  104621:	80 78 09 01          	cmpb   $0x1,0x9(%eax)
  104625:	75 16                	jne    10463d <net_icmpv4_send_error+0x42>
		if (NET_ICMP_BUF(orig)->code < 8) {
  104627:	89 f0                	mov    %esi,%eax
  104629:	e8 7a fe ff ff       	call   1044a8 <net_nbuf_icmp_data>
			/* We must not send ICMP errors back */
			return -EINVAL;
  10462e:	ba ea ff ff ff       	mov    $0xffffffea,%edx
		if (NET_ICMP_BUF(orig)->code < 8) {
  104633:	80 78 01 07          	cmpb   $0x7,0x1(%eax)
  104637:	0f 86 82 01 00 00    	jbe    1047bf <net_icmpv4_send_error+0x1c4>
	return ((struct net_nbuf *)net_buf_user_data(buf))->iface;
  10463d:	8b 7b 08             	mov    0x8(%ebx),%edi
		}
	}

	iface = net_nbuf_iface(orig);

	buf = net_nbuf_get_reserve_tx(0, K_FOREVER);
  104640:	6a ff                	push   $0xffffffff
  104642:	6a 00                	push   $0x0
  104644:	e8 c1 ec ff ff       	call   10330a <net_nbuf_get_reserve_tx>
  104649:	5b                   	pop    %ebx
  10464a:	89 c3                	mov    %eax,%ebx
	return buf->frags->data;
  10464c:	8b 06                	mov    (%esi),%eax
  10464e:	5a                   	pop    %edx

	reserve = sizeof(struct net_ipv4_hdr) + sizeof(struct net_icmp_hdr) +
		NET_ICMPV4_UNUSED_LEN;

	if (NET_IPV4_BUF(orig)->proto == IPPROTO_UDP) {
		extra_len = sizeof(struct net_ipv4_hdr) +
  10464f:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
	if (NET_IPV4_BUF(orig)->proto == IPPROTO_UDP) {
  104656:	8b 40 10             	mov    0x10(%eax),%eax
  104659:	8a 40 09             	mov    0x9(%eax),%al
  10465c:	3c 11                	cmp    $0x11,%al
  10465e:	74 32                	je     104692 <net_icmpv4_send_error+0x97>
			sizeof(struct net_udp_hdr);
	} else if (NET_IPV4_BUF(orig)->proto == IPPROTO_TCP) {
		extra_len = sizeof(struct net_ipv4_hdr);
  104660:	c7 45 f0 14 00 00 00 	movl   $0x14,-0x10(%ebp)
	} else if (NET_IPV4_BUF(orig)->proto == IPPROTO_TCP) {
  104667:	3c 06                	cmp    $0x6,%al
  104669:	74 27                	je     104692 <net_icmpv4_send_error+0x97>
	return iface->l2->reserve(iface, (void *)dst_ip6);
  10466b:	8b 47 08             	mov    0x8(%edi),%eax
  10466e:	6a 00                	push   $0x0
  104670:	57                   	push   %edi
  104671:	ff 50 08             	call   *0x8(%eax)
  104674:	5a                   	pop    %edx
		/* FIXME, add TCP header length too */
	} else {
		size_t space = CONFIG_NET_NBUF_DATA_SIZE -
			net_if_get_ll_reserve(iface, NULL);
  104675:	0f b7 d0             	movzwl %ax,%edx
		size_t space = CONFIG_NET_NBUF_DATA_SIZE -
  104678:	b8 00 01 00 00       	mov    $0x100,%eax
  10467d:	59                   	pop    %ecx
  10467e:	29 d0                	sub    %edx,%eax

		if (reserve > space) {
			extra_len = 0;
  104680:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (reserve > space) {
  104687:	83 f8 1b             	cmp    $0x1b,%eax
  10468a:	76 06                	jbe    104692 <net_icmpv4_send_error+0x97>
		} else {
			extra_len = space - reserve;
  10468c:	83 e8 1c             	sub    $0x1c,%eax
  10468f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104692:	8b 06                	mov    (%esi),%eax
  104694:	8b 50 10             	mov    0x10(%eax),%edx
	dst = &NET_IPV4_BUF(orig)->dst;

	/* We only copy minimal IPv4 + next header from original message.
	 * This is so that the memory pressure is minimized.
	 */
	frag = net_nbuf_copy(orig->frags, extra_len, reserve, K_FOREVER);
  104697:	6a ff                	push   $0xffffffff
  104699:	6a 1c                	push   $0x1c
  10469b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10469e:	ff 75 f0             	pushl  -0x10(%ebp)
  1046a1:	50                   	push   %eax
  1046a2:	e8 e1 ec ff ff       	call   103388 <net_nbuf_copy>
  1046a7:	83 c4 10             	add    $0x10,%esp
	if (!frag) {
  1046aa:	85 c0                	test   %eax,%eax
  1046ac:	75 0c                	jne    1046ba <net_icmpv4_send_error+0xbf>
		net_stats_update_icmp_sent();
		return -EIO;
	}

drop:
	net_nbuf_unref(buf);
  1046ae:	53                   	push   %ebx
  1046af:	e8 a8 ec ff ff       	call   10335c <net_nbuf_unref>
  1046b4:	5f                   	pop    %edi
  1046b5:	e9 00 01 00 00       	jmp    1047ba <net_icmpv4_send_error+0x1bf>
	net_buf_frag_add(buf, frag);
  1046ba:	50                   	push   %eax
  1046bb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1046be:	53                   	push   %ebx
  1046bf:	e8 ca d4 ff ff       	call   101b8e <net_buf_frag_add>
  1046c4:	58                   	pop    %eax
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  1046c5:	89 d8                	mov    %ebx,%eax
  1046c7:	5a                   	pop    %edx
  1046c8:	e8 e5 d5 ff ff       	call   101cb2 <net_buf_user_data>
	net_nbuf_set_iface(buf, iface);
  1046cd:	89 fa                	mov    %edi,%edx
  1046cf:	c6 40 29 02          	movb   $0x2,0x29(%eax)
  1046d3:	89 d8                	mov    %ebx,%eax
  1046d5:	e8 98 f7 ff ff       	call   103e72 <net_nbuf_set_iface>
	net_nbuf_set_ll_reserve(buf, net_buf_headroom(frag));
  1046da:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1046dd:	83 c1 10             	add    $0x10,%ecx
  1046e0:	51                   	push   %ecx
  1046e1:	e8 43 d5 ff ff       	call   101c29 <net_buf_simple_headroom>
  1046e6:	59                   	pop    %ecx
  1046e7:	89 c1                	mov    %eax,%ecx
	((struct net_nbuf *) net_buf_user_data(buf))->ll_reserve = len;
  1046e9:	89 d8                	mov    %ebx,%eax
  1046eb:	e8 c2 d5 ff ff       	call   101cb2 <net_buf_user_data>
	setup_ipv4_header(buf, extra_len, net_if_ipv4_get_ttl(iface),
  1046f0:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
  1046f4:	88 48 28             	mov    %cl,0x28(%eax)
  1046f7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  1046fb:	0f b6 8f 30 05 00 00 	movzbl 0x530(%edi),%ecx
  104702:	50                   	push   %eax
  104703:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
  104707:	50                   	push   %eax
  104708:	89 d8                	mov    %ebx,%eax
  10470a:	e8 b4 fd ff ff       	call   1044c3 <setup_ipv4_header>
  10470f:	5f                   	pop    %edi
  104710:	58                   	pop    %eax
	net_ipaddr_copy(&addr, src);
  104711:	8b 45 ec             	mov    -0x14(%ebp),%eax
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->src, dst);
  104714:	8b 7d ec             	mov    -0x14(%ebp),%edi
	net_ipaddr_copy(&addr, src);
  104717:	8b 50 0c             	mov    0xc(%eax),%edx
	return buf->frags->data;
  10471a:	8b 03                	mov    (%ebx),%eax
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->src, dst);
  10471c:	8b 4f 10             	mov    0x10(%edi),%ecx
  10471f:	8b 40 10             	mov    0x10(%eax),%eax
  104722:	89 48 0c             	mov    %ecx,0xc(%eax)
  104725:	8b 03                	mov    (%ebx),%eax
  104727:	8b 40 10             	mov    0x10(%eax),%eax
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->dst, &addr);
  10472a:	89 50 10             	mov    %edx,0x10(%eax)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  10472d:	89 d8                	mov    %ebx,%eax
  10472f:	e8 7e d5 ff ff       	call   101cb2 <net_buf_user_data>
  104734:	89 c1                	mov    %eax,%ecx
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  104736:	89 f0                	mov    %esi,%eax
  104738:	e8 75 d5 ff ff       	call   101cb2 <net_buf_user_data>
	net_nbuf_ll_src(buf)->addr = net_nbuf_ll_dst(orig)->addr;
  10473d:	8b 40 1c             	mov    0x1c(%eax),%eax
  104740:	89 41 14             	mov    %eax,0x14(%ecx)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  104743:	89 d8                	mov    %ebx,%eax
  104745:	e8 68 d5 ff ff       	call   101cb2 <net_buf_user_data>
  10474a:	89 c1                	mov    %eax,%ecx
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  10474c:	89 f0                	mov    %esi,%eax
  10474e:	e8 5f d5 ff ff       	call   101cb2 <net_buf_user_data>
	net_nbuf_ll_src(buf)->len = net_nbuf_ll_dst(orig)->len;
  104753:	8a 40 20             	mov    0x20(%eax),%al
  104756:	88 41 18             	mov    %al,0x18(%ecx)
  104759:	89 d8                	mov    %ebx,%eax
  10475b:	e8 52 d5 ff ff       	call   101cb2 <net_buf_user_data>
  104760:	89 c1                	mov    %eax,%ecx
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  104762:	89 f0                	mov    %esi,%eax
  104764:	e8 49 d5 ff ff       	call   101cb2 <net_buf_user_data>
	net_nbuf_ll_dst(buf)->addr = net_nbuf_ll_src(orig)->addr;
  104769:	8b 40 14             	mov    0x14(%eax),%eax
  10476c:	89 41 1c             	mov    %eax,0x1c(%ecx)
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_dst;
  10476f:	89 d8                	mov    %ebx,%eax
  104771:	e8 3c d5 ff ff       	call   101cb2 <net_buf_user_data>
  104776:	89 c1                	mov    %eax,%ecx
	return &((struct net_nbuf *)net_buf_user_data(buf))->lladdr_src;
  104778:	89 f0                	mov    %esi,%eax
  10477a:	e8 33 d5 ff ff       	call   101cb2 <net_buf_user_data>
	net_nbuf_ll_dst(buf)->len = net_nbuf_ll_src(orig)->len;
  10477f:	8a 40 18             	mov    0x18(%eax),%al
  104782:	88 41 20             	mov    %al,0x20(%ecx)
	NET_ICMP_BUF(buf)->chksum = 0;
  104785:	89 d8                	mov    %ebx,%eax
  104787:	e8 1c fd ff ff       	call   1044a8 <net_nbuf_icmp_data>
  10478c:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	NET_ICMP_BUF(buf)->chksum = ~net_calc_chksum_icmpv4(buf);
  104792:	89 d8                	mov    %ebx,%eax
  104794:	e8 0f fd ff ff       	call   1044a8 <net_nbuf_icmp_data>
  104799:	6a 01                	push   $0x1
  10479b:	89 c6                	mov    %eax,%esi
  10479d:	53                   	push   %ebx
  10479e:	e8 c5 f1 ff ff       	call   103968 <net_calc_chksum>
  1047a3:	5a                   	pop    %edx
  1047a4:	f7 d0                	not    %eax
  1047a6:	59                   	pop    %ecx
  1047a7:	66 89 46 02          	mov    %ax,0x2(%esi)
	if (net_send_data(buf) >= 0) {
  1047ab:	53                   	push   %ebx
  1047ac:	e8 af d6 ff ff       	call   101e60 <net_send_data>
  1047b1:	5e                   	pop    %esi
  1047b2:	85 c0                	test   %eax,%eax
  1047b4:	0f 88 f4 fe ff ff    	js     1046ae <net_icmpv4_send_error+0xb3>
		return -EIO;
  1047ba:	ba fb ff ff ff       	mov    $0xfffffffb,%edx

	/* Note that we always return < 0 so that the caller knows to
	 * discard the original buffer.
	 */
	return -EIO;
}
  1047bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1047c2:	89 d0                	mov    %edx,%eax
  1047c4:	5b                   	pop    %ebx
  1047c5:	5e                   	pop    %esi
  1047c6:	5f                   	pop    %edi
  1047c7:	5d                   	pop    %ebp
  1047c8:	c3                   	ret    

001047c9 <net_ipv4_create_raw>:
				    uint16_t reserve,
				    const struct in_addr *src,
				    const struct in_addr *dst,
				    struct net_if *iface,
				    uint8_t next_header)
{
  1047c9:	55                   	push   %ebp
  1047ca:	89 e5                	mov    %esp,%ebp
  1047cc:	57                   	push   %edi
  1047cd:	56                   	push   %esi
  1047ce:	53                   	push   %ebx
	struct net_buf *header;

	header = net_nbuf_get_reserve_data(reserve, K_FOREVER);
  1047cf:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
{
  1047d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	header = net_nbuf_get_reserve_data(reserve, K_FOREVER);
  1047d6:	6a ff                	push   $0xffffffff
{
  1047d8:	8b 7d 1c             	mov    0x1c(%ebp),%edi
	header = net_nbuf_get_reserve_data(reserve, K_FOREVER);
  1047db:	50                   	push   %eax
  1047dc:	e8 3e eb ff ff       	call   10331f <net_nbuf_get_reserve_data>
  1047e1:	5a                   	pop    %edx
  1047e2:	89 c6                	mov    %eax,%esi
  1047e4:	59                   	pop    %ecx

	net_buf_frag_insert(buf, header);
  1047e5:	50                   	push   %eax
  1047e6:	53                   	push   %ebx
  1047e7:	e8 7d d3 ff ff       	call   101b69 <net_buf_frag_insert>
  1047ec:	58                   	pop    %eax
	return buf->frags->data;
  1047ed:	8b 03                	mov    (%ebx),%eax
  1047ef:	5a                   	pop    %edx
	NET_IPV4_BUF(buf)->id[0] = NET_IPV4_BUF(buf)->id[1] = 0;

	net_ipaddr_copy(&NET_IPV4_BUF(buf)->dst, dst);
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->src, src);

	NET_IPV4_BUF(buf)->proto = next_header;
  1047f0:	89 f9                	mov    %edi,%ecx

	net_nbuf_set_ip_hdr_len(buf, sizeof(struct net_ipv4_hdr));
	net_nbuf_set_family(buf, AF_INET);

	net_buf_add(header, sizeof(struct net_ipv4_hdr));
  1047f2:	83 c6 10             	add    $0x10,%esi
	NET_IPV4_BUF(buf)->vhl = 0x45;
  1047f5:	8b 40 10             	mov    0x10(%eax),%eax
  1047f8:	c6 00 45             	movb   $0x45,(%eax)
  1047fb:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->tos = 0x00;
  1047fd:	8b 40 10             	mov    0x10(%eax),%eax
  104800:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  104804:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->proto = 0;
  104806:	8b 40 10             	mov    0x10(%eax),%eax
  104809:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  10480d:	8b 45 18             	mov    0x18(%ebp),%eax
  104810:	8a 90 30 05 00 00    	mov    0x530(%eax),%dl
  104816:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->ttl = net_if_ipv4_get_ttl(iface);
  104818:	8b 40 10             	mov    0x10(%eax),%eax
  10481b:	88 50 08             	mov    %dl,0x8(%eax)
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->dst, dst);
  10481e:	8b 55 14             	mov    0x14(%ebp),%edx
  104821:	8b 03                	mov    (%ebx),%eax
  104823:	8b 40 10             	mov    0x10(%eax),%eax
	NET_IPV4_BUF(buf)->offset[0] = NET_IPV4_BUF(buf)->offset[1] = 0;
  104826:	c6 40 07 00          	movb   $0x0,0x7(%eax)
  10482a:	c6 40 06 00          	movb   $0x0,0x6(%eax)
  10482e:	8b 03                	mov    (%ebx),%eax
  104830:	8b 40 10             	mov    0x10(%eax),%eax
	NET_IPV4_BUF(buf)->id[0] = NET_IPV4_BUF(buf)->id[1] = 0;
  104833:	c6 40 05 00          	movb   $0x0,0x5(%eax)
  104837:	c6 40 04 00          	movb   $0x0,0x4(%eax)
  10483b:	8b 03                	mov    (%ebx),%eax
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->dst, dst);
  10483d:	8b 12                	mov    (%edx),%edx
  10483f:	8b 40 10             	mov    0x10(%eax),%eax
  104842:	89 50 10             	mov    %edx,0x10(%eax)
	net_ipaddr_copy(&NET_IPV4_BUF(buf)->src, src);
  104845:	8b 55 10             	mov    0x10(%ebp),%edx
  104848:	8b 03                	mov    (%ebx),%eax
  10484a:	8b 40 10             	mov    0x10(%eax),%eax
  10484d:	8b 12                	mov    (%edx),%edx
  10484f:	89 50 0c             	mov    %edx,0xc(%eax)
  104852:	8b 03                	mov    (%ebx),%eax
	NET_IPV4_BUF(buf)->proto = next_header;
  104854:	8b 40 10             	mov    0x10(%eax),%eax
  104857:	88 48 09             	mov    %cl,0x9(%eax)
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  10485a:	0f b7 43 16          	movzwl 0x16(%ebx),%eax
  10485e:	8d 44 03 1b          	lea    0x1b(%ebx,%eax,1),%eax
  104862:	83 e0 fc             	and    $0xfffffffc,%eax
	((struct net_nbuf *) net_buf_user_data(buf))->ip_hdr_len = len;
  104865:	c6 40 2a 14          	movb   $0x14,0x2a(%eax)
	((struct net_nbuf *)net_buf_user_data(buf))->family = family;
  104869:	c6 40 29 02          	movb   $0x2,0x29(%eax)
	net_buf_add(header, sizeof(struct net_ipv4_hdr));
  10486d:	6a 14                	push   $0x14
  10486f:	56                   	push   %esi
  104870:	e8 70 d3 ff ff       	call   101be5 <net_buf_simple_add>
  104875:	59                   	pop    %ecx
  104876:	5e                   	pop    %esi

	return buf;
}
  104877:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10487a:	89 d8                	mov    %ebx,%eax
  10487c:	5b                   	pop    %ebx
  10487d:	5e                   	pop    %esi
  10487e:	5f                   	pop    %edi
  10487f:	5d                   	pop    %ebp
  104880:	c3                   	ret    

00104881 <net_ipv4_create>:

struct net_buf *net_ipv4_create(struct net_context *context,
				struct net_buf *buf,
				const struct in_addr *src,
				const struct in_addr *dst)
{
  104881:	55                   	push   %ebp
  104882:	89 e5                	mov    %esp,%ebp
  104884:	57                   	push   %edi
  104885:	56                   	push   %esi
  104886:	53                   	push   %ebx
  104887:	50                   	push   %eax
  104888:	8b 5d 10             	mov    0x10(%ebp),%ebx
  10488b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10488e:	8b 7d 0c             	mov    0xc(%ebp),%edi
	NET_ASSERT(((struct sockaddr_in_ptr *)&context->local)->sin_addr);

	if (!src) {
  104891:	85 db                	test   %ebx,%ebx
  104893:	75 03                	jne    104898 <net_ipv4_create+0x17>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
  104895:	8b 59 08             	mov    0x8(%ecx),%ebx
	return addr->s_addr[0] == 0;
  104898:	8b 03                	mov    (%ebx),%eax
  10489a:	8d 57 18             	lea    0x18(%edi),%edx
	}

	if (net_is_ipv4_addr_unspecified(src)
  10489d:	85 c0                	test   %eax,%eax
  10489f:	74 0c                	je     1048ad <net_ipv4_create+0x2c>
	return (addr->s_addr[0] & 0xE0000000) == 0xE0000000;
  1048a1:	25 00 00 00 e0       	and    $0xe0000000,%eax
	    || net_is_ipv4_addr_mcast(src)) {
  1048a6:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
  1048ab:	75 14                	jne    1048c1 <net_ipv4_create+0x40>
  1048ad:	0f b7 47 16          	movzwl 0x16(%edi),%eax
  1048b1:	8d 44 02 03          	lea    0x3(%edx,%eax,1),%eax
  1048b5:	83 e0 fc             	and    $0xfffffffc,%eax
		src = &net_nbuf_iface(buf)->ipv4.unicast[0].address.in_addr;
  1048b8:	8b 58 08             	mov    0x8(%eax),%ebx
  1048bb:	81 c3 e4 04 00 00    	add    $0x4e4,%ebx
	if (context->flags & NET_CONTEXT_PROTO) {
  1048c1:	8a 41 39             	mov    0x39(%ecx),%al
  1048c4:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1048c7:	83 e0 40             	and    $0x40,%eax
	return IPPROTO_UDP;
  1048ca:	3c 01                	cmp    $0x1,%al
	return net_if_get_by_index(context->iface);
  1048cc:	0f b6 41 38          	movzbl 0x38(%ecx),%eax
	return IPPROTO_UDP;
  1048d0:	19 f6                	sbb    %esi,%esi
	return net_if_get_by_index(context->iface);
  1048d2:	50                   	push   %eax
  1048d3:	e8 99 d8 ff ff       	call   102171 <net_if_get_by_index>
	return IPPROTO_UDP;
  1048d8:	83 e6 0b             	and    $0xb,%esi
  1048db:	83 c6 06             	add    $0x6,%esi
  1048de:	8b 55 f0             	mov    -0x10(%ebp),%edx
	}

	return net_ipv4_create_raw(buf,
  1048e1:	89 34 24             	mov    %esi,(%esp)
  1048e4:	50                   	push   %eax
  1048e5:	ff 75 14             	pushl  0x14(%ebp)
  1048e8:	53                   	push   %ebx
  1048e9:	0f b7 47 16          	movzwl 0x16(%edi),%eax
  1048ed:	8d 44 02 03          	lea    0x3(%edx,%eax,1),%eax
  1048f1:	83 e0 fc             	and    $0xfffffffc,%eax
  1048f4:	0f b6 40 28          	movzbl 0x28(%eax),%eax
  1048f8:	50                   	push   %eax
  1048f9:	57                   	push   %edi
  1048fa:	e8 ca fe ff ff       	call   1047c9 <net_ipv4_create_raw>
  1048ff:	83 c4 18             	add    $0x18,%esp
				   net_nbuf_ll_reserve(buf),
				   src,
				   dst,
				   net_context_get_iface(context),
				   net_context_get_ip_proto(context));
}
  104902:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104905:	5b                   	pop    %ebx
  104906:	5e                   	pop    %esi
  104907:	5f                   	pop    %edi
  104908:	5d                   	pop    %ebp
  104909:	c3                   	ret    

0010490a <net_ipv4_finalize_raw>:

struct net_buf *net_ipv4_finalize_raw(struct net_buf *buf,
				      uint8_t next_header)
{
  10490a:	55                   	push   %ebp
  10490b:	89 e5                	mov    %esp,%ebp
  10490d:	57                   	push   %edi
  10490e:	56                   	push   %esi
  10490f:	53                   	push   %ebx
  104910:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104913:	8b 45 0c             	mov    0xc(%ebp),%eax
	/* Set the length of the IPv4 header */
	size_t total_len;

	net_nbuf_compact(buf);
  104916:	53                   	push   %ebx
{
  104917:	89 c7                	mov    %eax,%edi
	net_nbuf_compact(buf);
  104919:	e8 46 ec ff ff       	call   103564 <net_nbuf_compact>

	total_len = net_buf_frags_len(buf->frags);
  10491e:	8b 0b                	mov    (%ebx),%ecx
	net_nbuf_compact(buf);
  104920:	5e                   	pop    %esi
	total_len = net_buf_frags_len(buf->frags);
  104921:	89 ca                	mov    %ecx,%edx
	size_t bytes = 0;
  104923:	31 c0                	xor    %eax,%eax
	while (buf) {
  104925:	85 d2                	test   %edx,%edx
  104927:	74 0a                	je     104933 <net_ipv4_finalize_raw+0x29>
		bytes += buf->len;
  104929:	0f b7 72 14          	movzwl 0x14(%edx),%esi
		buf = buf->frags;
  10492d:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
  10492f:	01 f0                	add    %esi,%eax
  104931:	eb f2                	jmp    104925 <net_ipv4_finalize_raw+0x1b>

	NET_IPV4_BUF(buf)->len[0] = total_len / 256;
  104933:	8b 51 10             	mov    0x10(%ecx),%edx
  104936:	89 c1                	mov    %eax,%ecx
  104938:	c1 e9 08             	shr    $0x8,%ecx
  10493b:	88 4a 02             	mov    %cl,0x2(%edx)
	return buf->frags->data;
  10493e:	8b 13                	mov    (%ebx),%edx
	NET_IPV4_BUF(buf)->len[1] = total_len - NET_IPV4_BUF(buf)->len[0] * 256;
  104940:	8b 52 10             	mov    0x10(%edx),%edx
  104943:	88 42 03             	mov    %al,0x3(%edx)
  104946:	8b 03                	mov    (%ebx),%eax

	NET_IPV4_BUF(buf)->chksum = 0;
  104948:	8b 40 10             	mov    0x10(%eax),%eax
  10494b:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  104951:	8b 03                	mov    (%ebx),%eax
  104953:	8b 70 10             	mov    0x10(%eax),%esi
	NET_IPV4_BUF(buf)->chksum = ~net_calc_chksum_ipv4(buf);
  104956:	53                   	push   %ebx
  104957:	e8 e7 f0 ff ff       	call   103a43 <net_calc_chksum_ipv4>
  10495c:	59                   	pop    %ecx
  10495d:	f7 d0                	not    %eax
  10495f:	66 89 46 0a          	mov    %ax,0xa(%esi)

#if defined(CONFIG_NET_UDP)
	if (next_header == IPPROTO_UDP) {
  104963:	89 f8                	mov    %edi,%eax
  104965:	3c 11                	cmp    $0x11,%al
  104967:	75 28                	jne    104991 <net_ipv4_finalize_raw+0x87>
		NET_UDP_BUF(buf)->chksum = 0;
  104969:	89 d8                	mov    %ebx,%eax
  10496b:	e8 1b db ff ff       	call   10248b <net_nbuf_tcp_data>
  104970:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
		NET_UDP_BUF(buf)->chksum = ~net_calc_chksum_udp(buf);
  104976:	89 d8                	mov    %ebx,%eax
  104978:	e8 0e db ff ff       	call   10248b <net_nbuf_tcp_data>
}

static inline uint16_t net_calc_chksum_udp(struct net_buf *buf)
{
	return net_calc_chksum(buf, IPPROTO_UDP);
  10497d:	6a 11                	push   $0x11
  10497f:	89 c6                	mov    %eax,%esi
  104981:	53                   	push   %ebx
  104982:	e8 e1 ef ff ff       	call   103968 <net_calc_chksum>
  104987:	5f                   	pop    %edi
  104988:	f7 d0                	not    %eax
  10498a:	5a                   	pop    %edx
  10498b:	66 89 46 06          	mov    %ax,0x6(%esi)
  10498f:	eb 2c                	jmp    1049bd <net_ipv4_finalize_raw+0xb3>
	}
#endif
#if defined(CONFIG_NET_TCP)
	if (next_header == IPPROTO_TCP) {
  104991:	89 f8                	mov    %edi,%eax
  104993:	3c 06                	cmp    $0x6,%al
  104995:	75 26                	jne    1049bd <net_ipv4_finalize_raw+0xb3>
		NET_TCP_BUF(buf)->chksum = 0;
  104997:	89 d8                	mov    %ebx,%eax
  104999:	e8 ed da ff ff       	call   10248b <net_nbuf_tcp_data>
  10499e:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
		NET_TCP_BUF(buf)->chksum = ~net_calc_chksum_tcp(buf);
  1049a4:	89 d8                	mov    %ebx,%eax
  1049a6:	e8 e0 da ff ff       	call   10248b <net_nbuf_tcp_data>
}

static inline uint16_t net_calc_chksum_tcp(struct net_buf *buf)
{
	return net_calc_chksum(buf, IPPROTO_TCP);
  1049ab:	6a 06                	push   $0x6
  1049ad:	89 c6                	mov    %eax,%esi
  1049af:	53                   	push   %ebx
  1049b0:	e8 b3 ef ff ff       	call   103968 <net_calc_chksum>
  1049b5:	5a                   	pop    %edx
  1049b6:	f7 d0                	not    %eax
  1049b8:	59                   	pop    %ecx
  1049b9:	66 89 46 10          	mov    %ax,0x10(%esi)
	}
#endif

	return buf;
}
  1049bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1049c0:	89 d8                	mov    %ebx,%eax
  1049c2:	5b                   	pop    %ebx
  1049c3:	5e                   	pop    %esi
  1049c4:	5f                   	pop    %edi
  1049c5:	5d                   	pop    %ebp
  1049c6:	c3                   	ret    

001049c7 <net_ipv4_finalize>:

struct net_buf *net_ipv4_finalize(struct net_context *context,
				  struct net_buf *buf)
{
  1049c7:	55                   	push   %ebp
  1049c8:	89 e5                	mov    %esp,%ebp
	if (context->flags & NET_CONTEXT_PROTO) {
  1049ca:	8b 45 08             	mov    0x8(%ebp),%eax
  1049cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  1049d0:	8a 40 39             	mov    0x39(%eax),%al
	return net_ipv4_finalize_raw(buf,
  1049d3:	89 55 08             	mov    %edx,0x8(%ebp)
  1049d6:	83 e0 40             	and    $0x40,%eax
	return IPPROTO_UDP;
  1049d9:	3c 01                	cmp    $0x1,%al
  1049db:	19 c0                	sbb    %eax,%eax
  1049dd:	83 e0 0b             	and    $0xb,%eax
  1049e0:	83 c0 06             	add    $0x6,%eax
  1049e3:	89 45 0c             	mov    %eax,0xc(%ebp)
				     net_context_get_ip_proto(context));
}
  1049e6:	5d                   	pop    %ebp
	return net_ipv4_finalize_raw(buf,
  1049e7:	e9 1e ff ff ff       	jmp    10490a <net_ipv4_finalize_raw>

001049ec <net_ipv4_unspecified_address>:

const struct in_addr *net_ipv4_unspecified_address(void)
{
  1049ec:	55                   	push   %ebp
	static const struct in_addr addr;

	return &addr;
}
  1049ed:	b8 50 96 10 00       	mov    $0x109650,%eax
{
  1049f2:	89 e5                	mov    %esp,%ebp
}
  1049f4:	5d                   	pop    %ebp
  1049f5:	c3                   	ret    

001049f6 <net_ipv4_broadcast_address>:

const struct in_addr *net_ipv4_broadcast_address(void)
{
  1049f6:	55                   	push   %ebp
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
  1049f7:	b8 6c 81 10 00       	mov    $0x10816c,%eax
{
  1049fc:	89 e5                	mov    %esp,%ebp
}
  1049fe:	5d                   	pop    %ebp
  1049ff:	c3                   	ret    

00104a00 <prepare_segment.isra.7>:
#endif
	{
	}
}

static struct net_buf *prepare_segment(struct net_tcp *tcp,
  104a00:	55                   	push   %ebp
  104a01:	89 e5                	mov    %esp,%ebp
  104a03:	57                   	push   %edi
  104a04:	56                   	push   %esi
  104a05:	53                   	push   %ebx
  104a06:	83 ec 18             	sub    $0x18,%esp
  104a09:	89 d7                	mov    %edx,%edi
  104a0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104a0e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	struct net_context *context = tcp->context;
	uint16_t dst_port, src_port;

	NET_ASSERT(context);

	if (buf) {
  104a11:	85 c9                	test   %ecx,%ecx
  104a13:	74 0f                	je     104a24 <prepare_segment.isra.7+0x24>
		/* TCP transmit data comes in with a pre-allocated
		 * nbuf at the head (so that net_context_send can find
		 * the context), and the data after.  Rejigger so we
		 * can insert a TCP header cleanly
		 */
		tail = buf->frags;
  104a15:	8b 01                	mov    (%ecx),%eax
		buf->frags = NULL;
  104a17:	89 ce                	mov    %ecx,%esi
  104a19:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		tail = buf->frags;
  104a1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104a22:	eb 0e                	jmp    104a32 <prepare_segment.isra.7+0x32>
	} else {
		buf = net_nbuf_get_tx(context, K_FOREVER);
  104a24:	6a ff                	push   $0xffffffff
  104a26:	ff 75 ec             	pushl  -0x14(%ebp)
  104a29:	e8 06 e9 ff ff       	call   103334 <net_nbuf_get_tx>
  104a2e:	5e                   	pop    %esi
  104a2f:	89 c6                	mov    %eax,%esi
  104a31:	5a                   	pop    %edx
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  104a32:	8d 46 18             	lea    0x18(%esi),%eax
  104a35:	8d 4e 18             	lea    0x18(%esi),%ecx
  104a38:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104a3b:	0f b7 46 16          	movzwl 0x16(%esi),%eax
  104a3f:	8d 44 01 03          	lea    0x3(%ecx,%eax,1),%eax
  104a43:	83 e0 fc             	and    $0xfffffffc,%eax
	}

#if defined(CONFIG_NET_IPV4)
	if (net_nbuf_family(buf) == AF_INET) {
  104a46:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  104a4a:	75 6a                	jne    104ab6 <prepare_segment.isra.7+0xb6>
		net_ipv4_create(context, buf,
				net_sin_ptr(segment->src_addr)->sin_addr,
				&(net_sin(segment->dst_addr)->sin_addr));
  104a4c:	8b 47 14             	mov    0x14(%edi),%eax
  104a4f:	83 c0 04             	add    $0x4,%eax
		net_ipv4_create(context, buf,
  104a52:	50                   	push   %eax
				net_sin_ptr(segment->src_addr)->sin_addr,
  104a53:	8b 47 10             	mov    0x10(%edi),%eax
		net_ipv4_create(context, buf,
  104a56:	ff 70 04             	pushl  0x4(%eax)
  104a59:	56                   	push   %esi
  104a5a:	ff 75 ec             	pushl  -0x14(%ebp)
  104a5d:	e8 1f fe ff ff       	call   104881 <net_ipv4_create>
		dst_port = net_sin(segment->dst_addr)->sin_port;
  104a62:	8b 47 14             	mov    0x14(%edi),%eax
  104a65:	66 8b 40 02          	mov    0x2(%eax),%ax
		net_ipv4_create(context, buf,
  104a69:	83 c4 10             	add    $0x10,%esp
		dst_port = net_sin(segment->dst_addr)->sin_port;
  104a6c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
		src_port = ((struct sockaddr_in_ptr *)&context->local)->
  104a70:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104a73:	66 8b 40 06          	mov    0x6(%eax),%ax
  104a77:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  104a7b:	8b 06                	mov    (%esi),%eax
								sin_port;
		NET_IPV4_BUF(buf)->proto = IPPROTO_TCP;
  104a7d:	8b 40 10             	mov    0x10(%eax),%eax
  104a80:	c6 40 09 06          	movb   $0x6,0x9(%eax)
			net_nbuf_family(buf));
		net_nbuf_unref(buf);
		return NULL;
	}

	header = net_nbuf_get_data(context, K_FOREVER);
  104a84:	6a ff                	push   $0xffffffff
  104a86:	ff 75 ec             	pushl  -0x14(%ebp)
  104a89:	e8 ba e8 ff ff       	call   103348 <net_nbuf_get_data>
  104a8e:	5a                   	pop    %edx
  104a8f:	89 c3                	mov    %eax,%ebx
  104a91:	59                   	pop    %ecx
	net_buf_frag_add(buf, header);
  104a92:	50                   	push   %eax
  104a93:	56                   	push   %esi
  104a94:	e8 f5 d0 ff ff       	call   101b8e <net_buf_frag_add>
  104a99:	58                   	pop    %eax

	tcphdr = (struct net_tcp_hdr *)net_buf_add(header, NET_TCPH_LEN);
  104a9a:	8d 43 10             	lea    0x10(%ebx),%eax
	net_buf_frag_add(buf, header);
  104a9d:	5a                   	pop    %edx
	tcphdr = (struct net_tcp_hdr *)net_buf_add(header, NET_TCPH_LEN);
  104a9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104aa1:	6a 14                	push   $0x14
  104aa3:	50                   	push   %eax
  104aa4:	e8 3c d1 ff ff       	call   101be5 <net_buf_simple_add>
  104aa9:	59                   	pop    %ecx

	if (segment->options && segment->optlen) {
  104aaa:	8b 4f 0c             	mov    0xc(%edi),%ecx
	tcphdr = (struct net_tcp_hdr *)net_buf_add(header, NET_TCPH_LEN);
  104aad:	5b                   	pop    %ebx
	if (segment->options && segment->optlen) {
  104aae:	85 c9                	test   %ecx,%ecx
	tcphdr = (struct net_tcp_hdr *)net_buf_add(header, NET_TCPH_LEN);
  104ab0:	89 c3                	mov    %eax,%ebx
	if (segment->options && segment->optlen) {
  104ab2:	75 10                	jne    104ac4 <prepare_segment.isra.7+0xc4>
  104ab4:	eb 3a                	jmp    104af0 <prepare_segment.isra.7+0xf0>
		net_nbuf_unref(buf);
  104ab6:	56                   	push   %esi
		return NULL;
  104ab7:	31 f6                	xor    %esi,%esi
		net_nbuf_unref(buf);
  104ab9:	e8 9e e8 ff ff       	call   10335c <net_nbuf_unref>
  104abe:	5b                   	pop    %ebx
  104abf:	e9 ca 00 00 00       	jmp    104b8e <prepare_segment.isra.7+0x18e>
	if (segment->options && segment->optlen) {
  104ac4:	0f b6 57 0b          	movzbl 0xb(%edi),%edx
  104ac8:	84 d2                	test   %dl,%dl
  104aca:	74 24                	je     104af0 <prepare_segment.isra.7+0xf0>
	memcpy(net_buf_add(header, len), data, len);
  104acc:	52                   	push   %edx
  104acd:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  104ad0:	ff 75 e8             	pushl  -0x18(%ebp)
  104ad3:	89 55 e0             	mov    %edx,-0x20(%ebp)
  104ad6:	e8 0a d1 ff ff       	call   101be5 <net_buf_simple_add>
  104adb:	5a                   	pop    %edx
  104adc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  104adf:	59                   	pop    %ecx
  104ae0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  104ae3:	52                   	push   %edx
  104ae4:	51                   	push   %ecx
  104ae5:	50                   	push   %eax
  104ae6:	e8 82 c9 ff ff       	call   10146d <memcpy>
  104aeb:	83 c4 0c             	add    $0xc,%esp
  104aee:	eb 04                	jmp    104af4 <prepare_segment.isra.7+0xf4>
		net_tcp_add_options(header, segment->optlen, segment->options);
	} else {
		tcphdr->offset = NET_TCPH_LEN << 2;
  104af0:	c6 43 0c 50          	movb   $0x50,0xc(%ebx)
	}

	tcphdr->src_port = src_port;
  104af4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104af7:	66 89 03             	mov    %ax,(%ebx)
	tcphdr->dst_port = dst_port;
  104afa:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
  104afe:	66 89 43 02          	mov    %ax,0x2(%ebx)
	sys_put_be32(segment->seq, tcphdr->seq);
  104b02:	8b 07                	mov    (%edi),%eax
	sys_put_be16(val >> 16, dst);
  104b04:	89 c2                	mov    %eax,%edx
	dst[1] = val;
  104b06:	88 43 07             	mov    %al,0x7(%ebx)
	sys_put_be16(val >> 16, dst);
  104b09:	c1 ea 10             	shr    $0x10,%edx
	dst[1] = val;
  104b0c:	88 53 05             	mov    %dl,0x5(%ebx)
	dst[0] = val >> 8;
  104b0f:	89 d1                	mov    %edx,%ecx
  104b11:	66 c1 e9 08          	shr    $0x8,%cx
  104b15:	89 c2                	mov    %eax,%edx
  104b17:	66 c1 ea 08          	shr    $0x8,%dx
  104b1b:	88 4b 04             	mov    %cl,0x4(%ebx)
  104b1e:	88 53 06             	mov    %dl,0x6(%ebx)
	sys_put_be32(segment->ack, tcphdr->ack);
  104b21:	8b 47 04             	mov    0x4(%edi),%eax
	sys_put_be16(val >> 16, dst);
  104b24:	89 c2                	mov    %eax,%edx
	dst[1] = val;
  104b26:	88 43 0b             	mov    %al,0xb(%ebx)
	sys_put_be16(val >> 16, dst);
  104b29:	c1 ea 10             	shr    $0x10,%edx
	dst[1] = val;
  104b2c:	88 53 09             	mov    %dl,0x9(%ebx)
	dst[0] = val >> 8;
  104b2f:	89 d1                	mov    %edx,%ecx
  104b31:	66 c1 e9 08          	shr    $0x8,%cx
  104b35:	89 c2                	mov    %eax,%edx
  104b37:	66 c1 ea 08          	shr    $0x8,%dx
  104b3b:	88 4b 08             	mov    %cl,0x8(%ebx)
  104b3e:	88 53 0a             	mov    %dl,0xa(%ebx)
	tcphdr->flags = segment->flags;
  104b41:	8a 47 0a             	mov    0xa(%edi),%al
  104b44:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_put_be16(segment->wnd, tcphdr->wnd);
  104b47:	8b 47 08             	mov    0x8(%edi),%eax
	tcphdr->urg[0] = 0;
  104b4a:	c6 43 12 00          	movb   $0x0,0x12(%ebx)
  104b4e:	89 c2                	mov    %eax,%edx
	dst[1] = val;
  104b50:	88 43 0f             	mov    %al,0xf(%ebx)
	dst[0] = val >> 8;
  104b53:	66 c1 ea 08          	shr    $0x8,%dx
	tcphdr->urg[1] = 0;
  104b57:	c6 43 13 00          	movb   $0x0,0x13(%ebx)
  104b5b:	88 53 0e             	mov    %dl,0xe(%ebx)

	if (tail) {
  104b5e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104b62:	74 0b                	je     104b6f <prepare_segment.isra.7+0x16f>
		net_buf_frag_add(buf, tail);
  104b64:	ff 75 f0             	pushl  -0x10(%ebp)
  104b67:	56                   	push   %esi
  104b68:	e8 21 d0 ff ff       	call   101b8e <net_buf_frag_add>
  104b6d:	59                   	pop    %ecx
  104b6e:	5b                   	pop    %ebx
  104b6f:	0f b7 46 16          	movzwl 0x16(%esi),%eax
  104b73:	8d 7e 18             	lea    0x18(%esi),%edi
  104b76:	8d 44 07 03          	lea    0x3(%edi,%eax,1),%eax
  104b7a:	83 e0 fc             	and    $0xfffffffc,%eax
	if (net_nbuf_family(buf) == AF_INET) {
  104b7d:	80 78 29 02          	cmpb   $0x2,0x29(%eax)
  104b81:	75 0b                	jne    104b8e <prepare_segment.isra.7+0x18e>
		net_ipv4_finalize(context, buf);
  104b83:	56                   	push   %esi
  104b84:	ff 75 ec             	pushl  -0x14(%ebp)
  104b87:	e8 3b fe ff ff       	call   1049c7 <net_ipv4_finalize>
  104b8c:	58                   	pop    %eax
  104b8d:	5a                   	pop    %edx
	finalize_segment(context, buf);

	net_tcp_trace("", buf);

	return buf;
}
  104b8e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104b91:	89 f0                	mov    %esi,%eax
  104b93:	5b                   	pop    %ebx
  104b94:	5e                   	pop    %esi
  104b95:	5f                   	pop    %edi
  104b96:	5d                   	pop    %ebp
  104b97:	c3                   	ret    

00104b98 <net_tcp_alloc>:
{
  104b98:	55                   	push   %ebp
  104b99:	89 e5                	mov    %esp,%ebp
  104b9b:	57                   	push   %edi
  104b9c:	56                   	push   %esi
  104b9d:	53                   	push   %ebx
	__asm__ volatile (
  104b9e:	9c                   	pushf  
  104b9f:	fa                   	cli    
  104ba0:	5e                   	pop    %esi
	for (i = 0; i < NET_MAX_TCP_CONTEXT; i++) {
  104ba1:	31 c0                	xor    %eax,%eax
	return tcp->flags & NET_TCP_IN_USE;
  104ba3:	69 d8 94 00 00 00    	imul   $0x94,%eax,%ebx
  104ba9:	8b 8b dc 96 10 00    	mov    0x1096dc(%ebx),%ecx
  104baf:	81 c3 d0 96 10 00    	add    $0x1096d0,%ebx
  104bb5:	89 cf                	mov    %ecx,%edi
  104bb7:	66 c1 ef 05          	shr    $0x5,%di
  104bbb:	89 fa                	mov    %edi,%edx
		if (!net_tcp_is_used(&tcp_context[i])) {
  104bbd:	83 e7 01             	and    $0x1,%edi
  104bc0:	75 16                	jne    104bd8 <net_tcp_alloc+0x40>
			tcp_context[i].flags |= NET_TCP_IN_USE;
  104bc2:	66 81 e1 1f e0       	and    $0xe01f,%cx
  104bc7:	83 ca 01             	or     $0x1,%edx
  104bca:	0f b6 d2             	movzbl %dl,%edx
  104bcd:	c1 e2 05             	shl    $0x5,%edx
  104bd0:	09 ca                	or     %ecx,%edx
  104bd2:	66 89 53 0c          	mov    %dx,0xc(%ebx)
			break;
  104bd6:	eb 06                	jmp    104bde <net_tcp_alloc+0x46>
	for (i = 0; i < NET_MAX_TCP_CONTEXT; i++) {
  104bd8:	40                   	inc    %eax
  104bd9:	83 f8 06             	cmp    $0x6,%eax
  104bdc:	75 c5                	jne    104ba3 <net_tcp_alloc+0xb>
  104bde:	0f ba e6 09          	bt     $0x9,%esi
  104be2:	73 01                	jae    104be5 <net_tcp_alloc+0x4d>
	__asm__ volatile (
  104be4:	fb                   	sti    
		return NULL;
  104be5:	31 f6                	xor    %esi,%esi
	if (i >= NET_MAX_TCP_CONTEXT) {
  104be7:	83 f8 06             	cmp    $0x6,%eax
  104bea:	0f 84 8b 00 00 00    	je     104c7b <net_tcp_alloc+0xe3>
  104bf0:	69 d8 94 00 00 00    	imul   $0x94,%eax,%ebx
	memset(&tcp_context[i], 0, sizeof(struct net_tcp));
  104bf6:	68 94 00 00 00       	push   $0x94
  104bfb:	6a 00                	push   $0x0
  104bfd:	8d b3 60 96 10 00    	lea    0x109660(%ebx),%esi
  104c03:	56                   	push   %esi
  104c04:	e8 cf c8 ff ff       	call   1014d8 <memset>
	tcp_context[i].flags = NET_TCP_IN_USE;
  104c09:	8b 83 dc 96 10 00    	mov    0x1096dc(%ebx),%eax
  104c0f:	8d 93 d0 96 10 00    	lea    0x1096d0(%ebx),%edx
  104c15:	66 25 1f e0          	and    $0xe01f,%ax
	memset(&tcp_context[i], 0, sizeof(struct net_tcp));
  104c19:	83 c4 0c             	add    $0xc,%esp
	tcp_context[i].flags = NET_TCP_IN_USE;
  104c1c:	83 c8 20             	or     $0x20,%eax
  104c1f:	66 89 83 dc 96 10 00 	mov    %ax,0x1096dc(%ebx)
 * @param state TCP state
 */
static inline void net_tcp_set_state(struct net_tcp *tcp,
				     enum net_tcp_state state)
{
	tcp->state = state;
  104c26:	81 62 0c ff 1f fe ff 	andl   $0xfffe1fff,0xc(%edx)
	tcp_context[i].context = context;
  104c2d:	8b 45 08             	mov    0x8(%ebp),%eax
  104c30:	89 83 60 96 10 00    	mov    %eax,0x109660(%ebx)
	return sys_rand32_get();
  104c36:	e8 6a bd ff ff       	call   1009a5 <sys_rand32_get>
	tcp_context[i].send_seq = init_isn();
  104c3b:	89 83 d0 96 10 00    	mov    %eax,0x1096d0(%ebx)
	tcp_context[i].recv_max_ack = tcp_context[i].send_seq + 1u;
  104c41:	40                   	inc    %eax
  104c42:	89 83 cc 96 10 00    	mov    %eax,0x1096cc(%ebx)
	k_timer_init(&tcp_context[i].retry_timer, tcp_retry_expired, NULL);
  104c48:	8d 83 90 96 10 00    	lea    0x109690(%ebx),%eax
  104c4e:	6a 00                	push   $0x0
  104c50:	68 8b 4e 10 00       	push   $0x104e8b
  104c55:	50                   	push   %eax
	tcp_context[i].accept_cb = NULL;
  104c56:	c7 83 e0 96 10 00 00 	movl   $0x0,0x1096e0(%ebx)
  104c5d:	00 00 00 
	k_timer_init(&tcp_context[i].retry_timer, tcp_retry_expired, NULL);
  104c60:	e8 5f 2e 00 00       	call   107ac4 <k_timer_init>
  104c65:	83 c4 0c             	add    $0xc,%esp
	k_sem_init(&tcp_context[i].connect_wait, 0, UINT_MAX);
  104c68:	8d 83 e4 96 10 00    	lea    0x1096e4(%ebx),%eax
  104c6e:	6a ff                	push   $0xffffffff
  104c70:	6a 00                	push   $0x0
  104c72:	50                   	push   %eax
  104c73:	e8 6b 27 00 00       	call   1073e3 <k_sem_init>
  104c78:	83 c4 0c             	add    $0xc,%esp
}
  104c7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104c7e:	89 f0                	mov    %esi,%eax
  104c80:	5b                   	pop    %ebx
  104c81:	5e                   	pop    %esi
  104c82:	5f                   	pop    %edi
  104c83:	5d                   	pop    %ebp
  104c84:	c3                   	ret    

00104c85 <net_tcp_release>:
{
  104c85:	55                   	push   %ebp
  104c86:	89 e5                	mov    %esp,%ebp
  104c88:	56                   	push   %esi
  104c89:	53                   	push   %ebx
  104c8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!PART_OF_ARRAY(tcp_context, tcp)) {
  104c8d:	81 fb 60 96 10 00    	cmp    $0x109660,%ebx
  104c93:	0f 92 c2             	setb   %dl
  104c96:	85 db                	test   %ebx,%ebx
  104c98:	0f 94 c0             	sete   %al
  104c9b:	08 c2                	or     %al,%dl
  104c9d:	0f 85 a7 00 00 00    	jne    104d4a <net_tcp_release+0xc5>
  104ca3:	81 fb d8 99 10 00    	cmp    $0x1099d8,%ebx
  104ca9:	0f 83 9b 00 00 00    	jae    104d4a <net_tcp_release+0xc5>
  104caf:	8b 53 64             	mov    0x64(%ebx),%edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, buf, tmp,
  104cb2:	31 c0                	xor    %eax,%eax
  104cb4:	85 d2                	test   %edx,%edx
  104cb6:	74 03                	je     104cbb <net_tcp_release+0x36>
  104cb8:	8d 42 fc             	lea    -0x4(%edx),%eax
  104cbb:	31 f6                	xor    %esi,%esi
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  104cbd:	83 f8 fc             	cmp    $0xfffffffc,%eax
  104cc0:	74 36                	je     104cf8 <net_tcp_release+0x73>
	return node->next;
  104cc2:	8b 50 04             	mov    0x4(%eax),%edx
  104cc5:	85 d2                	test   %edx,%edx
  104cc7:	74 2f                	je     104cf8 <net_tcp_release+0x73>
  104cc9:	8d 72 fc             	lea    -0x4(%edx),%esi
  104ccc:	eb 2a                	jmp    104cf8 <net_tcp_release+0x73>
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
		list->head = node->next;
  104cce:	8b 50 04             	mov    0x4(%eax),%edx
		sys_slist_remove(&tcp->sent_list, NULL, &buf->sent_list);
  104cd1:	8d 48 04             	lea    0x4(%eax),%ecx
  104cd4:	89 53 64             	mov    %edx,0x64(%ebx)

		/* Was node also the tail? */
		if (list->tail == node) {
  104cd7:	39 4b 68             	cmp    %ecx,0x68(%ebx)
  104cda:	75 03                	jne    104cdf <net_tcp_release+0x5a>
			list->tail = list->head;
  104cdc:	89 53 68             	mov    %edx,0x68(%ebx)
		if (list->tail == node) {
			list->tail = prev_node;
		}
	}

	node->next = NULL;
  104cdf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		net_nbuf_unref(buf);
  104ce6:	50                   	push   %eax
  104ce7:	e8 70 e6 ff ff       	call   10335c <net_nbuf_unref>
  104cec:	5a                   	pop    %edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, buf, tmp,
  104ced:	31 d2                	xor    %edx,%edx
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  104cef:	83 fe fc             	cmp    $0xfffffffc,%esi
  104cf2:	75 0a                	jne    104cfe <net_tcp_release+0x79>
  104cf4:	89 f0                	mov    %esi,%eax
  104cf6:	89 d6                	mov    %edx,%esi
  104cf8:	85 c0                	test   %eax,%eax
  104cfa:	75 d2                	jne    104cce <net_tcp_release+0x49>
  104cfc:	eb 0c                	jmp    104d0a <net_tcp_release+0x85>
	return node->next;
  104cfe:	8b 46 04             	mov    0x4(%esi),%eax
  104d01:	85 c0                	test   %eax,%eax
  104d03:	74 ef                	je     104cf4 <net_tcp_release+0x6f>
  104d05:	8d 50 fc             	lea    -0x4(%eax),%edx
  104d08:	eb ea                	jmp    104cf4 <net_tcp_release+0x6f>
	k_delayed_work_cancel(&tcp->ack_timer);
  104d0a:	8d 43 08             	lea    0x8(%ebx),%eax
  104d0d:	50                   	push   %eax
  104d0e:	e8 5f 2f 00 00       	call   107c72 <k_delayed_work_cancel>
	k_timer_stop(&tcp->retry_timer);
  104d13:	8d 43 30             	lea    0x30(%ebx),%eax
  104d16:	89 04 24             	mov    %eax,(%esp)
  104d19:	e8 4f 2e 00 00       	call   107b6d <k_timer_stop>
  104d1e:	58                   	pop    %eax
 *
 * @return N/A
 */
static inline void k_sem_reset(struct k_sem *sem)
{
	sem->count = 0;
  104d1f:	c7 83 8c 00 00 00 00 	movl   $0x0,0x8c(%ebx)
  104d26:	00 00 00 
  104d29:	81 63 7c ff 1f fe ff 	andl   $0xfffe1fff,0x7c(%ebx)
	tcp->context = NULL;
  104d30:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	__asm__ volatile (
  104d36:	9c                   	pushf  
  104d37:	fa                   	cli    
  104d38:	5a                   	pop    %edx
	return 0;
  104d39:	31 c0                	xor    %eax,%eax
	tcp->flags &= ~(NET_TCP_IN_USE | NET_TCP_RECV_MSS_SET);
  104d3b:	66 81 63 7c df fb    	andw   $0xfbdf,0x7c(%ebx)
  104d41:	0f ba e2 09          	bt     $0x9,%edx
  104d45:	73 08                	jae    104d4f <net_tcp_release+0xca>
	__asm__ volatile (
  104d47:	fb                   	sti    
  104d48:	eb 05                	jmp    104d4f <net_tcp_release+0xca>
		return -EINVAL;
  104d4a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  104d4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104d52:	5b                   	pop    %ebx
  104d53:	5e                   	pop    %esi
  104d54:	5d                   	pop    %ebp
  104d55:	c3                   	ret    

00104d56 <net_tcp_get_recv_mss>:
#else /* CONFIG_NET_IPV4 */
#define ip_max_packet_len(...) 0
#endif /* CONFIG_NET_IPV4 */

uint16_t net_tcp_get_recv_mss(const struct net_tcp *tcp)
{
  104d56:	55                   	push   %ebp
  104d57:	89 e5                	mov    %esp,%ebp
	sa_family_t family = net_context_get_family(tcp->context);
  104d59:	8b 45 08             	mov    0x8(%ebp),%eax
  104d5c:	8b 00                	mov    (%eax),%eax
	if (context->flags & NET_CONTEXT_FAMILY) {
  104d5e:	f6 40 39 10          	testb  $0x10,0x39(%eax)
  104d62:	74 04                	je     104d68 <net_tcp_get_recv_mss+0x12>
	else if (family == AF_INET6) {
		return 1280;
	}
#endif /* CONFIG_NET_IPV6 */

	return 0;
  104d64:	31 c0                	xor    %eax,%eax
  104d66:	eb 1b                	jmp    104d83 <net_tcp_get_recv_mss+0x2d>
	return net_if_get_by_index(context->iface);
  104d68:	0f b6 40 38          	movzbl 0x38(%eax),%eax
  104d6c:	50                   	push   %eax
  104d6d:	e8 ff d3 ff ff       	call   102171 <net_if_get_by_index>
  104d72:	5a                   	pop    %edx
		if (iface && iface->mtu >= NET_IPV4TCPH_LEN) {
  104d73:	85 c0                	test   %eax,%eax
  104d75:	74 ed                	je     104d64 <net_tcp_get_recv_mss+0xe>
  104d77:	8b 40 18             	mov    0x18(%eax),%eax
  104d7a:	66 83 f8 27          	cmp    $0x27,%ax
  104d7e:	76 e4                	jbe    104d64 <net_tcp_get_recv_mss+0xe>
			return iface->mtu - NET_IPV4TCPH_LEN;
  104d80:	83 e8 28             	sub    $0x28,%eax
}
  104d83:	c9                   	leave  
  104d84:	c3                   	ret    

00104d85 <net_tcp_prepare_reset>:
}

int net_tcp_prepare_reset(struct net_tcp *tcp,
			  const struct sockaddr *remote,
			  struct net_buf **buf)
{
  104d85:	55                   	push   %ebp
	struct tcp_segment segment = { 0 };
  104d86:	31 c0                	xor    %eax,%eax
{
  104d88:	89 e5                	mov    %esp,%ebp
  104d8a:	57                   	push   %edi
  104d8b:	53                   	push   %ebx
	struct tcp_segment segment = { 0 };
  104d8c:	b9 06 00 00 00       	mov    $0x6,%ecx
{
  104d91:	83 ec 18             	sub    $0x18,%esp
	struct tcp_segment segment = { 0 };
  104d94:	8d 7d e0             	lea    -0x20(%ebp),%edi
{
  104d97:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct tcp_segment segment = { 0 };
  104d9a:	f3 ab                	rep stos %eax,%es:(%edi)

	if ((net_context_get_state(tcp->context) != NET_CONTEXT_UNCONNECTED) &&
  104d9c:	8b 03                	mov    (%ebx),%eax
  104d9e:	f6 40 39 06          	testb  $0x6,0x39(%eax)
  104da2:	74 5b                	je     104dff <net_tcp_prepare_reset+0x7a>
	return (enum net_tcp_state)tcp->state;
  104da4:	8b 53 7c             	mov    0x7c(%ebx),%edx
  104da7:	c1 ea 0d             	shr    $0xd,%edx
  104daa:	83 e2 0f             	and    $0xf,%edx
	    (net_tcp_get_state(tcp) != NET_TCP_SYN_SENT) &&
  104dad:	83 fa 09             	cmp    $0x9,%edx
  104db0:	74 4d                	je     104dff <net_tcp_prepare_reset+0x7a>
  104db2:	83 fa 02             	cmp    $0x2,%edx
  104db5:	74 48                	je     104dff <net_tcp_prepare_reset+0x7a>
	    (net_tcp_get_state(tcp) != NET_TCP_TIME_WAIT)) {
		if (net_tcp_get_state(tcp) == NET_TCP_SYN_RCVD) {
  104db7:	83 fa 03             	cmp    $0x3,%edx
  104dba:	75 0c                	jne    104dc8 <net_tcp_prepare_reset+0x43>
			/* Send the reset segment with acknowledgment. */
			segment.ack = tcp->send_ack;
  104dbc:	8b 53 74             	mov    0x74(%ebx),%edx
			segment.flags = NET_TCP_RST | NET_TCP_ACK;
  104dbf:	c6 45 ea 14          	movb   $0x14,-0x16(%ebp)
			segment.ack = tcp->send_ack;
  104dc3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  104dc6:	eb 04                	jmp    104dcc <net_tcp_prepare_reset+0x47>
		} else {
			/* Send the reset segment without acknowledgment. */
			segment.ack = 0;
			segment.flags = NET_TCP_RST;
  104dc8:	c6 45 ea 04          	movb   $0x4,-0x16(%ebp)
		}

		segment.seq = 0;
		segment.src_addr = &tcp->context->local;
  104dcc:	8d 50 04             	lea    0x4(%eax),%edx
		segment.dst_addr = remote;
		segment.wnd = 0;
		segment.options = NULL;
		segment.optlen = 0;

		*buf = prepare_segment(tcp, &segment, NULL);
  104dcf:	31 c9                	xor    %ecx,%ecx
		segment.src_addr = &tcp->context->local;
  104dd1:	89 55 f0             	mov    %edx,-0x10(%ebp)
		segment.dst_addr = remote;
  104dd4:	8b 55 0c             	mov    0xc(%ebp),%edx
  104dd7:	89 55 f4             	mov    %edx,-0xc(%ebp)
		*buf = prepare_segment(tcp, &segment, NULL);
  104dda:	8d 55 e0             	lea    -0x20(%ebp),%edx
		segment.seq = 0;
  104ddd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		segment.wnd = 0;
  104de4:	66 c7 45 e8 00 00    	movw   $0x0,-0x18(%ebp)
		segment.options = NULL;
  104dea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		segment.optlen = 0;
  104df1:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
		*buf = prepare_segment(tcp, &segment, NULL);
  104df5:	e8 06 fc ff ff       	call   104a00 <prepare_segment.isra.7>
  104dfa:	8b 55 10             	mov    0x10(%ebp),%edx
  104dfd:	89 02                	mov    %eax,(%edx)
	}

	return 0;
}
  104dff:	83 c4 18             	add    $0x18,%esp
  104e02:	31 c0                	xor    %eax,%eax
  104e04:	5b                   	pop    %ebx
  104e05:	5f                   	pop    %edi
  104e06:	5d                   	pop    %ebp
  104e07:	c3                   	ret    

00104e08 <net_tcp_send_buf>:

	return 0;
}

int net_tcp_send_buf(struct net_buf *buf)
{
  104e08:	55                   	push   %ebp
  104e09:	89 e5                	mov    %esp,%ebp
  104e0b:	57                   	push   %edi
  104e0c:	56                   	push   %esi
  104e0d:	53                   	push   %ebx
  104e0e:	52                   	push   %edx
  104e0f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104e12:	0f b7 43 16          	movzwl 0x16(%ebx),%eax
  104e16:	8d 73 18             	lea    0x18(%ebx),%esi
  104e19:	8d 44 06 03          	lea    0x3(%esi,%eax,1),%eax
  104e1d:	83 e0 fc             	and    $0xfffffffc,%eax
	return ((struct net_nbuf *)net_buf_user_data(buf))->context;
  104e20:	8b 38                	mov    (%eax),%edi
	struct net_context *ctx = net_nbuf_context(buf);
	struct net_tcp_hdr *tcphdr = NET_TCP_BUF(buf);
  104e22:	89 d8                	mov    %ebx,%eax
  104e24:	e8 81 d6 ff ff       	call   1024aa <net_nbuf_tcp_data>

	sys_put_be32(ctx->tcp->send_ack, tcphdr->ack);
  104e29:	8b 57 3c             	mov    0x3c(%edi),%edx
  104e2c:	8b 52 74             	mov    0x74(%edx),%edx
	sys_put_be16(val >> 16, dst);
  104e2f:	89 d1                	mov    %edx,%ecx
	dst[1] = val;
  104e31:	88 50 0b             	mov    %dl,0xb(%eax)
	sys_put_be16(val >> 16, dst);
  104e34:	c1 e9 10             	shr    $0x10,%ecx
  104e37:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	dst[0] = val >> 8;
  104e3a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104e3d:	66 c1 e9 08          	shr    $0x8,%cx
  104e41:	88 48 08             	mov    %cl,0x8(%eax)
	dst[1] = val;
  104e44:	8a 4d f0             	mov    -0x10(%ebp),%cl
  104e47:	88 48 09             	mov    %cl,0x9(%eax)
	dst[0] = val >> 8;
  104e4a:	89 d1                	mov    %edx,%ecx
  104e4c:	66 c1 e9 08          	shr    $0x8,%cx
  104e50:	88 48 0a             	mov    %cl,0xa(%eax)
	/* The data stream code always sets this flag, because
	 * existing stacks (Linux, anyway) seem to ignore data packets
	 * without a valid-but-already-transmitted ACK.  But set it
	 * anyway if we know we need it just to sanify edge cases.
	 */
	if (ctx->tcp->sent_ack != ctx->tcp->send_ack) {
  104e53:	8b 57 3c             	mov    0x3c(%edi),%edx
  104e56:	8b 4a 74             	mov    0x74(%edx),%ecx
  104e59:	39 4a 78             	cmp    %ecx,0x78(%edx)
  104e5c:	74 04                	je     104e62 <net_tcp_send_buf+0x5a>
		tcphdr->flags |= NET_TCP_ACK;
  104e5e:	80 48 0d 10          	orb    $0x10,0xd(%eax)
	}

	if (tcphdr->flags & NET_TCP_FIN) {
  104e62:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  104e66:	74 04                	je     104e6c <net_tcp_send_buf+0x64>
		ctx->tcp->fin_sent = 1;
  104e68:	80 4a 7e 04          	orb    $0x4,0x7e(%edx)
	}

	ctx->tcp->sent_ack = ctx->tcp->send_ack;
  104e6c:	89 4a 78             	mov    %ecx,0x78(%edx)
  104e6f:	0f b7 43 16          	movzwl 0x16(%ebx),%eax
  104e73:	8d 44 06 03          	lea    0x3(%esi,%eax,1),%eax
  104e77:	83 e0 fc             	and    $0xfffffffc,%eax
	((struct net_nbuf *)net_buf_user_data(buf))->buf_sent = sent;
  104e7a:	c6 40 2d 01          	movb   $0x1,0x2d(%eax)

	net_nbuf_set_buf_sent(buf, true);

	return net_send_data(buf);
  104e7e:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  104e81:	58                   	pop    %eax
  104e82:	5b                   	pop    %ebx
  104e83:	5e                   	pop    %esi
  104e84:	5f                   	pop    %edi
  104e85:	5d                   	pop    %ebp
	return net_send_data(buf);
  104e86:	e9 d5 cf ff ff       	jmp    101e60 <net_send_data>

00104e8b <tcp_retry_expired>:
{
  104e8b:	55                   	push   %ebp
  104e8c:	89 e5                	mov    %esp,%ebp
  104e8e:	53                   	push   %ebx
  104e8f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!sys_slist_is_empty(&tcp->sent_list)) {
  104e92:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
  104e96:	74 3d                	je     104ed5 <tcp_retry_expired+0x4a>
		tcp->retry_timeout_shift++;
  104e98:	8a 43 4c             	mov    0x4c(%ebx),%al
  104e9b:	8d 48 01             	lea    0x1(%eax),%ecx
  104e9e:	83 e0 e0             	and    $0xffffffe0,%eax
  104ea1:	83 e1 1f             	and    $0x1f,%ecx
  104ea4:	09 c8                	or     %ecx,%eax
  104ea6:	88 43 4c             	mov    %al,0x4c(%ebx)
	return ((uint32_t)1 << tcp->retry_timeout_shift) * INIT_RETRY_MS;
  104ea9:	b8 c8 00 00 00       	mov    $0xc8,%eax
  104eae:	d3 e0                	shl    %cl,%eax
		k_timer_start(&tcp->retry_timer, retry_timeout(tcp), 0);
  104eb0:	6a 00                	push   $0x0
  104eb2:	50                   	push   %eax
  104eb3:	53                   	push   %ebx
  104eb4:	e8 52 2c 00 00       	call   107b0b <k_timer_start>
  104eb9:	83 c4 0c             	add    $0xc,%esp
		buf = CONTAINER_OF(sys_slist_peek_head(&tcp->sent_list),
  104ebc:	8b 43 34             	mov    0x34(%ebx),%eax
  104ebf:	83 e8 04             	sub    $0x4,%eax
		net_tcp_send_buf(net_nbuf_ref(buf));
  104ec2:	50                   	push   %eax
  104ec3:	e8 ac e4 ff ff       	call   103374 <net_nbuf_ref>
}
  104ec8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		net_tcp_send_buf(net_nbuf_ref(buf));
  104ecb:	5a                   	pop    %edx
  104ecc:	89 45 08             	mov    %eax,0x8(%ebp)
}
  104ecf:	c9                   	leave  
		net_tcp_send_buf(net_nbuf_ref(buf));
  104ed0:	e9 33 ff ff ff       	jmp    104e08 <net_tcp_send_buf>
}
  104ed5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104ed8:	c9                   	leave  
  104ed9:	c3                   	ret    

00104eda <net_tcp_send_data>:
		tcp->flags &= ~NET_TCP_RETRYING;
	}
}

int net_tcp_send_data(struct net_context *context)
{
  104eda:	55                   	push   %ebp
  104edb:	89 e5                	mov    %esp,%ebp
  104edd:	53                   	push   %ebx
  104ede:	8b 45 08             	mov    0x8(%ebp),%eax
  104ee1:	8b 40 3c             	mov    0x3c(%eax),%eax
  104ee4:	8b 40 64             	mov    0x64(%eax),%eax
	struct net_buf *buf;

	/* For now, just send all queued data synchronously.  Need to
	 * add window handling and retry/ACK logic.
	 */
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, buf, sent_list) {
  104ee7:	85 c0                	test   %eax,%eax
  104ee9:	8d 58 fc             	lea    -0x4(%eax),%ebx
  104eec:	74 28                	je     104f16 <net_tcp_send_data+0x3c>
  104eee:	85 db                	test   %ebx,%ebx
  104ef0:	74 24                	je     104f16 <net_tcp_send_data+0x3c>
  104ef2:	0f b7 43 16          	movzwl 0x16(%ebx),%eax
  104ef6:	8d 44 03 1b          	lea    0x1b(%ebx,%eax,1),%eax
  104efa:	83 e0 fc             	and    $0xfffffffc,%eax
		if (!net_nbuf_buf_sent(buf)) {
  104efd:	80 78 2d 00          	cmpb   $0x0,0x2d(%eax)
  104f01:	75 07                	jne    104f0a <net_tcp_send_data+0x30>
			net_tcp_send_buf(buf);
  104f03:	53                   	push   %ebx
  104f04:	e8 ff fe ff ff       	call   104e08 <net_tcp_send_buf>
  104f09:	58                   	pop    %eax
  104f0a:	8b 5b 04             	mov    0x4(%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, buf, sent_list) {
  104f0d:	85 db                	test   %ebx,%ebx
  104f0f:	74 05                	je     104f16 <net_tcp_send_data+0x3c>
  104f11:	83 eb 04             	sub    $0x4,%ebx
  104f14:	eb d8                	jmp    104eee <net_tcp_send_data+0x14>
		}
	}

	return 0;
}
  104f16:	31 c0                	xor    %eax,%eax
  104f18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104f1b:	c9                   	leave  
  104f1c:	c3                   	ret    

00104f1d <net_tcp_init>:
		}
	}
}

void net_tcp_init(void)
{
  104f1d:	55                   	push   %ebp
  104f1e:	89 e5                	mov    %esp,%ebp
}
  104f20:	5d                   	pop    %ebp
  104f21:	c3                   	ret    

00104f22 <net_tcp_change_state>:
}
#endif /* CONFIG_NET_DEBUG_TCP */

void net_tcp_change_state(struct net_tcp *tcp,
			  enum net_tcp_state new_state)
{
  104f22:	55                   	push   %ebp
  104f23:	89 e5                	mov    %esp,%ebp
  104f25:	53                   	push   %ebx
  104f26:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104f29:	8b 55 0c             	mov    0xc(%ebp),%edx
  104f2c:	8b 43 7c             	mov    0x7c(%ebx),%eax
  104f2f:	89 c1                	mov    %eax,%ecx
  104f31:	c1 e9 0d             	shr    $0xd,%ecx
  104f34:	83 e1 0f             	and    $0xf,%ecx
	NET_ASSERT(tcp);

	if (net_tcp_get_state(tcp) == new_state) {
  104f37:	39 d1                	cmp    %edx,%ecx
  104f39:	74 53                	je     104f8e <net_tcp_change_state+0x6c>
	tcp->state = state;
  104f3b:	83 e2 0f             	and    $0xf,%edx
  104f3e:	25 ff 1f fe ff       	and    $0xfffe1fff,%eax
  104f43:	89 d1                	mov    %edx,%ecx
  104f45:	83 e1 0f             	and    $0xf,%ecx
  104f48:	c1 e1 0d             	shl    $0xd,%ecx
  104f4b:	09 c8                	or     %ecx,%eax
	validate_state_transition(tcp->state, new_state);
#endif /* CONFIG_NET_DEBUG_TCP */

	net_tcp_set_state(tcp, new_state);

	if (net_tcp_get_state(tcp) != NET_TCP_CLOSED) {
  104f4d:	84 d2                	test   %dl,%dl
  104f4f:	89 43 7c             	mov    %eax,0x7c(%ebx)
  104f52:	75 3a                	jne    104f8e <net_tcp_change_state+0x6c>
		return;
	}

	if (!tcp->context) {
  104f54:	8b 03                	mov    (%ebx),%eax
  104f56:	85 c0                	test   %eax,%eax
  104f58:	74 34                	je     104f8e <net_tcp_change_state+0x6c>
		return;
	}

	/* Remove any port handlers if we are closing */
	if (tcp->context->conn_handler) {
  104f5a:	8b 40 14             	mov    0x14(%eax),%eax
  104f5d:	85 c0                	test   %eax,%eax
  104f5f:	74 10                	je     104f71 <net_tcp_change_state+0x4f>
	return net_conn_unregister(handle);
  104f61:	50                   	push   %eax
  104f62:	e8 03 04 00 00       	call   10536a <net_conn_unregister>
  104f67:	58                   	pop    %eax
		net_tcp_unregister(tcp->context->conn_handler);
		tcp->context->conn_handler = NULL;
  104f68:	8b 03                	mov    (%ebx),%eax
  104f6a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	}

	if (tcp->accept_cb) {
  104f71:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  104f77:	85 d2                	test   %edx,%edx
  104f79:	74 13                	je     104f8e <net_tcp_change_state+0x6c>
		tcp->accept_cb(tcp->context,
			       &tcp->context->remote,
			       sizeof(struct sockaddr),
			       -ENETRESET,
			       tcp->context->user_data);
  104f7b:	8b 03                	mov    (%ebx),%eax
		tcp->accept_cb(tcp->context,
  104f7d:	ff 70 24             	pushl  0x24(%eax)
  104f80:	8d 48 0c             	lea    0xc(%eax),%ecx
  104f83:	6a cc                	push   $0xffffffcc
  104f85:	6a 08                	push   $0x8
  104f87:	51                   	push   %ecx
  104f88:	50                   	push   %eax
  104f89:	ff d2                	call   *%edx
  104f8b:	83 c4 14             	add    $0x14,%esp
	}
}
  104f8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104f91:	c9                   	leave  
  104f92:	c3                   	ret    

00104f93 <net_tcp_prepare_segment>:
{
  104f93:	55                   	push   %ebp
	struct tcp_segment segment = { 0 };
  104f94:	31 c0                	xor    %eax,%eax
{
  104f96:	89 e5                	mov    %esp,%ebp
  104f98:	57                   	push   %edi
  104f99:	56                   	push   %esi
  104f9a:	53                   	push   %ebx
  104f9b:	83 ec 18             	sub    $0x18,%esp
	struct tcp_segment segment = { 0 };
  104f9e:	8d 7d dc             	lea    -0x24(%ebp),%edi
{
  104fa1:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct tcp_segment segment = { 0 };
  104fa4:	b9 06 00 00 00       	mov    $0x6,%ecx
{
  104fa9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104fac:	89 d6                	mov    %edx,%esi
	struct tcp_segment segment = { 0 };
  104fae:	f3 ab                	rep stos %eax,%es:(%edi)
	if (!local) {
  104fb0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  104fb4:	75 08                	jne    104fbe <net_tcp_prepare_segment+0x2b>
		local = &tcp->context->local;
  104fb6:	8b 03                	mov    (%ebx),%eax
  104fb8:	83 c0 04             	add    $0x4,%eax
  104fbb:	89 45 18             	mov    %eax,0x18(%ebp)
	seq = tcp->send_seq;
  104fbe:	8b 7b 70             	mov    0x70(%ebx),%edi
	if (flags & NET_TCP_ACK) {
  104fc1:	f6 c2 10             	test   $0x10,%dl
  104fc4:	74 41                	je     105007 <net_tcp_prepare_segment+0x74>
	return (enum net_tcp_state)tcp->state;
  104fc6:	8b 43 7c             	mov    0x7c(%ebx),%eax
  104fc9:	c1 e8 0d             	shr    $0xd,%eax
  104fcc:	83 e0 0f             	and    $0xf,%eax
		if (net_tcp_get_state(tcp) == NET_TCP_FIN_WAIT_1) {
  104fcf:	83 f8 07             	cmp    $0x7,%eax
  104fd2:	75 10                	jne    104fe4 <net_tcp_prepare_segment+0x51>
			if (flags & NET_TCP_FIN) {
  104fd4:	f6 c2 01             	test   $0x1,%dl
  104fd7:	74 07                	je     104fe0 <net_tcp_prepare_segment+0x4d>
				flags &= ~NET_TCP_FIN;
  104fd9:	89 d6                	mov    %edx,%esi
  104fdb:	83 e6 fe             	and    $0xfffffffe,%esi
  104fde:	eb 09                	jmp    104fe9 <net_tcp_prepare_segment+0x56>
				net_tcp_change_state(tcp, NET_TCP_CLOSING);
  104fe0:	6a 0a                	push   $0xa
  104fe2:	eb 1b                	jmp    104fff <net_tcp_prepare_segment+0x6c>
		} else if (net_tcp_get_state(tcp) == NET_TCP_FIN_WAIT_2) {
  104fe4:	83 f8 08             	cmp    $0x8,%eax
  104fe7:	75 04                	jne    104fed <net_tcp_prepare_segment+0x5a>
			net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
  104fe9:	6a 09                	push   $0x9
  104feb:	eb 12                	jmp    104fff <net_tcp_prepare_segment+0x6c>
		} else if (net_tcp_get_state(tcp) == NET_TCP_CLOSE_WAIT) {
  104fed:	83 f8 05             	cmp    $0x5,%eax
  104ff0:	75 15                	jne    105007 <net_tcp_prepare_segment+0x74>
			flags |= NET_TCP_FIN;
  104ff2:	89 d6                	mov    %edx,%esi
			tcp->flags |= NET_TCP_IS_SHUTDOWN;
  104ff4:	66 81 4b 7c 00 01    	orw    $0x100,0x7c(%ebx)
			flags |= NET_TCP_FIN;
  104ffa:	83 ce 01             	or     $0x1,%esi
			net_tcp_change_state(tcp, NET_TCP_LAST_ACK);
  104ffd:	6a 06                	push   $0x6
  104fff:	53                   	push   %ebx
  105000:	e8 1d ff ff ff       	call   104f22 <net_tcp_change_state>
  105005:	59                   	pop    %ecx
  105006:	58                   	pop    %eax
	if (flags & NET_TCP_FIN) {
  105007:	f7 c6 01 00 00 00    	test   $0x1,%esi
  10500d:	74 21                	je     105030 <net_tcp_prepare_segment+0x9d>
		tcp->flags |= NET_TCP_FINAL_SENT;
  10500f:	66 83 4b 7c 40       	orw    $0x40,0x7c(%ebx)
  105014:	8b 43 7c             	mov    0x7c(%ebx),%eax
		seq++;
  105017:	47                   	inc    %edi
  105018:	c1 e8 0d             	shr    $0xd,%eax
  10501b:	83 e0 0f             	and    $0xf,%eax
		if (net_tcp_get_state(tcp) == NET_TCP_ESTABLISHED ||
  10501e:	83 e8 03             	sub    $0x3,%eax
  105021:	83 f8 01             	cmp    $0x1,%eax
  105024:	77 0a                	ja     105030 <net_tcp_prepare_segment+0x9d>
			net_tcp_change_state(tcp, NET_TCP_FIN_WAIT_1);
  105026:	6a 07                	push   $0x7
  105028:	53                   	push   %ebx
  105029:	e8 f4 fe ff ff       	call   104f22 <net_tcp_change_state>
  10502e:	58                   	pop    %eax
  10502f:	5a                   	pop    %edx
	if (flags & NET_TCP_SYN) {
  105030:	89 f0                	mov    %esi,%eax
	*send_buf = prepare_segment(tcp, &segment, *send_buf);
  105032:	8d 55 dc             	lea    -0x24(%ebp),%edx
	if (flags & NET_TCP_SYN) {
  105035:	83 e0 02             	and    $0x2,%eax
	segment.wnd = wnd;
  105038:	66 c7 45 e4 00 05    	movw   $0x500,-0x1c(%ebp)
		seq++;
  10503e:	3c 01                	cmp    $0x1,%al
	segment.src_addr = (struct sockaddr_ptr *)local;
  105040:	8b 45 18             	mov    0x18(%ebp),%eax
		seq++;
  105043:	83 df ff             	sbb    $0xffffffff,%edi
	segment.src_addr = (struct sockaddr_ptr *)local;
  105046:	89 45 ec             	mov    %eax,-0x14(%ebp)
	segment.dst_addr = remote;
  105049:	8b 45 1c             	mov    0x1c(%ebp),%eax
  10504c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	segment.seq = tcp->send_seq;
  10504f:	8b 43 70             	mov    0x70(%ebx),%eax
  105052:	89 45 dc             	mov    %eax,-0x24(%ebp)
	segment.ack = tcp->send_ack;
  105055:	8b 43 74             	mov    0x74(%ebx),%eax
  105058:	89 45 e0             	mov    %eax,-0x20(%ebp)
	segment.flags = flags;
  10505b:	89 f0                	mov    %esi,%eax
  10505d:	88 45 e6             	mov    %al,-0x1a(%ebp)
	segment.options = options;
  105060:	8b 45 10             	mov    0x10(%ebp),%eax
  105063:	89 45 e8             	mov    %eax,-0x18(%ebp)
	segment.optlen = optlen;
  105066:	8b 45 14             	mov    0x14(%ebp),%eax
  105069:	88 45 e7             	mov    %al,-0x19(%ebp)
	*send_buf = prepare_segment(tcp, &segment, *send_buf);
  10506c:	8b 45 20             	mov    0x20(%ebp),%eax
  10506f:	8b 08                	mov    (%eax),%ecx
  105071:	8b 03                	mov    (%ebx),%eax
  105073:	e8 88 f9 ff ff       	call   104a00 <prepare_segment.isra.7>
  105078:	8b 4d 20             	mov    0x20(%ebp),%ecx
  10507b:	89 01                	mov    %eax,(%ecx)
	return d > 0 && d < 0x20000000;
  10507d:	8b 43 6c             	mov    0x6c(%ebx),%eax
  105080:	f7 d0                	not    %eax
  105082:	01 f8                	add    %edi,%eax
	tcp->send_seq = seq;
  105084:	89 7b 70             	mov    %edi,0x70(%ebx)
	if (seq_greater(tcp->send_seq, tcp->recv_max_ack)) {
  105087:	3d fe ff ff 1f       	cmp    $0x1ffffffe,%eax
  10508c:	77 03                	ja     105091 <net_tcp_prepare_segment+0xfe>
		tcp->recv_max_ack = tcp->send_seq;
  10508e:	89 7b 6c             	mov    %edi,0x6c(%ebx)
}
  105091:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105094:	31 c0                	xor    %eax,%eax
  105096:	5b                   	pop    %ebx
  105097:	5e                   	pop    %esi
  105098:	5f                   	pop    %edi
  105099:	5d                   	pop    %ebp
  10509a:	c3                   	ret    

0010509b <net_tcp_prepare_ack>:
{
  10509b:	55                   	push   %ebp
  10509c:	89 e5                	mov    %esp,%ebp
  10509e:	57                   	push   %edi
  10509f:	56                   	push   %esi
  1050a0:	53                   	push   %ebx
  1050a1:	83 ec 08             	sub    $0x8,%esp
  1050a4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1050a7:	8b 75 0c             	mov    0xc(%ebp),%esi
  1050aa:	8b 7d 10             	mov    0x10(%ebp),%edi
  1050ad:	8b 43 7c             	mov    0x7c(%ebx),%eax
  1050b0:	c1 e8 0d             	shr    $0xd,%eax
  1050b3:	83 e0 0f             	and    $0xf,%eax
	switch (net_tcp_get_state(tcp)) {
  1050b6:	3c 03                	cmp    $0x3,%al
  1050b8:	74 18                	je     1050d2 <net_tcp_prepare_ack+0x37>
  1050ba:	72 57                	jb     105113 <net_tcp_prepare_ack+0x78>
  1050bc:	83 e8 06             	sub    $0x6,%eax
  1050bf:	3c 01                	cmp    $0x1,%al
  1050c1:	77 50                	ja     105113 <net_tcp_prepare_ack+0x78>
		tcp->send_seq--;
  1050c3:	ff 4b 70             	decl   0x70(%ebx)
		net_tcp_prepare_segment(tcp, NET_TCP_FIN | NET_TCP_ACK,
  1050c6:	57                   	push   %edi
  1050c7:	56                   	push   %esi
  1050c8:	6a 00                	push   $0x0
  1050ca:	6a 00                	push   $0x0
  1050cc:	6a 00                	push   $0x0
  1050ce:	6a 11                	push   $0x11
  1050d0:	eb 4b                	jmp    10511d <net_tcp_prepare_ack+0x82>
		tcp->send_seq--;
  1050d2:	ff 4b 70             	decl   0x70(%ebx)
		recv_mss = 0;
  1050d5:	31 c0                	xor    %eax,%eax
	if (!(tcp->flags & NET_TCP_RECV_MSS_SET)) {
  1050d7:	f6 43 7d 04          	testb  $0x4,0x7d(%ebx)
  1050db:	75 0d                	jne    1050ea <net_tcp_prepare_ack+0x4f>
		recv_mss = net_tcp_get_recv_mss(tcp);
  1050dd:	53                   	push   %ebx
  1050de:	e8 73 fc ff ff       	call   104d56 <net_tcp_get_recv_mss>
  1050e3:	5a                   	pop    %edx
		tcp->flags |= NET_TCP_RECV_MSS_SET;
  1050e4:	66 81 4b 7c 00 04    	orw    $0x400,0x7c(%ebx)
		htonl((uint32_t)(recv_mss | NET_TCP_MSS_HEADER));
  1050ea:	0f b7 c0             	movzwl %ax,%eax
  1050ed:	89 c2                	mov    %eax,%edx
		net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
  1050ef:	57                   	push   %edi
		htonl((uint32_t)(recv_mss | NET_TCP_MSS_HEADER));
  1050f0:	c1 e2 18             	shl    $0x18,%edx
		net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
  1050f3:	56                   	push   %esi
		htonl((uint32_t)(recv_mss | NET_TCP_MSS_HEADER));
  1050f4:	c1 e0 08             	shl    $0x8,%eax
  1050f7:	81 ca 02 04 00 00    	or     $0x402,%edx
  1050fd:	25 00 00 ff 00       	and    $0xff0000,%eax
		net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
  105102:	6a 00                	push   $0x0
		htonl((uint32_t)(recv_mss | NET_TCP_MSS_HEADER));
  105104:	09 d0                	or     %edx,%eax
		net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
  105106:	6a 04                	push   $0x4
		htonl((uint32_t)(recv_mss | NET_TCP_MSS_HEADER));
  105108:	89 45 ec             	mov    %eax,-0x14(%ebp)
		net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
  10510b:	8d 45 ec             	lea    -0x14(%ebp),%eax
  10510e:	50                   	push   %eax
  10510f:	6a 12                	push   $0x12
  105111:	eb 0a                	jmp    10511d <net_tcp_prepare_ack+0x82>
		net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL, remote,
  105113:	57                   	push   %edi
  105114:	56                   	push   %esi
  105115:	6a 00                	push   $0x0
  105117:	6a 00                	push   $0x0
  105119:	6a 00                	push   $0x0
  10511b:	6a 10                	push   $0x10
  10511d:	53                   	push   %ebx
  10511e:	e8 70 fe ff ff       	call   104f93 <net_tcp_prepare_segment>
  105123:	83 c4 1c             	add    $0x1c,%esp
}
  105126:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105129:	31 c0                	xor    %eax,%eax
  10512b:	5b                   	pop    %ebx
  10512c:	5e                   	pop    %esi
  10512d:	5f                   	pop    %edi
  10512e:	5d                   	pop    %ebp
  10512f:	c3                   	ret    

00105130 <net_tcp_queue_data>:
{
  105130:	55                   	push   %ebp
  105131:	89 e5                	mov    %esp,%ebp
  105133:	57                   	push   %edi
  105134:	56                   	push   %esi
  105135:	53                   	push   %ebx
  105136:	8b 7d 08             	mov    0x8(%ebp),%edi
	size_t data_len = net_buf_frags_len(buf);
  105139:	8b 45 0c             	mov    0xc(%ebp),%eax
	size_t bytes = 0;
  10513c:	31 db                	xor    %ebx,%ebx
	struct net_conn *conn = (struct net_conn *)context->conn_handler;
  10513e:	8b 57 14             	mov    0x14(%edi),%edx
	while (buf) {
  105141:	85 c0                	test   %eax,%eax
  105143:	74 0a                	je     10514f <net_tcp_queue_data+0x1f>
		bytes += buf->len;
  105145:	0f b7 48 14          	movzwl 0x14(%eax),%ecx
		buf = buf->frags;
  105149:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  10514b:	01 cb                	add    %ecx,%ebx
  10514d:	eb f2                	jmp    105141 <net_tcp_queue_data+0x11>
	ret = net_tcp_prepare_segment(context->tcp, NET_TCP_PSH | NET_TCP_ACK,
  10514f:	8d 45 0c             	lea    0xc(%ebp),%eax
  105152:	50                   	push   %eax
  105153:	52                   	push   %edx
  105154:	6a 00                	push   $0x0
  105156:	6a 00                	push   $0x0
  105158:	6a 00                	push   $0x0
  10515a:	6a 18                	push   $0x18
  10515c:	ff 77 3c             	pushl  0x3c(%edi)
  10515f:	e8 2f fe ff ff       	call   104f93 <net_tcp_prepare_segment>
  105164:	83 c4 1c             	add    $0x1c,%esp
  105167:	89 c6                	mov    %eax,%esi
	if (ret) {
  105169:	85 c0                	test   %eax,%eax
  10516b:	75 2e                	jne    10519b <net_tcp_queue_data+0x6b>
	context->tcp->send_seq += data_len;
  10516d:	8b 47 3c             	mov    0x3c(%edi),%eax
	sys_slist_append(&context->tcp->sent_list, &buf->sent_list);
  105170:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	context->tcp->send_seq += data_len;
  105173:	01 58 70             	add    %ebx,0x70(%eax)
	if (!list->tail) {
  105176:	8b 58 68             	mov    0x68(%eax),%ebx
	sys_slist_append(&context->tcp->sent_list, &buf->sent_list);
  105179:	8d 51 04             	lea    0x4(%ecx),%edx
	node->next = NULL;
  10517c:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
	if (!list->tail) {
  105183:	85 db                	test   %ebx,%ebx
  105185:	75 08                	jne    10518f <net_tcp_queue_data+0x5f>
		list->tail = node;
  105187:	89 50 68             	mov    %edx,0x68(%eax)
		list->head = node;
  10518a:	89 50 64             	mov    %edx,0x64(%eax)
  10518d:	eb 05                	jmp    105194 <net_tcp_queue_data+0x64>
		list->tail->next = node;
  10518f:	89 13                	mov    %edx,(%ebx)
		list->tail = node;
  105191:	89 50 68             	mov    %edx,0x68(%eax)
	net_nbuf_ref(buf);
  105194:	51                   	push   %ecx
  105195:	e8 da e1 ff ff       	call   103374 <net_nbuf_ref>
  10519a:	58                   	pop    %eax
}
  10519b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10519e:	89 f0                	mov    %esi,%eax
  1051a0:	5b                   	pop    %ebx
  1051a1:	5e                   	pop    %esi
  1051a2:	5f                   	pop    %edi
  1051a3:	5d                   	pop    %ebp
  1051a4:	c3                   	ret    

001051a5 <net_tcp_ack_received>:
{
  1051a5:	55                   	push   %ebp
  1051a6:	89 e5                	mov    %esp,%ebp
  1051a8:	57                   	push   %edi
  1051a9:	56                   	push   %esi
  1051aa:	53                   	push   %ebx
  1051ab:	83 ec 14             	sub    $0x14,%esp
	bool valid_ack = false;
  1051ae:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
{
  1051b2:	8b 7d 08             	mov    0x8(%ebp),%edi
  1051b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1051b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct net_tcp *tcp = ctx->tcp;
  1051bb:	8b 77 3c             	mov    0x3c(%edi),%esi
  1051be:	8b 5e 64             	mov    0x64(%esi),%ebx
	while (!sys_slist_is_empty(list)) {
  1051c1:	85 db                	test   %ebx,%ebx
  1051c3:	74 55                	je     10521a <net_tcp_ack_received+0x75>
		buf = CONTAINER_OF(head, struct net_buf, sent_list);
  1051c5:	8d 43 fc             	lea    -0x4(%ebx),%eax
  1051c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		tcphdr = NET_TCP_BUF(buf);
  1051cb:	e8 da d2 ff ff       	call   1024aa <net_nbuf_tcp_data>
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  1051d0:	0f b7 53 12          	movzwl 0x12(%ebx),%edx
	return d > 0 && d < 0x20000000;
  1051d4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1051d7:	8d 54 13 17          	lea    0x17(%ebx,%edx,1),%edx
  1051db:	83 e2 fc             	and    $0xfffffffc,%edx
		seq = sys_get_be32(tcphdr->seq) + net_nbuf_appdatalen(buf) - 1;
  1051de:	0f b7 52 24          	movzwl 0x24(%edx),%edx
	return d > 0 && d < 0x20000000;
  1051e2:	29 d1                	sub    %edx,%ecx
	return ((uint16_t)src[0] << 8) | src[1];
  1051e4:	0f b6 50 04          	movzbl 0x4(%eax),%edx
  1051e8:	c1 e2 08             	shl    $0x8,%edx
  1051eb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1051ee:	0f b6 48 05          	movzbl 0x5(%eax),%ecx
  1051f2:	09 d1                	or     %edx,%ecx
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
  1051f4:	c1 e1 10             	shl    $0x10,%ecx
  1051f7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	return ((uint16_t)src[0] << 8) | src[1];
  1051fa:	0f b6 48 06          	movzbl 0x6(%eax),%ecx
  1051fe:	0f b6 50 07          	movzbl 0x7(%eax),%edx
  105202:	c1 e1 08             	shl    $0x8,%ecx
  105205:	09 ca                	or     %ecx,%edx
  105207:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	return ((uint32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
  10520a:	0f b7 d2             	movzwl %dx,%edx
  10520d:	0b 55 e0             	or     -0x20(%ebp),%edx
  105210:	29 d1                	sub    %edx,%ecx
		if (!seq_greater(ack, seq)) {
  105212:	81 f9 fe ff ff 1f    	cmp    $0x1ffffffe,%ecx
  105218:	76 0c                	jbe    105226 <net_tcp_ack_received+0x81>
	if (valid_ack) {
  10521a:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  10521e:	0f 84 c4 00 00 00    	je     1052e8 <net_tcp_ack_received+0x143>
  105224:	eb 4c                	jmp    105272 <net_tcp_ack_received+0xcd>
		if (tcphdr->flags & NET_TCP_FIN) {
  105226:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  10522a:	74 21                	je     10524d <net_tcp_ack_received+0xa8>
  10522c:	8b 46 7c             	mov    0x7c(%esi),%eax
  10522f:	c1 e8 0d             	shr    $0xd,%eax
  105232:	83 e0 0f             	and    $0xf,%eax
			if (s == NET_TCP_FIN_WAIT_1) {
  105235:	83 f8 07             	cmp    $0x7,%eax
  105238:	75 04                	jne    10523e <net_tcp_ack_received+0x99>
				net_tcp_change_state(tcp, NET_TCP_FIN_WAIT_2);
  10523a:	6a 08                	push   $0x8
  10523c:	eb 07                	jmp    105245 <net_tcp_ack_received+0xa0>
			} else if (s == NET_TCP_CLOSING) {
  10523e:	83 f8 0a             	cmp    $0xa,%eax
  105241:	75 0a                	jne    10524d <net_tcp_ack_received+0xa8>
				net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
  105243:	6a 09                	push   $0x9
  105245:	56                   	push   %esi
  105246:	e8 d7 fc ff ff       	call   104f22 <net_tcp_change_state>
  10524b:	59                   	pop    %ecx
  10524c:	58                   	pop    %eax
		list->head = node->next;
  10524d:	8b 03                	mov    (%ebx),%eax
		if (list->tail == node) {
  10524f:	3b 5e 68             	cmp    0x68(%esi),%ebx
		list->head = node->next;
  105252:	89 46 64             	mov    %eax,0x64(%esi)
		if (list->tail == node) {
  105255:	75 03                	jne    10525a <net_tcp_ack_received+0xb5>
			list->tail = list->head;
  105257:	89 46 68             	mov    %eax,0x68(%esi)
	node->next = NULL;
  10525a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		net_nbuf_unref(buf);
  105260:	ff 75 ec             	pushl  -0x14(%ebp)
  105263:	e8 f4 e0 ff ff       	call   10335c <net_nbuf_unref>
  105268:	5a                   	pop    %edx
		valid_ack = true;
  105269:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
  10526d:	e9 4c ff ff ff       	jmp    1051be <net_tcp_ack_received+0x19>
		restart_timer(ctx->tcp);
  105272:	8b 5f 3c             	mov    0x3c(%edi),%ebx
	if (!sys_slist_is_empty(&tcp->sent_list)) {
  105275:	83 7b 64 00          	cmpl   $0x0,0x64(%ebx)
  105279:	8d 43 30             	lea    0x30(%ebx),%eax
  10527c:	74 1c                	je     10529a <net_tcp_ack_received+0xf5>
		tcp->flags |= NET_TCP_RETRYING;
  10527e:	66 81 4b 7c 00 02    	orw    $0x200,0x7c(%ebx)
		tcp->retry_timeout_shift = 0;
  105284:	80 63 7c e0          	andb   $0xe0,0x7c(%ebx)
		k_timer_start(&tcp->retry_timer, retry_timeout(tcp), 0);
  105288:	6a 00                	push   $0x0
  10528a:	68 c8 00 00 00       	push   $0xc8
  10528f:	50                   	push   %eax
  105290:	e8 76 28 00 00       	call   107b0b <k_timer_start>
  105295:	83 c4 0c             	add    $0xc,%esp
  105298:	eb 0d                	jmp    1052a7 <net_tcp_ack_received+0x102>
		k_timer_stop(&tcp->retry_timer);
  10529a:	50                   	push   %eax
  10529b:	e8 cd 28 00 00       	call   107b6d <k_timer_stop>
  1052a0:	58                   	pop    %eax
		tcp->flags &= ~NET_TCP_RETRYING;
  1052a1:	66 81 63 7c ff fd    	andw   $0xfdff,0x7c(%ebx)
		if (ctx->tcp->flags & NET_TCP_RETRYING) {
  1052a7:	8b 47 3c             	mov    0x3c(%edi),%eax
  1052aa:	f6 40 7d 02          	testb  $0x2,0x7d(%eax)
  1052ae:	74 38                	je     1052e8 <net_tcp_ack_received+0x143>
  1052b0:	8b 50 64             	mov    0x64(%eax),%edx
			SYS_SLIST_FOR_EACH_CONTAINER(&ctx->tcp->sent_list, buf,
  1052b3:	85 d2                	test   %edx,%edx
  1052b5:	8d 42 fc             	lea    -0x4(%edx),%eax
  1052b8:	75 28                	jne    1052e2 <net_tcp_ack_received+0x13d>
			net_tcp_send_data(ctx);
  1052ba:	89 7d 08             	mov    %edi,0x8(%ebp)
}
  1052bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1052c0:	5b                   	pop    %ebx
  1052c1:	5e                   	pop    %esi
  1052c2:	5f                   	pop    %edi
  1052c3:	5d                   	pop    %ebp
			net_tcp_send_data(ctx);
  1052c4:	e9 11 fc ff ff       	jmp    104eda <net_tcp_send_data>
  1052c9:	0f b7 50 16          	movzwl 0x16(%eax),%edx
  1052cd:	8d 54 10 1b          	lea    0x1b(%eax,%edx,1),%edx
	return node->next;
  1052d1:	8b 40 04             	mov    0x4(%eax),%eax
  1052d4:	83 e2 fc             	and    $0xfffffffc,%edx
			SYS_SLIST_FOR_EACH_CONTAINER(&ctx->tcp->sent_list, buf,
  1052d7:	85 c0                	test   %eax,%eax
  1052d9:	c6 42 2d 00          	movb   $0x0,0x2d(%edx)
  1052dd:	74 db                	je     1052ba <net_tcp_ack_received+0x115>
  1052df:	83 e8 04             	sub    $0x4,%eax
  1052e2:	85 c0                	test   %eax,%eax
  1052e4:	75 e3                	jne    1052c9 <net_tcp_ack_received+0x124>
  1052e6:	eb d2                	jmp    1052ba <net_tcp_ack_received+0x115>
}
  1052e8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1052eb:	5b                   	pop    %ebx
  1052ec:	5e                   	pop    %esi
  1052ed:	5f                   	pop    %edi
  1052ee:	5d                   	pop    %ebp
  1052ef:	c3                   	ret    

001052f0 <net_nbuf_udp_data>:
{
  1052f0:	55                   	push   %ebp
  1052f1:	0f b7 50 16          	movzwl 0x16(%eax),%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  1052f5:	8b 08                	mov    (%eax),%ecx
{
  1052f7:	89 e5                	mov    %esp,%ebp
  1052f9:	8d 54 10 1b          	lea    0x1b(%eax,%edx,1),%edx
}
  1052fd:	5d                   	pop    %ebp
  1052fe:	83 e2 fc             	and    $0xfffffffc,%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  105301:	0f b6 42 2a          	movzbl 0x2a(%edx),%eax
				 net_nbuf_ext_len(buf)];
  105305:	0f b6 52 2b          	movzbl 0x2b(%edx),%edx
	return &buf->frags->data[net_nbuf_ip_hdr_len(buf) +
  105309:	01 d0                	add    %edx,%eax
  10530b:	03 41 10             	add    0x10(%ecx),%eax
}
  10530e:	c3                   	ret    

0010530f <check_addr>:
}

static bool check_addr(struct net_buf *buf,
		       struct sockaddr *addr,
		       bool is_remote)
{
  10530f:	55                   	push   %ebp
  105310:	89 e5                	mov    %esp,%ebp
  105312:	57                   	push   %edi
  105313:	56                   	push   %esi
  105314:	53                   	push   %ebx
  105315:	89 c6                	mov    %eax,%esi
	if (addr->family != net_nbuf_family(buf)) {
  105317:	8b 3a                	mov    (%edx),%edi
  105319:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  10531d:	8d 44 06 1b          	lea    0x1b(%esi,%eax,1),%eax
  105321:	83 e0 fc             	and    $0xfffffffc,%eax
	return ((struct net_nbuf *)net_buf_user_data(buf))->family;
  105324:	0f b6 40 29          	movzbl 0x29(%eax),%eax
  105328:	66 39 c7             	cmp    %ax,%di
  10532b:	75 32                	jne    10535f <check_addr+0x50>
		return true;
	}
#endif /* CONFIG_NET_IPV6 */

#if defined(CONFIG_NET_IPV4)
	if (net_nbuf_family(buf) == AF_INET && addr->family == AF_INET) {
  10532d:	66 83 ff 02          	cmp    $0x2,%di
  105331:	89 c3                	mov    %eax,%ebx
  105333:	0f 94 c0             	sete   %al
  105336:	80 fb 02             	cmp    $0x2,%bl
  105339:	0f 94 c3             	sete   %bl
  10533c:	20 d8                	and    %bl,%al
  10533e:	74 23                	je     105363 <check_addr+0x54>
		struct in_addr *addr4;

		if (is_remote) {
  105340:	84 c9                	test   %cl,%cl
  105342:	8b 0e                	mov    (%esi),%ecx
			addr4 = &NET_IPV4_BUF(buf)->src;
  105344:	8b 49 10             	mov    0x10(%ecx),%ecx
		if (is_remote) {
  105347:	74 05                	je     10534e <check_addr+0x3f>
			addr4 = &NET_IPV4_BUF(buf)->src;
  105349:	83 c1 0c             	add    $0xc,%ecx
  10534c:	eb 03                	jmp    105351 <check_addr+0x42>
		} else {
			addr4 = &NET_IPV4_BUF(buf)->dst;
  10534e:	83 c1 10             	add    $0x10,%ecx
		}

		if (net_sin(addr)->sin_addr.s_addr[0]) {
  105351:	8b 52 04             	mov    0x4(%edx),%edx
  105354:	85 d2                	test   %edx,%edx
  105356:	74 0d                	je     105365 <check_addr+0x56>
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
  105358:	39 11                	cmp    %edx,(%ecx)
  10535a:	0f 94 c0             	sete   %al
  10535d:	eb 06                	jmp    105365 <check_addr+0x56>
		return false;
  10535f:	31 c0                	xor    %eax,%eax
  105361:	eb 02                	jmp    105365 <check_addr+0x56>
			}
		}
	}
#endif /* CONFIG_NET_IPV4 */

	return true;
  105363:	b0 01                	mov    $0x1,%al
}
  105365:	5b                   	pop    %ebx
  105366:	5e                   	pop    %esi
  105367:	5f                   	pop    %edi
  105368:	5d                   	pop    %ebp
  105369:	c3                   	ret    

0010536a <net_conn_unregister>:
{
  10536a:	55                   	push   %ebp
  10536b:	89 e5                	mov    %esp,%ebp
  10536d:	8b 55 08             	mov    0x8(%ebp),%edx
	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
  105370:	81 fa 50 9a 10 00    	cmp    $0x109a50,%edx
  105376:	77 1b                	ja     105393 <net_conn_unregister+0x29>
  105378:	81 fa e0 99 10 00    	cmp    $0x1099e0,%edx
  10537e:	72 13                	jb     105393 <net_conn_unregister+0x29>
		return -ENOENT;
  105380:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(conn->flags & NET_CONN_IN_USE)) {
  105385:	f6 42 19 01          	testb  $0x1,0x19(%edx)
  105389:	74 0d                	je     105398 <net_conn_unregister+0x2e>
	conn->flags = 0;
  10538b:	c6 42 19 00          	movb   $0x0,0x19(%edx)
	return 0;
  10538f:	31 c0                	xor    %eax,%eax
  105391:	eb 05                	jmp    105398 <net_conn_unregister+0x2e>
		return -EINVAL;
  105393:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  105398:	5d                   	pop    %ebp
  105399:	c3                   	ret    

0010539a <net_conn_register>:
{
  10539a:	55                   	push   %ebp
  10539b:	89 e5                	mov    %esp,%ebp
  10539d:	57                   	push   %edi
  10539e:	56                   	push   %esi
  10539f:	53                   	push   %ebx
  1053a0:	83 ec 10             	sub    $0x10,%esp
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
  1053a3:	31 db                	xor    %ebx,%ebx
{
  1053a5:	8b 45 14             	mov    0x14(%ebp),%eax
  1053a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1053ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1053ae:	8b 45 18             	mov    0x18(%ebp),%eax
  1053b1:	8b 55 10             	mov    0x10(%ebp),%edx
  1053b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1053b7:	6b fb 1c             	imul   $0x1c,%ebx,%edi
		if (conns[i].flags & NET_CONN_IN_USE) {
  1053ba:	8a 87 f9 99 10 00    	mov    0x1099f9(%edi),%al
  1053c0:	a8 01                	test   $0x1,%al
  1053c2:	74 10                	je     1053d4 <net_conn_register+0x3a>
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
  1053c4:	43                   	inc    %ebx
  1053c5:	83 fb 04             	cmp    $0x4,%ebx
  1053c8:	75 ed                	jne    1053b7 <net_conn_register+0x1d>
	return -ENOENT;
  1053ca:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  1053cf:	e9 1c 01 00 00       	jmp    1054f0 <net_conn_register+0x156>
		if (remote_addr) {
  1053d4:	85 c9                	test   %ecx,%ecx
  1053d6:	75 04                	jne    1053dc <net_conn_register+0x42>
	uint8_t rank = 0;
  1053d8:	31 f6                	xor    %esi,%esi
  1053da:	eb 4f                	jmp    10542b <net_conn_register+0x91>
			if (remote_addr->family != AF_INET &&
  1053dc:	66 8b 31             	mov    (%ecx),%si
  1053df:	83 e6 f7             	and    $0xfffffff7,%esi
  1053e2:	66 83 fe 02          	cmp    $0x2,%si
  1053e6:	74 0a                	je     1053f2 <net_conn_register+0x58>
				return -EINVAL;
  1053e8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1053ed:	e9 fe 00 00 00       	jmp    1054f0 <net_conn_register+0x156>
			conns[i].flags |= NET_CONN_REMOTE_ADDR_SET;
  1053f2:	83 c8 02             	or     $0x2,%eax
  1053f5:	8d b7 e0 99 10 00    	lea    0x1099e0(%edi),%esi
			memcpy(&conns[i].remote_addr, remote_addr,
  1053fb:	6a 08                	push   $0x8
  1053fd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  105400:	51                   	push   %ecx
  105401:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  105404:	56                   	push   %esi
			conns[i].flags |= NET_CONN_REMOTE_ADDR_SET;
  105405:	88 87 f9 99 10 00    	mov    %al,0x1099f9(%edi)
			memcpy(&conns[i].remote_addr, remote_addr,
  10540b:	e8 5d c0 ff ff       	call   10146d <memcpy>
			if (remote_addr->family == AF_INET) {
  105410:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			memcpy(&conns[i].remote_addr, remote_addr,
  105413:	83 c4 0c             	add    $0xc,%esp
			if (remote_addr->family == AF_INET) {
  105416:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  105419:	66 83 39 02          	cmpw   $0x2,(%ecx)
  10541d:	75 b9                	jne    1053d8 <net_conn_register+0x3e>
					rank |= NET_RANK_REMOTE_UNSPEC_ADDR;
  10541f:	83 79 04 01          	cmpl   $0x1,0x4(%ecx)
  105423:	19 f6                	sbb    %esi,%esi
  105425:	83 e6 e8             	and    $0xffffffe8,%esi
  105428:	83 c6 20             	add    $0x20,%esi
		if (local_addr) {
  10542b:	85 d2                	test   %edx,%edx
  10542d:	74 48                	je     105477 <net_conn_register+0xdd>
			if (local_addr->family != AF_INET &&
  10542f:	66 8b 02             	mov    (%edx),%ax
  105432:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  105435:	83 e0 f7             	and    $0xfffffff7,%eax
  105438:	66 83 f8 02          	cmp    $0x2,%ax
  10543c:	75 aa                	jne    1053e8 <net_conn_register+0x4e>
			conns[i].flags |= NET_CONN_LOCAL_ADDR_SET;
  10543e:	6b c3 1c             	imul   $0x1c,%ebx,%eax
			memcpy(&conns[i].local_addr, local_addr,
  105441:	6a 08                	push   $0x8
  105443:	89 55 e8             	mov    %edx,-0x18(%ebp)
			conns[i].flags |= NET_CONN_LOCAL_ADDR_SET;
  105446:	80 88 f9 99 10 00 04 	orb    $0x4,0x1099f9(%eax)
			memcpy(&conns[i].local_addr, local_addr,
  10544d:	8d 87 e8 99 10 00    	lea    0x1099e8(%edi),%eax
  105453:	52                   	push   %edx
  105454:	50                   	push   %eax
  105455:	e8 13 c0 ff ff       	call   10146d <memcpy>
			if (local_addr->family == AF_INET) {
  10545a:	8b 55 e8             	mov    -0x18(%ebp),%edx
			memcpy(&conns[i].local_addr, local_addr,
  10545d:	83 c4 0c             	add    $0xc,%esp
			if (local_addr->family == AF_INET) {
  105460:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105463:	66 83 3a 02          	cmpw   $0x2,(%edx)
  105467:	75 0e                	jne    105477 <net_conn_register+0xdd>
				if (!net_sin(local_addr)->sin_addr.s_addr[0]) {
  105469:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  10546d:	75 05                	jne    105474 <net_conn_register+0xda>
					rank |= NET_RANK_LOCAL_UNSPEC_ADDR;
  10546f:	83 ce 04             	or     $0x4,%esi
  105472:	eb 03                	jmp    105477 <net_conn_register+0xdd>
					rank |= NET_RANK_LOCAL_SPEC_ADDR;
  105474:	83 ce 10             	or     $0x10,%esi
		if (remote_addr && local_addr) {
  105477:	85 c9                	test   %ecx,%ecx
  105479:	74 10                	je     10548b <net_conn_register+0xf1>
  10547b:	85 d2                	test   %edx,%edx
  10547d:	74 0c                	je     10548b <net_conn_register+0xf1>
			if (remote_addr->family != local_addr->family) {
  10547f:	66 8b 02             	mov    (%edx),%ax
  105482:	66 39 01             	cmp    %ax,(%ecx)
  105485:	0f 85 5d ff ff ff    	jne    1053e8 <net_conn_register+0x4e>
		if (remote_port) {
  10548b:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  105490:	74 0f                	je     1054a1 <net_conn_register+0x107>
			net_sin(&conns[i].remote_addr)->sin_port =
  105492:	8b 45 f0             	mov    -0x10(%ebp),%eax
			rank |= NET_RANK_REMOTE_PORT;
  105495:	83 ce 02             	or     $0x2,%esi
			net_sin(&conns[i].remote_addr)->sin_port =
  105498:	86 e0                	xchg   %ah,%al
  10549a:	66 89 87 e2 99 10 00 	mov    %ax,0x1099e2(%edi)
		if (local_port) {
  1054a1:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%ebp)
  1054a6:	74 0f                	je     1054b7 <net_conn_register+0x11d>
			net_sin(&conns[i].local_addr)->sin_port =
  1054a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
			rank |= NET_RANK_LOCAL_PORT;
  1054ab:	83 ce 01             	or     $0x1,%esi
			net_sin(&conns[i].local_addr)->sin_port =
  1054ae:	86 e0                	xchg   %ah,%al
  1054b0:	66 89 87 ea 99 10 00 	mov    %ax,0x1099ea(%edi)
		conns[i].flags |= NET_CONN_IN_USE;
  1054b7:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  1054ba:	81 c3 e0 99 10 00    	add    $0x1099e0,%ebx
		conns[i].cb = cb;
  1054c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
  1054c3:	89 43 10             	mov    %eax,0x10(%ebx)
		conns[i].user_data = user_data;
  1054c6:	8b 45 20             	mov    0x20(%ebp),%eax
  1054c9:	89 43 14             	mov    %eax,0x14(%ebx)
		conns[i].rank = rank;
  1054cc:	89 f0                	mov    %esi,%eax
  1054ce:	88 43 1a             	mov    %al,0x1a(%ebx)
		conns[i].proto = proto;
  1054d1:	8b 45 08             	mov    0x8(%ebp),%eax
		conns[i].flags |= NET_CONN_IN_USE;
  1054d4:	80 4b 19 01          	orb    $0x1,0x19(%ebx)
		conns[i].proto = proto;
  1054d8:	88 43 18             	mov    %al,0x18(%ebx)
		return 0;
  1054db:	31 c0                	xor    %eax,%eax
		if (handle) {
  1054dd:	83 7d 24 00          	cmpl   $0x0,0x24(%ebp)
  1054e1:	74 0d                	je     1054f0 <net_conn_register+0x156>
			*handle = (struct net_conn_handle *)&conns[i];
  1054e3:	8b 45 24             	mov    0x24(%ebp),%eax
  1054e6:	81 c7 e0 99 10 00    	add    $0x1099e0,%edi
  1054ec:	89 38                	mov    %edi,(%eax)
		return 0;
  1054ee:	31 c0                	xor    %eax,%eax
}
  1054f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1054f3:	5b                   	pop    %ebx
  1054f4:	5e                   	pop    %esi
  1054f5:	5f                   	pop    %edi
  1054f6:	5d                   	pop    %ebp
  1054f7:	c3                   	ret    

001054f8 <net_conn_input>:
#endif /* CONFIG_NET_IPV4 */
	}
}

enum net_verdict net_conn_input(enum net_ip_protocol proto, struct net_buf *buf)
{
  1054f8:	55                   	push   %ebp
  1054f9:	89 e5                	mov    %esp,%ebp
  1054fb:	57                   	push   %edi
  1054fc:	56                   	push   %esi
  1054fd:	53                   	push   %ebx
  1054fe:	83 ec 0c             	sub    $0xc,%esp
  105501:	bf e0 99 10 00       	mov    $0x1099e0,%edi
  105506:	8b 75 0c             	mov    0xc(%ebp),%esi
	int i, best_match = -1;
	int16_t best_rank = -1;
  105509:	66 c7 45 f0 ff ff    	movw   $0xffff,-0x10(%ebp)
	int i, best_match = -1;
  10550f:	83 cb ff             	or     $0xffffffff,%ebx
		"family %d", proto2str(proto), buf,
		ntohs(NET_CONN_BUF(buf)->src_port),
		ntohs(NET_CONN_BUF(buf)->dst_port),
		net_nbuf_family(buf));

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
  105512:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
  105519:	8a 47 19             	mov    0x19(%edi),%al
  10551c:	88 45 f3             	mov    %al,-0xd(%ebp)
  10551f:	a8 01                	test   $0x1,%al
  105521:	0f 84 9a 00 00 00    	je     1055c1 <net_conn_input+0xc9>
			continue;
		}

		if (conns[i].proto != proto) {
  105527:	0f b6 47 18          	movzbl 0x18(%edi),%eax
  10552b:	3b 45 08             	cmp    0x8(%ebp),%eax
  10552e:	0f 85 8d 00 00 00    	jne    1055c1 <net_conn_input+0xc9>
			continue;
		}

		if (net_sin(&conns[i].remote_addr)->sin_port) {
  105534:	66 8b 57 02          	mov    0x2(%edi),%dx
  105538:	66 85 d2             	test   %dx,%dx
  10553b:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10553e:	74 0f                	je     10554f <net_conn_input+0x57>
			if (net_sin(&conns[i].remote_addr)->sin_port !=
			    NET_CONN_BUF(buf)->src_port) {
  105540:	89 f0                	mov    %esi,%eax
  105542:	e8 a9 fd ff ff       	call   1052f0 <net_nbuf_udp_data>
			if (net_sin(&conns[i].remote_addr)->sin_port !=
  105547:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10554a:	66 3b 10             	cmp    (%eax),%dx
  10554d:	75 72                	jne    1055c1 <net_conn_input+0xc9>
				continue;
			}
		}

		if (net_sin(&conns[i].local_addr)->sin_port) {
  10554f:	66 8b 57 0a          	mov    0xa(%edi),%dx
  105553:	66 85 d2             	test   %dx,%dx
  105556:	89 55 e8             	mov    %edx,-0x18(%ebp)
  105559:	74 10                	je     10556b <net_conn_input+0x73>
			if (net_sin(&conns[i].local_addr)->sin_port !=
			    NET_CONN_BUF(buf)->dst_port) {
  10555b:	89 f0                	mov    %esi,%eax
  10555d:	e8 8e fd ff ff       	call   1052f0 <net_nbuf_udp_data>
			if (net_sin(&conns[i].local_addr)->sin_port !=
  105562:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105565:	66 3b 50 02          	cmp    0x2(%eax),%dx
  105569:	75 56                	jne    1055c1 <net_conn_input+0xc9>
				continue;
			}
		}

		if (conns[i].flags & NET_CONN_REMOTE_ADDR_SET) {
  10556b:	f6 45 f3 02          	testb  $0x2,-0xd(%ebp)
  10556f:	74 12                	je     105583 <net_conn_input+0x8b>
			if (!check_addr(buf, &conns[i].remote_addr, true)) {
  105571:	b9 01 00 00 00       	mov    $0x1,%ecx
  105576:	89 fa                	mov    %edi,%edx
  105578:	89 f0                	mov    %esi,%eax
  10557a:	e8 90 fd ff ff       	call   10530f <check_addr>
  10557f:	84 c0                	test   %al,%al
  105581:	74 3e                	je     1055c1 <net_conn_input+0xc9>
				continue;
			}
		}

		if (conns[i].flags & NET_CONN_LOCAL_ADDR_SET) {
  105583:	f6 45 f3 04          	testb  $0x4,-0xd(%ebp)
  105587:	74 10                	je     105599 <net_conn_input+0xa1>
			if (!check_addr(buf, &conns[i].local_addr, false)) {
  105589:	31 c9                	xor    %ecx,%ecx
  10558b:	8d 57 08             	lea    0x8(%edi),%edx
  10558e:	89 f0                	mov    %esi,%eax
  105590:	e8 7a fd ff ff       	call   10530f <check_addr>
  105595:	84 c0                	test   %al,%al
  105597:	74 28                	je     1055c1 <net_conn_input+0xc9>

		/* If we have an existing best_match, and that one
		 * specifies a remote port, then we've matched to a
		 * LISTENING connection that should not override.
		 */
		if (best_match >= 0 &&
  105599:	83 fb ff             	cmp    $0xffffffff,%ebx
  10559c:	74 0d                	je     1055ab <net_conn_input+0xb3>
		    net_sin(&conns[best_match].remote_addr)->sin_port) {
  10559e:	6b c3 1c             	imul   $0x1c,%ebx,%eax
		if (best_match >= 0 &&
  1055a1:	66 83 b8 e2 99 10 00 	cmpw   $0x0,0x1099e2(%eax)
  1055a8:	00 
  1055a9:	75 16                	jne    1055c1 <net_conn_input+0xc9>
			continue;
		}

		if (best_rank < conns[i].rank) {
  1055ab:	0f b6 4f 1a          	movzbl 0x1a(%edi),%ecx
  1055af:	0f bf 45 f0          	movswl -0x10(%ebp),%eax
  1055b3:	39 c8                	cmp    %ecx,%eax
  1055b5:	7d 0a                	jge    1055c1 <net_conn_input+0xc9>
			best_rank = conns[i].rank;
  1055b7:	0f b6 c1             	movzbl %cl,%eax
  1055ba:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  1055be:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
  1055c1:	ff 45 ec             	incl   -0x14(%ebp)
  1055c4:	83 c7 1c             	add    $0x1c,%edi
  1055c7:	83 7d ec 04          	cmpl   $0x4,-0x14(%ebp)
  1055cb:	0f 85 48 ff ff ff    	jne    105519 <net_conn_input+0x21>
			best_match = i;
		}
	}

	if (best_match >= 0) {
  1055d1:	83 fb ff             	cmp    $0xffffffff,%ebx
  1055d4:	74 20                	je     1055f6 <net_conn_input+0xfe>
			conns[best_match].cb,
			conns[best_match].user_data,
			conns[best_match].rank);
#endif /* CONFIG_NET_CONN_CACHE */

		if (conns[best_match].cb(&conns[best_match], buf,
  1055d6:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  1055d9:	ff b3 f4 99 10 00    	pushl  0x1099f4(%ebx)
  1055df:	81 c3 e0 99 10 00    	add    $0x1099e0,%ebx
  1055e5:	56                   	push   %esi
  1055e6:	53                   	push   %ebx
  1055e7:	ff 53 10             	call   *0x10(%ebx)
  1055ea:	83 c4 0c             	add    $0xc,%esp
  1055ed:	83 f8 02             	cmp    $0x2,%eax
  1055f0:	74 3b                	je     10562d <net_conn_input+0x135>

		if (proto == IPPROTO_UDP) {
			net_stats_update_udp_recv();
		}

		return NET_OK;
  1055f2:	31 c0                	xor    %eax,%eax
  1055f4:	eb 3c                	jmp    105632 <net_conn_input+0x13a>
  1055f6:	0f b7 46 16          	movzwl 0x16(%esi),%eax
  1055fa:	8d 44 06 1b          	lea    0x1b(%esi,%eax,1),%eax
  1055fe:	83 e0 fc             	and    $0xfffffffc,%eax
  105601:	8a 40 29             	mov    0x29(%eax),%al
	    net_is_ipv6_addr_mcast(&NET_IPV6_BUF(buf)->dst)) {
		;
	} else
#endif
#if defined(CONFIG_NET_IPV4)
	if (net_nbuf_family(buf) == AF_INET &&
  105604:	3c 02                	cmp    $0x2,%al
  105606:	75 14                	jne    10561c <net_conn_input+0x124>
	return buf->frags->data;
  105608:	8b 06                	mov    (%esi),%eax
  10560a:	8b 40 10             	mov    0x10(%eax),%eax
  10560d:	8b 40 10             	mov    0x10(%eax),%eax
  105610:	25 00 00 00 e0       	and    $0xe0000000,%eax
  105615:	3d 00 00 00 e0       	cmp    $0xe0000000,%eax
  10561a:	eb 02                	jmp    10561e <net_conn_input+0x126>
	if (net_nbuf_family(buf) == AF_INET6) {
  10561c:	3c 0a                	cmp    $0xa,%al
  10561e:	74 0d                	je     10562d <net_conn_input+0x135>
		net_icmpv4_send_error(buf, NET_ICMPV4_DST_UNREACH,
  105620:	6a 03                	push   $0x3
  105622:	6a 03                	push   $0x3
  105624:	56                   	push   %esi
  105625:	e8 d1 ef ff ff       	call   1045fb <net_icmpv4_send_error>
  10562a:	83 c4 0c             	add    $0xc,%esp
drop:
	if (proto == IPPROTO_UDP) {
		net_stats_update_udp_drop();
	}

	return NET_DROP;
  10562d:	b8 02 00 00 00       	mov    $0x2,%eax
}
  105632:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105635:	5b                   	pop    %ebx
  105636:	5e                   	pop    %esi
  105637:	5f                   	pop    %edi
  105638:	5d                   	pop    %ebp
  105639:	c3                   	ret    

0010563a <net_conn_init>:

void net_conn_init(void)
{
  10563a:	55                   	push   %ebp
  10563b:	89 e5                	mov    %esp,%ebp
		for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
			conn_cache[i].idx = -1;
		}
	} while (0);
#endif /* CONFIG_NET_CONN_CACHE */
}
  10563d:	5d                   	pop    %ebp
  10563e:	c3                   	ret    

0010563f <rlen_encode>:
 * @param [in] len Value to encode
 *
 * @retval 0 always
 */
static int rlen_encode(uint8_t *buf, uint32_t len)
{
  10563f:	55                   	push   %ebp
	uint8_t encoded;
	uint8_t i;

	i = 0;
  105640:	31 c9                	xor    %ecx,%ecx
{
  105642:	89 e5                	mov    %esp,%ebp
  105644:	56                   	push   %esi
  105645:	53                   	push   %ebx
	do {
		encoded = len % 128;
  105646:	88 d3                	mov    %dl,%bl
  105648:	83 e3 7f             	and    $0x7f,%ebx
		len = len / 128;
		/* if there are more data to encode,
		 * set the top bit of this byte
		 */
		if (len > 0) {
  10564b:	c1 ea 07             	shr    $0x7,%edx
  10564e:	74 03                	je     105653 <rlen_encode+0x14>
			encoded = encoded | 128;
  105650:	83 cb 80             	or     $0xffffff80,%ebx
		}
		buf[i++] = encoded;
  105653:	8d 71 01             	lea    0x1(%ecx),%esi
	} while (len > 0);
  105656:	85 d2                	test   %edx,%edx
		buf[i++] = encoded;
  105658:	0f b6 c9             	movzbl %cl,%ecx
  10565b:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
	} while (len > 0);
  10565e:	74 04                	je     105664 <rlen_encode+0x25>
		buf[i++] = encoded;
  105660:	89 f1                	mov    %esi,%ecx
  105662:	eb e2                	jmp    105646 <rlen_encode+0x7>

	return 0;
}
  105664:	5b                   	pop    %ebx
  105665:	31 c0                	xor    %eax,%eax
  105667:	5e                   	pop    %esi
  105668:	5d                   	pop    %ebp
  105669:	c3                   	ret    

0010566a <rlen_decode>:
 * @retval 0 on success
 * @retval -ENOMEM if size < 4
 */
static int rlen_decode(uint32_t *rlen, uint16_t *rlen_size,
		       uint8_t *buf, uint16_t size)
{
  10566a:	55                   	push   %ebp
  10566b:	89 e5                	mov    %esp,%ebp
  10566d:	57                   	push   %edi
  10566e:	56                   	push   %esi
  10566f:	53                   	push   %ebx
  105670:	83 ec 18             	sub    $0x18,%esp
	uint32_t value = 0;
	uint32_t mult = 1;
	uint16_t i = 0;
  105673:	31 db                	xor    %ebx,%ebx
{
  105675:	8b 75 08             	mov    0x8(%ebp),%esi
	uint32_t mult = 1;
  105678:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
{
  10567f:	66 89 75 de          	mov    %si,-0x22(%ebp)
	uint32_t value = 0;
  105683:	31 ff                	xor    %edi,%edi
	uint8_t encoded;

	do {
		if (i >= ENCLENBUF_MAX_SIZE || i >= size) {
  105685:	66 83 fb 03          	cmp    $0x3,%bx
  105689:	77 33                	ja     1056be <rlen_decode+0x54>
  10568b:	66 3b 5d de          	cmp    -0x22(%ebp),%bx
  10568f:	73 2d                	jae    1056be <rlen_decode+0x54>
			return -ENOMEM;
		}

		encoded = buf[i++];
  105691:	8d 73 01             	lea    0x1(%ebx),%esi
  105694:	8a 1c 19             	mov    (%ecx,%ebx,1),%bl
  105697:	88 5d e0             	mov    %bl,-0x20(%ebp)
		value += (encoded & 127) * mult;
  10569a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  10569d:	83 e3 7f             	and    $0x7f,%ebx
  1056a0:	0f af 5d f0          	imul   -0x10(%ebp),%ebx
		mult *= 128;
  1056a4:	c1 65 f0 07          	shll   $0x7,-0x10(%ebp)
		value += (encoded & 127) * mult;
  1056a8:	01 df                	add    %ebx,%edi
	} while ((encoded & 128) != 0);
  1056aa:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
  1056ae:	79 05                	jns    1056b5 <rlen_decode+0x4b>
		encoded = buf[i++];
  1056b0:	0f b7 de             	movzwl %si,%ebx
  1056b3:	eb d0                	jmp    105685 <rlen_decode+0x1b>

	*rlen = value;
  1056b5:	89 38                	mov    %edi,(%eax)
	*rlen_size = i;
  1056b7:	66 89 32             	mov    %si,(%edx)

	return 0;
  1056ba:	31 c0                	xor    %eax,%eax
  1056bc:	eb 05                	jmp    1056c3 <rlen_decode+0x59>
			return -ENOMEM;
  1056be:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
  1056c3:	83 c4 18             	add    $0x18,%esp
  1056c6:	5b                   	pop    %ebx
  1056c7:	5e                   	pop    %esi
  1056c8:	5f                   	pop    %edi
  1056c9:	5d                   	pop    %ebp
  1056ca:	c3                   	ret    

001056cb <unpack_pktid_validate>:
 */
static
int unpack_pktid(uint8_t *buf, uint16_t length, enum mqtt_packet *type,
		 uint8_t *reserved, uint16_t *pkt_id)
{
	if (length < MSG_PKTID_ONLY_SIZE) {
  1056cb:	66 83 fa 03          	cmp    $0x3,%dx
 * @retval -EINVAL
 */
static
int unpack_pktid_validate(uint8_t *buf, uint16_t length, uint16_t *pkt_id,
			  uint8_t expected_type, uint8_t expected_reserv)
{
  1056cf:	55                   	push   %ebp
  1056d0:	89 e5                	mov    %esp,%ebp
  1056d2:	56                   	push   %esi
  1056d3:	53                   	push   %ebx
  1056d4:	8b 75 08             	mov    0x8(%ebp),%esi
  1056d7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (length < MSG_PKTID_ONLY_SIZE) {
  1056da:	77 07                	ja     1056e3 <unpack_pktid_validate+0x18>
{
  1056dc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1056e1:	eb 25                	jmp    105708 <unpack_pktid_validate+0x3d>
	if (buf[1] != PACKET_ID_SIZE) {
  1056e3:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  1056e7:	75 f3                	jne    1056dc <unpack_pktid_validate+0x11>
	*type = buf[0] >> 4;
  1056e9:	8a 10                	mov    (%eax),%dl
	*pkt_id = ntohs(*(uint16_t *)(buf + 2));
  1056eb:	66 8b 40 02          	mov    0x2(%eax),%ax
  1056ef:	86 e0                	xchg   %ah,%al
  1056f1:	66 89 01             	mov    %ax,(%ecx)
	*type = buf[0] >> 4;
  1056f4:	88 d0                	mov    %dl,%al
	rc = unpack_pktid(buf, length, &type, &reserved, pkt_id);
	if (rc != 0) {
		return rc;
	}

	if (type != expected_type || reserved != expected_reserv) {
  1056f6:	89 f1                	mov    %esi,%ecx
	*type = buf[0] >> 4;
  1056f8:	c0 e8 04             	shr    $0x4,%al
	if (type != expected_type || reserved != expected_reserv) {
  1056fb:	38 c8                	cmp    %cl,%al
  1056fd:	75 dd                	jne    1056dc <unpack_pktid_validate+0x11>
	*reserved = buf[0] & 0x0F;
  1056ff:	83 e2 0f             	and    $0xf,%edx
	if (type != expected_type || reserved != expected_reserv) {
  105702:	38 da                	cmp    %bl,%dl
  105704:	75 d6                	jne    1056dc <unpack_pktid_validate+0x11>
		return -EINVAL;
	}

	return 0;
  105706:	31 c0                	xor    %eax,%eax
}
  105708:	5b                   	pop    %ebx
  105709:	5e                   	pop    %esi
  10570a:	5d                   	pop    %ebp
  10570b:	c3                   	ret    

0010570c <compute_rlen_size>:
{
  10570c:	55                   	push   %ebp
	if (len <= 127) {
  10570d:	83 fa 7f             	cmp    $0x7f,%edx
{
  105710:	89 e5                	mov    %esp,%ebp
	if (len <= 127) {
  105712:	77 07                	ja     10571b <compute_rlen_size+0xf>
		*size = 1;
  105714:	66 c7 00 01 00       	movw   $0x1,(%eax)
  105719:	eb 3f                	jmp    10575a <compute_rlen_size+0x4e>
	} else if (len >= 128 && len <= 16383) {
  10571b:	8d 4a 80             	lea    -0x80(%edx),%ecx
  10571e:	81 f9 7f 3f 00 00    	cmp    $0x3f7f,%ecx
  105724:	77 07                	ja     10572d <compute_rlen_size+0x21>
		*size = 2;
  105726:	66 c7 00 02 00       	movw   $0x2,(%eax)
  10572b:	eb 2d                	jmp    10575a <compute_rlen_size+0x4e>
	} else if (len >= 16384 && len <= 2097151) {
  10572d:	8d 8a 00 c0 ff ff    	lea    -0x4000(%edx),%ecx
  105733:	81 f9 ff bf 1f 00    	cmp    $0x1fbfff,%ecx
  105739:	77 07                	ja     105742 <compute_rlen_size+0x36>
		*size = 3;
  10573b:	66 c7 00 03 00       	movw   $0x3,(%eax)
  105740:	eb 18                	jmp    10575a <compute_rlen_size+0x4e>
	} else if (len >= 2097152 && len <= 268435455) {
  105742:	81 ea 00 00 20 00    	sub    $0x200000,%edx
		return -EINVAL;
  105748:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
	} else if (len >= 2097152 && len <= 268435455) {
  10574d:	81 fa ff ff df 0f    	cmp    $0xfdfffff,%edx
  105753:	77 07                	ja     10575c <compute_rlen_size+0x50>
		*size = 4;
  105755:	66 c7 00 04 00       	movw   $0x4,(%eax)
	return 0;
  10575a:	31 c9                	xor    %ecx,%ecx
}
  10575c:	89 c8                	mov    %ecx,%eax
  10575e:	5d                   	pop    %ebp
  10575f:	c3                   	ret    

00105760 <unpack_zerolen_validate.constprop.1>:
 */
static
int unpack_zerolen(uint8_t *buf, uint16_t length, enum mqtt_packet *pkt_type,
		   uint8_t *reserved)
{
	if (length < MSG_ZEROLEN_SIZE) {
  105760:	66 83 fa 01          	cmp    $0x1,%dx
  105764:	76 25                	jbe    10578b <unpack_zerolen_validate.constprop.1+0x2b>
 *
 * @retval 0 on success
 * @retval -EINVAL
 */
static
int unpack_zerolen_validate(uint8_t *buf, uint16_t length,
  105766:	55                   	push   %ebp
  105767:	89 e5                	mov    %esp,%ebp
  105769:	53                   	push   %ebx
	*pkt_type = buf[0] >> 4;
  10576a:	8a 10                	mov    (%eax),%dl
	rc = unpack_zerolen(buf, length, &pkt_type, &reserved);
	if (rc != 0) {
		return rc;
	}

	if (pkt_type != expected_type || reserved != expected_reserved) {
  10576c:	f6 c2 0f             	test   $0xf,%dl
  10576f:	0f 95 c3             	setne  %bl
	if (buf[1] != 0) {
  105772:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
  105776:	0f 95 c0             	setne  %al
	if (pkt_type != expected_type || reserved != expected_reserved) {
  105779:	08 c3                	or     %al,%bl
  10577b:	75 14                	jne    105791 <unpack_zerolen_validate.constprop.1+0x31>
	*pkt_type = buf[0] >> 4;
  10577d:	c0 ea 04             	shr    $0x4,%dl
		return -EINVAL;
	}

	return 0;
  105780:	31 c0                	xor    %eax,%eax
	*pkt_type = buf[0] >> 4;
  105782:	0f b6 d2             	movzbl %dl,%edx
	if (pkt_type != expected_type || reserved != expected_reserved) {
  105785:	39 ca                	cmp    %ecx,%edx
  105787:	74 0d                	je     105796 <unpack_zerolen_validate.constprop.1+0x36>
  105789:	eb 06                	jmp    105791 <unpack_zerolen_validate.constprop.1+0x31>
	if (length < MSG_ZEROLEN_SIZE) {
  10578b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  105790:	c3                   	ret    
	if (pkt_type != expected_type || reserved != expected_reserved) {
  105791:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  105796:	5b                   	pop    %ebx
  105797:	5d                   	pop    %ebp
  105798:	c3                   	ret    

00105799 <mqtt_pack_puback>:
{
  105799:	55                   	push   %ebp
  10579a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  10579f:	89 e5                	mov    %esp,%ebp
  1057a1:	8b 55 08             	mov    0x8(%ebp),%edx
  1057a4:	8b 4d 14             	mov    0x14(%ebp),%ecx
	if (size < MSG_PKTID_ONLY_SIZE) {
  1057a7:	66 83 7d 10 03       	cmpw   $0x3,0x10(%ebp)
  1057ac:	76 19                	jbe    1057c7 <mqtt_pack_puback+0x2e>
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  1057ae:	89 c8                	mov    %ecx,%eax
	buf[0] = (type << 4) + (reserved & 0x0F);
  1057b0:	c6 02 40             	movb   $0x40,(%edx)
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  1057b3:	86 e0                	xchg   %ah,%al
  1057b5:	66 89 42 02          	mov    %ax,0x2(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  1057b9:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf[1] = PACKET_ID_SIZE;
  1057bc:	c6 42 01 02          	movb   $0x2,0x1(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  1057c0:	66 c7 00 04 00       	movw   $0x4,(%eax)
	return 0;
  1057c5:	31 c0                	xor    %eax,%eax
}
  1057c7:	5d                   	pop    %ebp
  1057c8:	c3                   	ret    

001057c9 <mqtt_pack_pubrec>:
{
  1057c9:	55                   	push   %ebp
  1057ca:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  1057cf:	89 e5                	mov    %esp,%ebp
  1057d1:	8b 55 08             	mov    0x8(%ebp),%edx
  1057d4:	8b 4d 14             	mov    0x14(%ebp),%ecx
	if (size < MSG_PKTID_ONLY_SIZE) {
  1057d7:	66 83 7d 10 03       	cmpw   $0x3,0x10(%ebp)
  1057dc:	76 19                	jbe    1057f7 <mqtt_pack_pubrec+0x2e>
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  1057de:	89 c8                	mov    %ecx,%eax
	buf[0] = (type << 4) + (reserved & 0x0F);
  1057e0:	c6 02 50             	movb   $0x50,(%edx)
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  1057e3:	86 e0                	xchg   %ah,%al
  1057e5:	66 89 42 02          	mov    %ax,0x2(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  1057e9:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf[1] = PACKET_ID_SIZE;
  1057ec:	c6 42 01 02          	movb   $0x2,0x1(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  1057f0:	66 c7 00 04 00       	movw   $0x4,(%eax)
	return 0;
  1057f5:	31 c0                	xor    %eax,%eax
}
  1057f7:	5d                   	pop    %ebp
  1057f8:	c3                   	ret    

001057f9 <mqtt_pack_pubrel>:
{
  1057f9:	55                   	push   %ebp
  1057fa:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  1057ff:	89 e5                	mov    %esp,%ebp
  105801:	8b 55 08             	mov    0x8(%ebp),%edx
  105804:	8b 4d 14             	mov    0x14(%ebp),%ecx
	if (size < MSG_PKTID_ONLY_SIZE) {
  105807:	66 83 7d 10 03       	cmpw   $0x3,0x10(%ebp)
  10580c:	76 19                	jbe    105827 <mqtt_pack_pubrel+0x2e>
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  10580e:	89 c8                	mov    %ecx,%eax
	buf[0] = (type << 4) + (reserved & 0x0F);
  105810:	c6 02 62             	movb   $0x62,(%edx)
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  105813:	86 e0                	xchg   %ah,%al
  105815:	66 89 42 02          	mov    %ax,0x2(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  105819:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf[1] = PACKET_ID_SIZE;
  10581c:	c6 42 01 02          	movb   $0x2,0x1(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  105820:	66 c7 00 04 00       	movw   $0x4,(%eax)
	return 0;
  105825:	31 c0                	xor    %eax,%eax
}
  105827:	5d                   	pop    %ebp
  105828:	c3                   	ret    

00105829 <mqtt_pack_pubcomp>:
{
  105829:	55                   	push   %ebp
  10582a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  10582f:	89 e5                	mov    %esp,%ebp
  105831:	8b 55 08             	mov    0x8(%ebp),%edx
  105834:	8b 4d 14             	mov    0x14(%ebp),%ecx
	if (size < MSG_PKTID_ONLY_SIZE) {
  105837:	66 83 7d 10 03       	cmpw   $0x3,0x10(%ebp)
  10583c:	76 19                	jbe    105857 <mqtt_pack_pubcomp+0x2e>
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  10583e:	89 c8                	mov    %ecx,%eax
	buf[0] = (type << 4) + (reserved & 0x0F);
  105840:	c6 02 70             	movb   $0x70,(%edx)
	UNALIGNED_PUT(htons(pkt_id), (uint16_t *)(buf + PACKET_ID_SIZE));
  105843:	86 e0                	xchg   %ah,%al
  105845:	66 89 42 02          	mov    %ax,0x2(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  105849:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf[1] = PACKET_ID_SIZE;
  10584c:	c6 42 01 02          	movb   $0x2,0x1(%edx)
	*length = MSG_PKTID_ONLY_SIZE;
  105850:	66 c7 00 04 00       	movw   $0x4,(%eax)
	return 0;
  105855:	31 c0                	xor    %eax,%eax
}
  105857:	5d                   	pop    %ebp
  105858:	c3                   	ret    

00105859 <mqtt_pack_connect>:
{
  105859:	55                   	push   %ebp
  10585a:	89 e5                	mov    %esp,%ebp
  10585c:	57                   	push   %edi
  10585d:	56                   	push   %esi
  10585e:	53                   	push   %ebx
  10585f:	83 ec 14             	sub    $0x14,%esp
  105862:	8b 5d 14             	mov    0x14(%ebp),%ebx
  105865:	8b 45 10             	mov    0x10(%ebp),%eax
  105868:	8b 7d 08             	mov    0x8(%ebp),%edi
  10586b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pkt_size += msg->client_id_len;
  10586e:	8b 73 08             	mov    0x8(%ebx),%esi
	if (msg->will_flag) {
  105871:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  105875:	75 05                	jne    10587c <mqtt_pack_connect+0x23>
	pkt_size += msg->client_id_len;
  105877:	83 c6 02             	add    $0x2,%esi
  10587a:	eb 0a                	jmp    105886 <mqtt_pack_connect+0x2d>
		pkt_size += INT_SIZE;
  10587c:	03 73 18             	add    0x18(%ebx),%esi
		pkt_size += msg->will_msg_len;
  10587f:	8b 43 20             	mov    0x20(%ebx),%eax
  105882:	8d 74 06 06          	lea    0x6(%esi,%eax,1),%esi
	if (msg->user_name) {
  105886:	83 7b 24 00          	cmpl   $0x0,0x24(%ebx)
  10588a:	74 07                	je     105893 <mqtt_pack_connect+0x3a>
		pkt_size += msg->user_name_len;
  10588c:	8b 43 28             	mov    0x28(%ebx),%eax
  10588f:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
	if (msg->password) {
  105893:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  105897:	74 07                	je     1058a0 <mqtt_pack_connect+0x47>
		pkt_size += msg->password_len;
  105899:	8b 43 30             	mov    0x30(%ebx),%eax
  10589c:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
	pkt_size += CONNECT_VARIABLE_HDR_SIZE;
  1058a0:	83 c6 0a             	add    $0xa,%esi
	rc = compute_rlen_size(&rlen_size, pkt_size);
  1058a3:	8d 45 f2             	lea    -0xe(%ebp),%eax
  1058a6:	0f b7 ce             	movzwl %si,%ecx
  1058a9:	89 ca                	mov    %ecx,%edx
  1058ab:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1058ae:	e8 59 fe ff ff       	call   10570c <compute_rlen_size>
  1058b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (rc != 0) {
  1058b6:	85 c0                	test   %eax,%eax
  1058b8:	0f 85 a0 01 00 00    	jne    105a5e <mqtt_pack_connect+0x205>
	total_buf_size = PACKET_TYPE_SIZE + rlen_size + pkt_size;
  1058be:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
  1058c2:	8d 44 06 01          	lea    0x1(%esi,%eax,1),%eax
	if (total_buf_size > size) {
  1058c6:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
	total_buf_size = PACKET_TYPE_SIZE + rlen_size + pkt_size;
  1058ca:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
	if (total_buf_size > size) {
  1058ce:	0f 87 93 01 00 00    	ja     105a67 <mqtt_pack_connect+0x20e>
	rlen_encode(buf + PACKET_TYPE_SIZE, pkt_size);
  1058d4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
	buf[0] = MQTT_CONNECT << 4;
  1058d7:	c6 07 10             	movb   $0x10,(%edi)
	rlen_encode(buf + PACKET_TYPE_SIZE, pkt_size);
  1058da:	89 ca                	mov    %ecx,%edx
  1058dc:	8d 47 01             	lea    0x1(%edi),%eax
  1058df:	e8 5b fd ff ff       	call   10563f <rlen_encode>
	offset = PACKET_TYPE_SIZE + rlen_size;
  1058e4:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
  1058e8:	40                   	inc    %eax
	buf[offset + 0] = 0x00;
  1058e9:	0f b7 c0             	movzwl %ax,%eax
  1058ec:	c6 04 07 00          	movb   $0x0,(%edi,%eax,1)
	buf[offset + 1] = 0x04;
  1058f0:	c6 44 07 01 04       	movb   $0x4,0x1(%edi,%eax,1)
	buf[offset + 2] = 'M';
  1058f5:	c6 44 07 02 4d       	movb   $0x4d,0x2(%edi,%eax,1)
	buf[offset + 3] = 'Q';
  1058fa:	c6 44 07 03 51       	movb   $0x51,0x3(%edi,%eax,1)
	buf[offset + 4] = 'T';
  1058ff:	c6 44 07 04 54       	movb   $0x54,0x4(%edi,%eax,1)
	buf[offset + 5] = 'T';
  105904:	c6 44 07 05 54       	movb   $0x54,0x5(%edi,%eax,1)
	buf[offset + 6] = 0x04;
  105909:	c6 44 07 06 04       	movb   $0x4,0x6(%edi,%eax,1)
	buf[offset + 7] = (msg->user_name ? 1 << 7 : 0) |
  10590e:	83 7b 24 01          	cmpl   $0x1,0x24(%ebx)
  105912:	19 c9                	sbb    %ecx,%ecx
			  ((msg->will_qos & 0x03) << 3) |
  105914:	8b 73 0c             	mov    0xc(%ebx),%esi
	buf[offset + 7] = (msg->user_name ? 1 << 7 : 0) |
  105917:	f7 d1                	not    %ecx
  105919:	83 e1 80             	and    $0xffffff80,%ecx
  10591c:	66 83 7b 30 00       	cmpw   $0x0,0x30(%ebx)
  105921:	0f 95 c2             	setne  %dl
  105924:	c1 e2 06             	shl    $0x6,%edx
  105927:	09 d1                	or     %edx,%ecx
			  (msg->password_len ? 1 << 6 : 0) |
  105929:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  10592d:	0f 95 c2             	setne  %dl
  105930:	c1 e2 05             	shl    $0x5,%edx
			  ((msg->will_qos & 0x03) << 3) |
  105933:	c1 e6 03             	shl    $0x3,%esi
			  (msg->password_len ? 1 << 6 : 0) |
  105936:	09 ca                	or     %ecx,%edx
			  ((msg->will_qos & 0x03) << 3) |
  105938:	83 e6 18             	and    $0x18,%esi
			  (msg->will_retain ? 1 << 5 : 0) |
  10593b:	09 d6                	or     %edx,%esi
			  ((msg->will_qos & 0x03) << 3) |
  10593d:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  105941:	0f 95 c2             	setne  %dl
  105944:	c1 e2 02             	shl    $0x2,%edx
  105947:	09 d6                	or     %edx,%esi
			  (msg->will_flag ? 1 << 2 : 0) |
  105949:	f6 03 01             	testb  $0x1,(%ebx)
  10594c:	0f 95 c2             	setne  %dl
  10594f:	01 d2                	add    %edx,%edx
  105951:	09 d6                	or     %edx,%esi
  105953:	89 f1                	mov    %esi,%ecx
  105955:	88 4c 07 07          	mov    %cl,0x7(%edi,%eax,1)
	offset += 8 + INT_SIZE;
  105959:	66 8b 4d f2          	mov    -0xe(%ebp),%cx
	UNALIGNED_PUT(htons(msg->keep_alive), (uint16_t *)(buf + offset + 8));
  10595d:	66 8b 53 22          	mov    0x22(%ebx),%dx
	offset += 8 + INT_SIZE;
  105961:	83 c1 0b             	add    $0xb,%ecx
	UNALIGNED_PUT(htons(msg->keep_alive), (uint16_t *)(buf + offset + 8));
  105964:	86 f2                	xchg   %dh,%dl
  105966:	66 89 54 07 08       	mov    %dx,0x8(%edi,%eax,1)
	UNALIGNED_PUT(htons(msg->client_id_len),
  10596b:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  10596f:	0f b7 c9             	movzwl %cx,%ecx
  105972:	89 d0                	mov    %edx,%eax
  105974:	86 e0                	xchg   %ah,%al
  105976:	66 89 04 0f          	mov    %ax,(%edi,%ecx,1)
	offset += INT_SIZE;
  10597a:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
	memcpy(buf + offset, msg->client_id, msg->client_id_len);
  10597e:	52                   	push   %edx
  10597f:	ff 73 04             	pushl  0x4(%ebx)
	offset += INT_SIZE;
  105982:	8d 70 0d             	lea    0xd(%eax),%esi
	memcpy(buf + offset, msg->client_id, msg->client_id_len);
  105985:	0f b7 c6             	movzwl %si,%eax
  105988:	01 f8                	add    %edi,%eax
  10598a:	50                   	push   %eax
  10598b:	e8 dd ba ff ff       	call   10146d <memcpy>
	offset += msg->client_id_len;
  105990:	89 f0                	mov    %esi,%eax
	memcpy(buf + offset, msg->client_id, msg->client_id_len);
  105992:	83 c4 0c             	add    $0xc,%esp
	offset += msg->client_id_len;
  105995:	03 43 08             	add    0x8(%ebx),%eax
	if (msg->will_flag) {
  105998:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  10599c:	74 52                	je     1059f0 <mqtt_pack_connect+0x197>
		UNALIGNED_PUT(htons(msg->will_topic_len),
  10599e:	0f b7 4b 18          	movzwl 0x18(%ebx),%ecx
  1059a2:	0f b7 f0             	movzwl %ax,%esi
  1059a5:	89 ca                	mov    %ecx,%edx
  1059a7:	86 f2                	xchg   %dh,%dl
  1059a9:	66 89 14 37          	mov    %dx,(%edi,%esi,1)
		memcpy(buf + offset, msg->will_topic,
  1059ad:	51                   	push   %ecx
		offset += INT_SIZE;
  1059ae:	8d 70 02             	lea    0x2(%eax),%esi
		memcpy(buf + offset, msg->will_topic,
  1059b1:	ff 73 14             	pushl  0x14(%ebx)
  1059b4:	0f b7 c6             	movzwl %si,%eax
  1059b7:	01 f8                	add    %edi,%eax
  1059b9:	50                   	push   %eax
  1059ba:	e8 ae ba ff ff       	call   10146d <memcpy>
		offset += msg->will_topic_len;
  1059bf:	89 f0                	mov    %esi,%eax
		memcpy(buf + offset, msg->will_topic,
  1059c1:	83 c4 0c             	add    $0xc,%esp
		offset += msg->will_topic_len;
  1059c4:	03 43 18             	add    0x18(%ebx),%eax
		UNALIGNED_PUT(htons(msg->will_msg_len),
  1059c7:	0f b7 4b 20          	movzwl 0x20(%ebx),%ecx
  1059cb:	0f b7 f0             	movzwl %ax,%esi
  1059ce:	89 ca                	mov    %ecx,%edx
  1059d0:	86 f2                	xchg   %dh,%dl
  1059d2:	66 89 14 37          	mov    %dx,(%edi,%esi,1)
		memcpy(buf + offset, msg->will_msg, msg->will_msg_len);
  1059d6:	51                   	push   %ecx
		offset += INT_SIZE;
  1059d7:	8d 70 02             	lea    0x2(%eax),%esi
		memcpy(buf + offset, msg->will_msg, msg->will_msg_len);
  1059da:	ff 73 1c             	pushl  0x1c(%ebx)
  1059dd:	0f b7 c6             	movzwl %si,%eax
  1059e0:	01 f8                	add    %edi,%eax
  1059e2:	50                   	push   %eax
  1059e3:	e8 85 ba ff ff       	call   10146d <memcpy>
		offset += msg->will_msg_len;
  1059e8:	89 f0                	mov    %esi,%eax
		memcpy(buf + offset, msg->will_msg, msg->will_msg_len);
  1059ea:	83 c4 0c             	add    $0xc,%esp
		offset += msg->will_msg_len;
  1059ed:	03 43 20             	add    0x20(%ebx),%eax
	if (msg->user_name) {
  1059f0:	8b 4b 24             	mov    0x24(%ebx),%ecx
  1059f3:	85 c9                	test   %ecx,%ecx
  1059f5:	74 32                	je     105a29 <mqtt_pack_connect+0x1d0>
		UNALIGNED_PUT(htons(msg->user_name_len),
  1059f7:	0f b7 73 28          	movzwl 0x28(%ebx),%esi
  1059fb:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  1059fe:	89 f2                	mov    %esi,%edx
  105a00:	0f b7 f0             	movzwl %ax,%esi
  105a03:	86 f2                	xchg   %dh,%dl
  105a05:	66 89 14 37          	mov    %dx,(%edi,%esi,1)
		offset += INT_SIZE;
  105a09:	8d 50 02             	lea    0x2(%eax),%edx
		memcpy(buf + offset, msg->user_name, msg->user_name_len);
  105a0c:	ff 75 e4             	pushl  -0x1c(%ebp)
  105a0f:	0f b7 c2             	movzwl %dx,%eax
  105a12:	01 f8                	add    %edi,%eax
  105a14:	51                   	push   %ecx
  105a15:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  105a18:	50                   	push   %eax
  105a19:	e8 4f ba ff ff       	call   10146d <memcpy>
		offset += msg->user_name_len;
  105a1e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  105a21:	89 d0                	mov    %edx,%eax
		memcpy(buf + offset, msg->user_name, msg->user_name_len);
  105a23:	83 c4 0c             	add    $0xc,%esp
		offset += msg->user_name_len;
  105a26:	03 43 28             	add    0x28(%ebx),%eax
	if (msg->password) {
  105a29:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  105a2c:	85 c9                	test   %ecx,%ecx
  105a2e:	74 22                	je     105a52 <mqtt_pack_connect+0x1f9>
		UNALIGNED_PUT(htons(msg->password_len),
  105a30:	0f b7 5b 30          	movzwl 0x30(%ebx),%ebx
  105a34:	0f b7 f0             	movzwl %ax,%esi
		offset += INT_SIZE;
  105a37:	83 c0 02             	add    $0x2,%eax
		UNALIGNED_PUT(htons(msg->password_len),
  105a3a:	89 da                	mov    %ebx,%edx
		memcpy(buf + offset, msg->password, msg->password_len);
  105a3c:	0f b7 c0             	movzwl %ax,%eax
		UNALIGNED_PUT(htons(msg->password_len),
  105a3f:	86 f2                	xchg   %dh,%dl
		memcpy(buf + offset, msg->password, msg->password_len);
  105a41:	01 f8                	add    %edi,%eax
		UNALIGNED_PUT(htons(msg->password_len),
  105a43:	66 89 14 37          	mov    %dx,(%edi,%esi,1)
		memcpy(buf + offset, msg->password, msg->password_len);
  105a47:	53                   	push   %ebx
  105a48:	51                   	push   %ecx
  105a49:	50                   	push   %eax
  105a4a:	e8 1e ba ff ff       	call   10146d <memcpy>
  105a4f:	83 c4 0c             	add    $0xc,%esp
	*length = total_buf_size;
  105a52:	8b 45 0c             	mov    0xc(%ebp),%eax
  105a55:	66 8b 7d ea          	mov    -0x16(%ebp),%di
  105a59:	66 89 38             	mov    %di,(%eax)
	return 0;
  105a5c:	eb 10                	jmp    105a6e <mqtt_pack_connect+0x215>
		return -EINVAL;
  105a5e:	c7 45 ec ea ff ff ff 	movl   $0xffffffea,-0x14(%ebp)
  105a65:	eb 07                	jmp    105a6e <mqtt_pack_connect+0x215>
		return -ENOMEM;
  105a67:	c7 45 ec f4 ff ff ff 	movl   $0xfffffff4,-0x14(%ebp)
}
  105a6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105a71:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105a74:	5b                   	pop    %ebx
  105a75:	5e                   	pop    %esi
  105a76:	5f                   	pop    %edi
  105a77:	5d                   	pop    %ebp
  105a78:	c3                   	ret    

00105a79 <mqtt_unpack_suback>:
{
  105a79:	55                   	push   %ebp
  105a7a:	89 e5                	mov    %esp,%ebp
  105a7c:	57                   	push   %edi
  105a7d:	56                   	push   %esi
  105a7e:	53                   	push   %ebx
  105a7f:	83 ec 10             	sub    $0x10,%esp
  105a82:	8b 45 18             	mov    0x18(%ebp),%eax
  105a85:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  105a88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	*pkt_id = 0;
  105a8b:	8b 45 10             	mov    0x10(%ebp),%eax
{
  105a8e:	8b 7d 08             	mov    0x8(%ebp),%edi
	*pkt_id = 0;
  105a91:	66 c7 00 00 00       	movw   $0x0,(%eax)
	*items = 0;
  105a96:	8b 45 14             	mov    0x14(%ebp),%eax
	if (elements <= 0) {
  105a99:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
	*items = 0;
  105a9d:	c6 00 00             	movb   $0x0,(%eax)
	if (elements <= 0) {
  105aa0:	75 09                	jne    105aab <mqtt_unpack_suback+0x32>
		return -EINVAL;
  105aa2:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,-0x18(%ebp)
  105aa9:	eb 7f                	jmp    105b2a <mqtt_unpack_suback+0xb1>
	if (buf[0] != MQTT_SUBACK << 4) {
  105aab:	80 3f 90             	cmpb   $0x90,(%edi)
  105aae:	75 f2                	jne    105aa2 <mqtt_unpack_suback+0x29>
			 length - PACKET_TYPE_SIZE);
  105ab0:	8d 43 ff             	lea    -0x1(%ebx),%eax
	rc = rlen_decode(&rlen, &rlen_size, buf + PACKET_TYPE_SIZE,
  105ab3:	8d 55 ee             	lea    -0x12(%ebp),%edx
  105ab6:	0f b7 c0             	movzwl %ax,%eax
  105ab9:	50                   	push   %eax
  105aba:	8d 4f 01             	lea    0x1(%edi),%ecx
  105abd:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105ac0:	e8 a5 fb ff ff       	call   10566a <rlen_decode>
  105ac5:	5a                   	pop    %edx
  105ac6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (rc != 0) {
  105ac9:	85 c0                	test   %eax,%eax
  105acb:	75 d5                	jne    105aa2 <mqtt_unpack_suback+0x29>
	if (PACKET_TYPE_SIZE + rlen + rlen_size > length) {
  105acd:	0f b7 4d ee          	movzwl -0x12(%ebp),%ecx
  105ad1:	8b 75 f0             	mov    -0x10(%ebp),%esi
  105ad4:	89 ca                	mov    %ecx,%edx
  105ad6:	8d 74 0e 01          	lea    0x1(%esi,%ecx,1),%esi
  105ada:	0f b7 cb             	movzwl %bx,%ecx
  105add:	39 ce                	cmp    %ecx,%esi
  105adf:	77 c1                	ja     105aa2 <mqtt_unpack_suback+0x29>
	offset = PACKET_TYPE_SIZE + rlen_size;
  105ae1:	8d 4a 01             	lea    0x1(%edx),%ecx
	*pkt_id = ntohs(val_u16);
  105ae4:	8b 75 10             	mov    0x10(%ebp),%esi
	val_u16 = UNALIGNED_GET((uint16_t *)(buf + offset));
  105ae7:	0f b7 c9             	movzwl %cx,%ecx
  105aea:	66 8b 0c 0f          	mov    (%edi,%ecx,1),%cx
	*pkt_id = ntohs(val_u16);
  105aee:	86 e9                	xchg   %ch,%cl
  105af0:	66 89 0e             	mov    %cx,(%esi)
	offset += PACKET_ID_SIZE;
  105af3:	8d 4a 03             	lea    0x3(%edx),%ecx
	*items = length - offset;
  105af6:	8b 75 14             	mov    0x14(%ebp),%esi
  105af9:	29 cb                	sub    %ecx,%ebx
  105afb:	88 1e                	mov    %bl,(%esi)
	if (*items > elements) {
  105afd:	38 5d e4             	cmp    %bl,-0x1c(%ebp)
  105b00:	72 a0                	jb     105aa2 <mqtt_unpack_suback+0x29>
  105b02:	89 d3                	mov    %edx,%ebx
  105b04:	88 d9                	mov    %bl,%cl
	for (i = 0; i < *items; i++) {
  105b06:	8b 45 14             	mov    0x14(%ebp),%eax
  105b09:	29 d1                	sub    %edx,%ecx
  105b0b:	8d 73 03             	lea    0x3(%ebx),%esi
  105b0e:	38 08                	cmp    %cl,(%eax)
  105b10:	76 18                	jbe    105b2a <mqtt_unpack_suback+0xb1>
		qos = *(buf + offset);
  105b12:	0f b7 f6             	movzwl %si,%esi
  105b15:	43                   	inc    %ebx
  105b16:	0f b6 34 37          	movzbl (%edi,%esi,1),%esi
		if (qos < MQTT_QoS0 || qos > MQTT_QoS2) {
  105b1a:	83 fe 02             	cmp    $0x2,%esi
  105b1d:	77 83                	ja     105aa2 <mqtt_unpack_suback+0x29>
		granted_qos[i] = qos;
  105b1f:	0f b6 c9             	movzbl %cl,%ecx
  105b22:	8b 45 1c             	mov    0x1c(%ebp),%eax
  105b25:	89 34 88             	mov    %esi,(%eax,%ecx,4)
  105b28:	eb da                	jmp    105b04 <mqtt_unpack_suback+0x8b>
}
  105b2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105b2d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105b30:	5b                   	pop    %ebx
  105b31:	5e                   	pop    %esi
  105b32:	5f                   	pop    %edi
  105b33:	5d                   	pop    %ebp
  105b34:	c3                   	ret    

00105b35 <mqtt_pack_publish>:
{
  105b35:	55                   	push   %ebp
  105b36:	89 e5                	mov    %esp,%ebp
  105b38:	57                   	push   %edi
  105b39:	56                   	push   %esi
  105b3a:	53                   	push   %ebx
  105b3b:	83 ec 08             	sub    $0x8,%esp
  105b3e:	8b 5d 14             	mov    0x14(%ebp),%ebx
  105b41:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (msg->qos < MQTT_QoS0 || msg->qos > MQTT_QoS2) {
  105b44:	8b 43 04             	mov    0x4(%ebx),%eax
  105b47:	83 f8 02             	cmp    $0x2,%eax
  105b4a:	76 0c                	jbe    105b58 <mqtt_pack_publish+0x23>
		return -EINVAL;
  105b4c:	c7 45 ec ea ff ff ff 	movl   $0xffffffea,-0x14(%ebp)
  105b53:	e9 d7 00 00 00       	jmp    105c2f <mqtt_pack_publish+0xfa>
	payload = INT_SIZE + msg->topic_len +
  105b58:	85 c0                	test   %eax,%eax
  105b5a:	0f 95 c0             	setne  %al
  105b5d:	0f b6 f0             	movzbl %al,%esi
  105b60:	8b 43 18             	mov    0x18(%ebx),%eax
  105b63:	01 f6                	add    %esi,%esi
  105b65:	03 43 10             	add    0x10(%ebx),%eax
  105b68:	8d 74 06 02          	lea    0x2(%esi,%eax,1),%esi
	rc = compute_rlen_size(&rlen_size, payload);
  105b6c:	8d 45 f2             	lea    -0xe(%ebp),%eax
  105b6f:	0f b7 f6             	movzwl %si,%esi
  105b72:	89 f2                	mov    %esi,%edx
  105b74:	e8 93 fb ff ff       	call   10570c <compute_rlen_size>
  105b79:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (rc != 0) {
  105b7c:	85 c0                	test   %eax,%eax
  105b7e:	75 cc                	jne    105b4c <mqtt_pack_publish+0x17>
	if (PACKET_TYPE_SIZE + rlen_size + payload > size) {
  105b80:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  105b84:	0f b7 ff             	movzwl %di,%edi
  105b87:	8d 44 06 01          	lea    0x1(%esi,%eax,1),%eax
  105b8b:	39 f8                	cmp    %edi,%eax
  105b8d:	0f 8f 95 00 00 00    	jg     105c28 <mqtt_pack_publish+0xf3>
	buf[0] = (MQTT_PUBLISH << 4) | ((msg->dup ? 1 : 0) << 3) |
  105b93:	80 3b 01             	cmpb   $0x1,(%ebx)
		 (msg->qos << 1) | (msg->retain ? 1 : 0);
  105b96:	8a 43 04             	mov    0x4(%ebx),%al
	buf[0] = (MQTT_PUBLISH << 4) | ((msg->dup ? 1 : 0) << 3) |
  105b99:	19 d2                	sbb    %edx,%edx
		 (msg->qos << 1) | (msg->retain ? 1 : 0);
  105b9b:	01 c0                	add    %eax,%eax
	buf[0] = (MQTT_PUBLISH << 4) | ((msg->dup ? 1 : 0) << 3) |
  105b9d:	83 e2 f8             	and    $0xfffffff8,%edx
  105ba0:	83 c2 38             	add    $0x38,%edx
		 (msg->qos << 1) | (msg->retain ? 1 : 0);
  105ba3:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  105ba7:	0f 95 c1             	setne  %cl
  105baa:	09 c8                	or     %ecx,%eax
  105bac:	09 c2                	or     %eax,%edx
  105bae:	8b 45 08             	mov    0x8(%ebp),%eax
	rlen_encode(buf + PACKET_TYPE_SIZE, payload);
  105bb1:	40                   	inc    %eax
		 (msg->qos << 1) | (msg->retain ? 1 : 0);
  105bb2:	88 50 ff             	mov    %dl,-0x1(%eax)
	rlen_encode(buf + PACKET_TYPE_SIZE, payload);
  105bb5:	89 f2                	mov    %esi,%edx
  105bb7:	e8 83 fa ff ff       	call   10563f <rlen_encode>
	offset = PACKET_TYPE_SIZE + rlen_size;
  105bbc:	66 8b 7d f2          	mov    -0xe(%ebp),%di
	UNALIGNED_PUT(htons(msg->topic_len), (uint16_t *)(buf + offset));
  105bc0:	0f b7 73 10          	movzwl 0x10(%ebx),%esi
	offset = PACKET_TYPE_SIZE + rlen_size;
  105bc4:	8d 57 01             	lea    0x1(%edi),%edx
	UNALIGNED_PUT(htons(msg->topic_len), (uint16_t *)(buf + offset));
  105bc7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105bca:	0f b7 d2             	movzwl %dx,%edx
  105bcd:	89 f0                	mov    %esi,%eax
	offset += INT_SIZE;
  105bcf:	83 c7 03             	add    $0x3,%edi
	UNALIGNED_PUT(htons(msg->topic_len), (uint16_t *)(buf + offset));
  105bd2:	86 e0                	xchg   %ah,%al
  105bd4:	66 89 04 11          	mov    %ax,(%ecx,%edx,1)
	memcpy(buf + offset, msg->topic, msg->topic_len);
  105bd8:	56                   	push   %esi
  105bd9:	ff 73 0c             	pushl  0xc(%ebx)
  105bdc:	0f b7 c7             	movzwl %di,%eax
  105bdf:	01 c8                	add    %ecx,%eax
  105be1:	50                   	push   %eax
  105be2:	e8 86 b8 ff ff       	call   10146d <memcpy>
  105be7:	83 c4 0c             	add    $0xc,%esp
	offset += msg->topic_len;
  105bea:	03 7b 10             	add    0x10(%ebx),%edi
	if (msg->qos > MQTT_QoS0) {
  105bed:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  105bf1:	74 13                	je     105c06 <mqtt_pack_publish+0xd1>
		UNALIGNED_PUT(htons(msg->pkt_id), (uint16_t *)(buf + offset));
  105bf3:	0f b7 d7             	movzwl %di,%edx
  105bf6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105bf9:	66 8b 43 0a          	mov    0xa(%ebx),%ax
  105bfd:	86 e0                	xchg   %ah,%al
		offset += PACKET_ID_SIZE;
  105bff:	83 c7 02             	add    $0x2,%edi
		UNALIGNED_PUT(htons(msg->pkt_id), (uint16_t *)(buf + offset));
  105c02:	66 89 04 11          	mov    %ax,(%ecx,%edx,1)
	memcpy(buf + offset, msg->msg, msg->msg_len);
  105c06:	0f b7 43 18          	movzwl 0x18(%ebx),%eax
  105c0a:	50                   	push   %eax
  105c0b:	ff 73 14             	pushl  0x14(%ebx)
  105c0e:	0f b7 c7             	movzwl %di,%eax
  105c11:	03 45 08             	add    0x8(%ebp),%eax
  105c14:	50                   	push   %eax
  105c15:	e8 53 b8 ff ff       	call   10146d <memcpy>
	offset += msg->msg_len;
  105c1a:	03 7b 18             	add    0x18(%ebx),%edi
	*length = offset;
  105c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
	memcpy(buf + offset, msg->msg, msg->msg_len);
  105c20:	83 c4 0c             	add    $0xc,%esp
	*length = offset;
  105c23:	66 89 38             	mov    %di,(%eax)
	return 0;
  105c26:	eb 07                	jmp    105c2f <mqtt_pack_publish+0xfa>
		return -ENOMEM;
  105c28:	c7 45 ec f4 ff ff ff 	movl   $0xfffffff4,-0x14(%ebp)
}
  105c2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105c32:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105c35:	5b                   	pop    %ebx
  105c36:	5e                   	pop    %esi
  105c37:	5f                   	pop    %edi
  105c38:	5d                   	pop    %ebp
  105c39:	c3                   	ret    

00105c3a <mqtt_unpack_publish>:
{
  105c3a:	55                   	push   %ebp
  105c3b:	89 e5                	mov    %esp,%ebp
  105c3d:	57                   	push   %edi
  105c3e:	56                   	push   %esi
  105c3f:	53                   	push   %ebx
  105c40:	83 ec 14             	sub    $0x14,%esp
  105c43:	8b 75 08             	mov    0x8(%ebp),%esi
  105c46:	8b 7d 0c             	mov    0xc(%ebp),%edi
  105c49:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (buf[0] >> 4 != MQTT_PUBLISH) {
  105c4c:	8a 06                	mov    (%esi),%al
  105c4e:	88 c2                	mov    %al,%dl
  105c50:	c0 ea 04             	shr    $0x4,%dl
  105c53:	80 fa 03             	cmp    $0x3,%dl
  105c56:	74 0c                	je     105c64 <mqtt_unpack_publish+0x2a>
		return -EINVAL;
  105c58:	c7 45 e8 ea ff ff ff 	movl   $0xffffffea,-0x18(%ebp)
  105c5f:	e9 af 00 00 00       	jmp    105d13 <mqtt_unpack_publish+0xd9>
	msg->dup = (buf[0] & 0x08) >> 3;
  105c64:	c1 e8 03             	shr    $0x3,%eax
	rc = rlen_decode(&rmlen, &rmlen_size, buf + PACKET_TYPE_SIZE,
  105c67:	8d 55 ee             	lea    -0x12(%ebp),%edx
	msg->dup = (buf[0] & 0x08) >> 3;
  105c6a:	83 e0 01             	and    $0x1,%eax
	rc = rlen_decode(&rmlen, &rmlen_size, buf + PACKET_TYPE_SIZE,
  105c6d:	8d 4e 01             	lea    0x1(%esi),%ecx
	msg->dup = (buf[0] & 0x08) >> 3;
  105c70:	88 03                	mov    %al,(%ebx)
	msg->qos = (buf[0] & 0x06) >> 1;
  105c72:	0f b6 06             	movzbl (%esi),%eax
  105c75:	d1 f8                	sar    %eax
  105c77:	83 e0 03             	and    $0x3,%eax
  105c7a:	89 43 04             	mov    %eax,0x4(%ebx)
	msg->retain = buf[0] & 0x01;
  105c7d:	8a 06                	mov    (%esi),%al
  105c7f:	83 e0 01             	and    $0x1,%eax
  105c82:	88 43 08             	mov    %al,0x8(%ebx)
			 length - PACKET_TYPE_SIZE);
  105c85:	8d 47 ff             	lea    -0x1(%edi),%eax
	rc = rlen_decode(&rmlen, &rmlen_size, buf + PACKET_TYPE_SIZE,
  105c88:	0f b7 c0             	movzwl %ax,%eax
  105c8b:	50                   	push   %eax
  105c8c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105c8f:	e8 d6 f9 ff ff       	call   10566a <rlen_decode>
  105c94:	5a                   	pop    %edx
  105c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (rc != 0) {
  105c98:	85 c0                	test   %eax,%eax
  105c9a:	75 bc                	jne    105c58 <mqtt_unpack_publish+0x1e>
	if ((PACKET_TYPE_SIZE + rmlen_size + rmlen) > length) {
  105c9c:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
  105ca0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105ca3:	89 d1                	mov    %edx,%ecx
  105ca5:	8d 54 10 01          	lea    0x1(%eax,%edx,1),%edx
  105ca9:	0f b7 c7             	movzwl %di,%eax
  105cac:	89 45 e0             	mov    %eax,-0x20(%ebp)
  105caf:	39 c2                	cmp    %eax,%edx
  105cb1:	77 a5                	ja     105c58 <mqtt_unpack_publish+0x1e>
	offset = PACKET_TYPE_SIZE + rmlen_size;
  105cb3:	8d 51 01             	lea    0x1(%ecx),%edx
	offset += INT_SIZE;
  105cb6:	8d 41 03             	lea    0x3(%ecx),%eax
	val_u16 = UNALIGNED_GET((uint16_t *)(buf + offset));
  105cb9:	0f b7 d2             	movzwl %dx,%edx
	if (offset + msg->topic_len > length) {
  105cbc:	0f b7 c8             	movzwl %ax,%ecx
	val_u16 = UNALIGNED_GET((uint16_t *)(buf + offset));
  105cbf:	66 8b 14 16          	mov    (%esi,%edx,1),%dx
	offset += INT_SIZE;
  105cc3:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	msg->topic_len = ntohs(val_u16);
  105cc7:	86 f2                	xchg   %dh,%dl
	if (offset + msg->topic_len > length) {
  105cc9:	0f b7 c2             	movzwl %dx,%eax
  105ccc:	01 c8                	add    %ecx,%eax
	msg->topic_len = ntohs(val_u16);
  105cce:	66 89 53 10          	mov    %dx,0x10(%ebx)
	if (offset + msg->topic_len > length) {
  105cd2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  105cd5:	7f 81                	jg     105c58 <mqtt_unpack_publish+0x1e>
	if (msg->qos == MQTT_QoS1 || msg->qos == MQTT_QoS2) {
  105cd7:	8b 43 04             	mov    0x4(%ebx),%eax
	msg->topic = (char *)(buf + offset);
  105cda:	01 f1                	add    %esi,%ecx
	offset += msg->topic_len;
  105cdc:	66 03 55 e6          	add    -0x1a(%ebp),%dx
	msg->topic = (char *)(buf + offset);
  105ce0:	89 4b 0c             	mov    %ecx,0xc(%ebx)
	if (msg->qos == MQTT_QoS1 || msg->qos == MQTT_QoS2) {
  105ce3:	8d 48 ff             	lea    -0x1(%eax),%ecx
  105ce6:	83 f9 01             	cmp    $0x1,%ecx
  105ce9:	77 12                	ja     105cfd <mqtt_unpack_publish+0xc3>
	val_u16 = UNALIGNED_GET((uint16_t *)(buf + offset));
  105ceb:	0f b7 ca             	movzwl %dx,%ecx
		offset += PACKET_ID_SIZE;
  105cee:	83 c2 02             	add    $0x2,%edx
	val_u16 = UNALIGNED_GET((uint16_t *)(buf + offset));
  105cf1:	66 8b 0c 0e          	mov    (%esi,%ecx,1),%cx
		msg->pkt_id = ntohs(val_u16);
  105cf5:	86 e9                	xchg   %ch,%cl
  105cf7:	66 89 4b 0a          	mov    %cx,0xa(%ebx)
  105cfb:	eb 06                	jmp    105d03 <mqtt_unpack_publish+0xc9>
		msg->pkt_id = 0;
  105cfd:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	msg->msg_len = length - offset;
  105d03:	89 f9                	mov    %edi,%ecx
  105d05:	29 d1                	sub    %edx,%ecx
	msg->msg = buf + offset;
  105d07:	0f b7 d2             	movzwl %dx,%edx
  105d0a:	01 d6                	add    %edx,%esi
	msg->msg_len = length - offset;
  105d0c:	66 89 4b 18          	mov    %cx,0x18(%ebx)
	msg->msg = buf + offset;
  105d10:	89 73 14             	mov    %esi,0x14(%ebx)
}
  105d13:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105d16:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105d19:	5b                   	pop    %ebx
  105d1a:	5e                   	pop    %esi
  105d1b:	5f                   	pop    %edi
  105d1c:	5d                   	pop    %ebp
  105d1d:	c3                   	ret    

00105d1e <mqtt_unpack_connack>:
{
  105d1e:	55                   	push   %ebp
		return -EINVAL;
  105d1f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
  105d24:	89 e5                	mov    %esp,%ebp
  105d26:	8b 55 08             	mov    0x8(%ebp),%edx
	if (length < CONNACK_SIZE) {
  105d29:	66 83 7d 0c 03       	cmpw   $0x3,0xc(%ebp)
  105d2e:	76 22                	jbe    105d52 <mqtt_unpack_connack+0x34>
	if (buf[0] != (MQTT_CONNACK << 4) || buf[1] != 2) {
  105d30:	80 3a 20             	cmpb   $0x20,(%edx)
  105d33:	75 1d                	jne    105d52 <mqtt_unpack_connack+0x34>
  105d35:	80 7a 01 02          	cmpb   $0x2,0x1(%edx)
  105d39:	75 17                	jne    105d52 <mqtt_unpack_connack+0x34>
	if (buf[2] > 1) {
  105d3b:	8a 4a 02             	mov    0x2(%edx),%cl
  105d3e:	80 f9 01             	cmp    $0x1,%cl
  105d41:	77 0f                	ja     105d52 <mqtt_unpack_connack+0x34>
	*session = buf[2];
  105d43:	8b 45 10             	mov    0x10(%ebp),%eax
  105d46:	88 08                	mov    %cl,(%eax)
	*connect_rc = buf[3];
  105d48:	8b 45 14             	mov    0x14(%ebp),%eax
  105d4b:	8a 52 03             	mov    0x3(%edx),%dl
  105d4e:	88 10                	mov    %dl,(%eax)
	return 0;
  105d50:	31 c0                	xor    %eax,%eax
}
  105d52:	5d                   	pop    %ebp
  105d53:	c3                   	ret    

00105d54 <mqtt_pack_pingreq>:
{
  105d54:	55                   	push   %ebp
  105d55:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  105d5a:	89 e5                	mov    %esp,%ebp
  105d5c:	8b 55 08             	mov    0x8(%ebp),%edx
	if (size < MSG_ZEROLEN_SIZE) {
  105d5f:	66 83 7d 10 01       	cmpw   $0x1,0x10(%ebp)
  105d64:	76 11                	jbe    105d77 <mqtt_pack_pingreq+0x23>
	*length = MSG_ZEROLEN_SIZE;
  105d66:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf[0] = (pkt_type << 4) + (reserved & 0x0F);
  105d69:	c6 02 c0             	movb   $0xc0,(%edx)
	buf[1] = 0x00;
  105d6c:	c6 42 01 00          	movb   $0x0,0x1(%edx)
	*length = MSG_ZEROLEN_SIZE;
  105d70:	66 c7 00 02 00       	movw   $0x2,(%eax)
	return 0;
  105d75:	31 c0                	xor    %eax,%eax
}
  105d77:	5d                   	pop    %ebp
  105d78:	c3                   	ret    

00105d79 <mqtt_pack_disconnect>:
{
  105d79:	55                   	push   %ebp
  105d7a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  105d7f:	89 e5                	mov    %esp,%ebp
  105d81:	8b 55 08             	mov    0x8(%ebp),%edx
	if (size < MSG_ZEROLEN_SIZE) {
  105d84:	66 83 7d 10 01       	cmpw   $0x1,0x10(%ebp)
  105d89:	76 11                	jbe    105d9c <mqtt_pack_disconnect+0x23>
	*length = MSG_ZEROLEN_SIZE;
  105d8b:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf[0] = (pkt_type << 4) + (reserved & 0x0F);
  105d8e:	c6 02 e0             	movb   $0xe0,(%edx)
	buf[1] = 0x00;
  105d91:	c6 42 01 00          	movb   $0x0,0x1(%edx)
	*length = MSG_ZEROLEN_SIZE;
  105d95:	66 c7 00 02 00       	movw   $0x2,(%eax)
	return 0;
  105d9a:	31 c0                	xor    %eax,%eax
}
  105d9c:	5d                   	pop    %ebp
  105d9d:	c3                   	ret    

00105d9e <mqtt_unpack_puback>:
{
  105d9e:	55                   	push   %ebp
  105d9f:	89 e5                	mov    %esp,%ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBACK,
  105da1:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
{
  105da5:	8b 45 08             	mov    0x8(%ebp),%eax
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBACK,
  105da8:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105dab:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  105db2:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
  105db9:	5d                   	pop    %ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBACK,
  105dba:	e9 0c f9 ff ff       	jmp    1056cb <unpack_pktid_validate>

00105dbf <mqtt_unpack_pubrec>:
{
  105dbf:	55                   	push   %ebp
  105dc0:	89 e5                	mov    %esp,%ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBREC,
  105dc2:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
{
  105dc6:	8b 45 08             	mov    0x8(%ebp),%eax
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBREC,
  105dc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105dcc:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  105dd3:	c7 45 08 05 00 00 00 	movl   $0x5,0x8(%ebp)
}
  105dda:	5d                   	pop    %ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBREC,
  105ddb:	e9 eb f8 ff ff       	jmp    1056cb <unpack_pktid_validate>

00105de0 <mqtt_unpack_pubrel>:
{
  105de0:	55                   	push   %ebp
  105de1:	89 e5                	mov    %esp,%ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBREL,
  105de3:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
{
  105de7:	8b 45 08             	mov    0x8(%ebp),%eax
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBREL,
  105dea:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105ded:	c7 45 0c 02 00 00 00 	movl   $0x2,0xc(%ebp)
  105df4:	c7 45 08 06 00 00 00 	movl   $0x6,0x8(%ebp)
}
  105dfb:	5d                   	pop    %ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBREL,
  105dfc:	e9 ca f8 ff ff       	jmp    1056cb <unpack_pktid_validate>

00105e01 <mqtt_unpack_pubcomp>:
{
  105e01:	55                   	push   %ebp
  105e02:	89 e5                	mov    %esp,%ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBCOMP,
  105e04:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
{
  105e08:	8b 45 08             	mov    0x8(%ebp),%eax
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBCOMP,
  105e0b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105e0e:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  105e15:	c7 45 08 07 00 00 00 	movl   $0x7,0x8(%ebp)
}
  105e1c:	5d                   	pop    %ebp
	return unpack_pktid_validate(buf, length, pkt_id, MQTT_PUBCOMP,
  105e1d:	e9 a9 f8 ff ff       	jmp    1056cb <unpack_pktid_validate>

00105e22 <mqtt_unpack_pingresp>:
{
	return unpack_zerolen_validate(buf, length, MQTT_PINGREQ, 0x00);
}

int mqtt_unpack_pingresp(uint8_t *buf, uint16_t length)
{
  105e22:	55                   	push   %ebp
	return unpack_zerolen_validate(buf, length, MQTT_PINGRESP, 0x00);
  105e23:	b9 0d 00 00 00       	mov    $0xd,%ecx
{
  105e28:	89 e5                	mov    %esp,%ebp
	return unpack_zerolen_validate(buf, length, MQTT_PINGRESP, 0x00);
  105e2a:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  105e2e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105e31:	5d                   	pop    %ebp
	return unpack_zerolen_validate(buf, length, MQTT_PINGRESP, 0x00);
  105e32:	e9 29 f9 ff ff       	jmp    105760 <unpack_zerolen_validate.constprop.1>

00105e37 <mqtt_rx_pub_msgs>:
 * @retval -EINVAL on error
 */
static
int mqtt_rx_pub_msgs(struct mqtt_ctx *ctx, struct net_buf *rx,
		     enum mqtt_packet type)
{
  105e37:	55                   	push   %ebp
	uint16_t pkt_id;
	uint16_t len;
	uint8_t *data;
	int rc;

	switch (type) {
  105e38:	83 f9 05             	cmp    $0x5,%ecx
{
  105e3b:	89 e5                	mov    %esp,%ebp
  105e3d:	57                   	push   %edi
  105e3e:	56                   	push   %esi
  105e3f:	53                   	push   %ebx
  105e40:	53                   	push   %ebx
  105e41:	89 cb                	mov    %ecx,%ebx
	switch (type) {
  105e43:	74 27                	je     105e6c <mqtt_rx_pub_msgs+0x35>
  105e45:	77 12                	ja     105e59 <mqtt_rx_pub_msgs+0x22>
  105e47:	83 f9 04             	cmp    $0x4,%ecx
  105e4a:	0f 85 8b 00 00 00    	jne    105edb <mqtt_rx_pub_msgs+0xa4>
	int (*response)(struct mqtt_ctx *, uint16_t) = NULL;
  105e50:	31 ff                	xor    %edi,%edi
	case MQTT_PUBACK:
		unpack = mqtt_unpack_puback;
  105e52:	b9 9e 5d 10 00       	mov    $0x105d9e,%ecx
  105e57:	eb 29                	jmp    105e82 <mqtt_rx_pub_msgs+0x4b>
	switch (type) {
  105e59:	83 f9 06             	cmp    $0x6,%ecx
  105e5c:	74 1a                	je     105e78 <mqtt_rx_pub_msgs+0x41>
  105e5e:	83 f9 07             	cmp    $0x7,%ecx
  105e61:	75 78                	jne    105edb <mqtt_rx_pub_msgs+0xa4>
	int (*response)(struct mqtt_ctx *, uint16_t) = NULL;
  105e63:	31 ff                	xor    %edi,%edi
		break;
	case MQTT_PUBCOMP:
		unpack = mqtt_unpack_pubcomp;
  105e65:	b9 01 5e 10 00       	mov    $0x105e01,%ecx
  105e6a:	eb 16                	jmp    105e82 <mqtt_rx_pub_msgs+0x4b>
		break;
	case MQTT_PUBREC:
		unpack = mqtt_unpack_pubrec;
		response = mqtt_tx_pubrel;
  105e6c:	bf ef 5f 10 00       	mov    $0x105fef,%edi
		unpack = mqtt_unpack_pubrec;
  105e71:	b9 bf 5d 10 00       	mov    $0x105dbf,%ecx
		break;
  105e76:	eb 0a                	jmp    105e82 <mqtt_rx_pub_msgs+0x4b>
	case MQTT_PUBREL:
		unpack = mqtt_unpack_pubrel;
		response = mqtt_tx_pubcomp;
  105e78:	bf da 5f 10 00       	mov    $0x105fda,%edi
		unpack = mqtt_unpack_pubrel;
  105e7d:	b9 e0 5d 10 00       	mov    $0x105de0,%ecx
  105e82:	89 c6                	mov    %eax,%esi

	data = rx->data;
	len = rx->len;

	/* 4 bytes message */
	rc = unpack(data, len, &pkt_id);
  105e84:	8d 45 f2             	lea    -0xe(%ebp),%eax
  105e87:	50                   	push   %eax
  105e88:	0f b7 42 14          	movzwl 0x14(%edx),%eax
  105e8c:	50                   	push   %eax
  105e8d:	ff 72 10             	pushl  0x10(%edx)
  105e90:	ff d1                	call   *%ecx
  105e92:	83 c4 0c             	add    $0xc,%esp
	if (rc != 0) {
  105e95:	85 c0                	test   %eax,%eax
  105e97:	75 42                	jne    105edb <mqtt_rx_pub_msgs+0xa4>
	}

	/* Only MQTT_APP_SUBSCRIBER, MQTT_APP_PUBLISHER_SUBSCRIBER and
	 * MQTT_APP_SERVER apps must receive the MQTT_PUBREL msg.
	 */
	if (type == MQTT_PUBREL) {
  105e99:	83 fb 06             	cmp    $0x6,%ebx
  105e9c:	75 18                	jne    105eb6 <mqtt_rx_pub_msgs+0x7f>
		if (ctx->app_type != MQTT_APP_PUBLISHER) {
  105e9e:	80 7e 28 01          	cmpb   $0x1,0x28(%esi)
  105ea2:	74 37                	je     105edb <mqtt_rx_pub_msgs+0xa4>
			rc = ctx->publish_rx(ctx, NULL, pkt_id, MQTT_PUBREL);
  105ea4:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  105ea8:	6a 06                	push   $0x6
  105eaa:	50                   	push   %eax
  105eab:	6a 00                	push   $0x0
  105ead:	56                   	push   %esi
  105eae:	ff 56 14             	call   *0x14(%esi)
  105eb1:	83 c4 10             	add    $0x10,%esp
  105eb4:	eb 0d                	jmp    105ec3 <mqtt_rx_pub_msgs+0x8c>
		} else {
			rc = -EINVAL;
		}
	} else {
		rc = ctx->publish_tx(ctx, pkt_id, type);
  105eb6:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  105eba:	53                   	push   %ebx
  105ebb:	50                   	push   %eax
  105ebc:	56                   	push   %esi
  105ebd:	ff 56 10             	call   *0x10(%esi)
  105ec0:	83 c4 0c             	add    $0xc,%esp
  105ec3:	89 c3                	mov    %eax,%ebx
	}

	if (rc != 0) {
  105ec5:	85 c0                	test   %eax,%eax
  105ec7:	75 12                	jne    105edb <mqtt_rx_pub_msgs+0xa4>
		return -EINVAL;
	}

	if (!response)  {
  105ec9:	85 ff                	test   %edi,%edi
  105ecb:	74 13                	je     105ee0 <mqtt_rx_pub_msgs+0xa9>
		return 0;
	}

	rc = response(ctx, pkt_id);
  105ecd:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  105ed1:	50                   	push   %eax
  105ed2:	56                   	push   %esi
  105ed3:	ff d7                	call   *%edi
  105ed5:	5a                   	pop    %edx
	if (rc != 0) {
  105ed6:	85 c0                	test   %eax,%eax
	rc = response(ctx, pkt_id);
  105ed8:	59                   	pop    %ecx
	if (rc != 0) {
  105ed9:	74 05                	je     105ee0 <mqtt_rx_pub_msgs+0xa9>
		return -EINVAL;
  105edb:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		return -EINVAL;
	}

	return 0;
}
  105ee0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105ee3:	89 d8                	mov    %ebx,%eax
  105ee5:	5b                   	pop    %ebx
  105ee6:	5e                   	pop    %esi
  105ee7:	5f                   	pop    %edi
  105ee8:	5d                   	pop    %ebp
  105ee9:	c3                   	ret    

00105eea <mqtt_tx_pub_msgs>:
{
  105eea:	55                   	push   %ebp
  105eeb:	89 e5                	mov    %esp,%ebp
  105eed:	57                   	push   %edi
  105eee:	56                   	push   %esi
  105eef:	53                   	push   %ebx
  105ef0:	83 ec 08             	sub    $0x8,%esp
  105ef3:	89 c3                	mov    %eax,%ebx
	switch (pkt_type) {
  105ef5:	83 f9 05             	cmp    $0x5,%ecx
  105ef8:	74 43                	je     105f3d <mqtt_tx_pub_msgs+0x53>
  105efa:	77 1e                	ja     105f1a <mqtt_tx_pub_msgs+0x30>
  105efc:	83 f9 04             	cmp    $0x4,%ecx
  105eff:	0f 85 c6 00 00 00    	jne    105fcb <mqtt_tx_pub_msgs+0xe1>
		rc = mqtt_pack_puback(msg, &len, sizeof(msg), id);
  105f05:	8d 45 ee             	lea    -0x12(%ebp),%eax
  105f08:	0f b7 d2             	movzwl %dx,%edx
  105f0b:	52                   	push   %edx
  105f0c:	6a 04                	push   $0x4
  105f0e:	50                   	push   %eax
  105f0f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105f12:	50                   	push   %eax
  105f13:	e8 81 f8 ff ff       	call   105799 <mqtt_pack_puback>
  105f18:	eb 4b                	jmp    105f65 <mqtt_tx_pub_msgs+0x7b>
	switch (pkt_type) {
  105f1a:	83 f9 06             	cmp    $0x6,%ecx
  105f1d:	74 33                	je     105f52 <mqtt_tx_pub_msgs+0x68>
  105f1f:	83 f9 07             	cmp    $0x7,%ecx
  105f22:	0f 85 a3 00 00 00    	jne    105fcb <mqtt_tx_pub_msgs+0xe1>
		rc = mqtt_pack_pubcomp(msg, &len, sizeof(msg), id);
  105f28:	8d 45 ee             	lea    -0x12(%ebp),%eax
  105f2b:	0f b7 d2             	movzwl %dx,%edx
  105f2e:	52                   	push   %edx
  105f2f:	6a 04                	push   $0x4
  105f31:	50                   	push   %eax
  105f32:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105f35:	50                   	push   %eax
  105f36:	e8 ee f8 ff ff       	call   105829 <mqtt_pack_pubcomp>
  105f3b:	eb 28                	jmp    105f65 <mqtt_tx_pub_msgs+0x7b>
		rc = mqtt_pack_pubrec(msg, &len, sizeof(msg), id);
  105f3d:	8d 45 ee             	lea    -0x12(%ebp),%eax
  105f40:	0f b7 d2             	movzwl %dx,%edx
  105f43:	52                   	push   %edx
  105f44:	6a 04                	push   $0x4
  105f46:	50                   	push   %eax
  105f47:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105f4a:	50                   	push   %eax
  105f4b:	e8 79 f8 ff ff       	call   1057c9 <mqtt_pack_pubrec>
  105f50:	eb 13                	jmp    105f65 <mqtt_tx_pub_msgs+0x7b>
		rc = mqtt_pack_pubrel(msg, &len, sizeof(msg), id);
  105f52:	8d 45 ee             	lea    -0x12(%ebp),%eax
  105f55:	0f b7 d2             	movzwl %dx,%edx
  105f58:	52                   	push   %edx
  105f59:	6a 04                	push   $0x4
  105f5b:	50                   	push   %eax
  105f5c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105f5f:	50                   	push   %eax
  105f60:	e8 94 f8 ff ff       	call   1057f9 <mqtt_pack_pubrel>
  105f65:	83 c4 10             	add    $0x10,%esp
		return -EINVAL;
  105f68:	be ea ff ff ff       	mov    $0xffffffea,%esi
	if (rc != 0) {
  105f6d:	85 c0                	test   %eax,%eax
  105f6f:	75 5f                	jne    105fd0 <mqtt_tx_pub_msgs+0xe6>
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  105f71:	ff 73 04             	pushl  0x4(%ebx)
  105f74:	ff 33                	pushl  (%ebx)
  105f76:	e8 b9 d3 ff ff       	call   103334 <net_nbuf_get_tx>
		rc = -ENOMEM;
  105f7b:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  105f80:	5a                   	pop    %edx
  105f81:	89 c7                	mov    %eax,%edi
  105f83:	59                   	pop    %ecx
	if (tx == NULL) {
  105f84:	85 c0                	test   %eax,%eax
  105f86:	74 3a                	je     105fc2 <mqtt_tx_pub_msgs+0xd8>
	rc = net_nbuf_append(tx, len, msg, ctx->net_timeout);
  105f88:	ff 73 04             	pushl  0x4(%ebx)
  105f8b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  105f8e:	50                   	push   %eax
  105f8f:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  105f93:	50                   	push   %eax
  105f94:	57                   	push   %edi
  105f95:	e8 92 d6 ff ff       	call   10362c <net_nbuf_append>
  105f9a:	83 c4 10             	add    $0x10,%esp
	if (rc != true) {
  105f9d:	84 c0                	test   %al,%al
  105f9f:	74 21                	je     105fc2 <mqtt_tx_pub_msgs+0xd8>
	rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  105fa1:	6a 00                	push   $0x0
  105fa3:	6a 00                	push   $0x0
  105fa5:	ff 73 04             	pushl  0x4(%ebx)
  105fa8:	6a 00                	push   $0x0
  105faa:	57                   	push   %edi
  105fab:	e8 27 d0 ff ff       	call   102fd7 <net_context_send>
  105fb0:	83 c4 14             	add    $0x14,%esp
  105fb3:	89 c6                	mov    %eax,%esi
	if (rc < 0) {
  105fb5:	85 c0                	test   %eax,%eax
  105fb7:	78 04                	js     105fbd <mqtt_tx_pub_msgs+0xd3>
	tx = NULL;
  105fb9:	31 ff                	xor    %edi,%edi
  105fbb:	eb 05                	jmp    105fc2 <mqtt_tx_pub_msgs+0xd8>
		rc = -EIO;
  105fbd:	be fb ff ff ff       	mov    $0xfffffffb,%esi
	net_nbuf_unref(tx);
  105fc2:	57                   	push   %edi
  105fc3:	e8 94 d3 ff ff       	call   10335c <net_nbuf_unref>
  105fc8:	58                   	pop    %eax
	return rc;
  105fc9:	eb 05                	jmp    105fd0 <mqtt_tx_pub_msgs+0xe6>
		return -EINVAL;
  105fcb:	be ea ff ff ff       	mov    $0xffffffea,%esi
}
  105fd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105fd3:	89 f0                	mov    %esi,%eax
  105fd5:	5b                   	pop    %ebx
  105fd6:	5e                   	pop    %esi
  105fd7:	5f                   	pop    %edi
  105fd8:	5d                   	pop    %ebp
  105fd9:	c3                   	ret    

00105fda <mqtt_tx_pubcomp>:
{
  105fda:	55                   	push   %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBCOMP);
  105fdb:	b9 07 00 00 00       	mov    $0x7,%ecx
{
  105fe0:	89 e5                	mov    %esp,%ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBCOMP);
  105fe2:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  105fe6:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105fe9:	5d                   	pop    %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBCOMP);
  105fea:	e9 fb fe ff ff       	jmp    105eea <mqtt_tx_pub_msgs>

00105fef <mqtt_tx_pubrel>:
{
  105fef:	55                   	push   %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBREL);
  105ff0:	b9 06 00 00 00       	mov    $0x6,%ecx
{
  105ff5:	89 e5                	mov    %esp,%ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBREL);
  105ff7:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  105ffb:	8b 45 08             	mov    0x8(%ebp),%eax
}
  105ffe:	5d                   	pop    %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBREL);
  105fff:	e9 e6 fe ff ff       	jmp    105eea <mqtt_tx_pub_msgs>

00106004 <mqtt_linearize_buffer.constprop.1>:
 *
 * @retval Data buffer
 * @retval NULL on error
 */
static
struct net_buf *mqtt_linearize_buffer(struct mqtt_ctx *ctx, struct net_buf *rx,
  106004:	55                   	push   %ebp
  106005:	89 e5                	mov    %esp,%ebp
  106007:	57                   	push   %edi
  106008:	56                   	push   %esi
  106009:	53                   	push   %ebx
  10600a:	0f b7 4a 16          	movzwl 0x16(%edx),%ecx
  10600e:	8d 4c 0a 1b          	lea    0x1b(%edx,%ecx,1),%ecx
  106012:	83 e1 fc             	and    $0xfffffffc,%ecx
	return ((struct net_nbuf *)net_buf_user_data(buf))->appdatalen;
  106015:	8b 79 24             	mov    0x24(%ecx),%edi
	/* CONFIG_MQTT_MSG_MAX_SIZE is defined via Kconfig. So here it's
	 * determined if the input buffer could fit our data buffer or if
	 * it has the expected size.
	 */
	data_len = net_nbuf_appdatalen(rx);
	if (data_len < min_size || data_len > CONFIG_MQTT_MSG_MAX_SIZE) {
  106018:	8d 4f fe             	lea    -0x2(%edi),%ecx
  10601b:	66 83 f9 7e          	cmp    $0x7e,%cx
  10601f:	77 46                	ja     106067 <mqtt_linearize_buffer.constprop.1+0x63>
		return NULL;
	}

	data = net_buf_alloc(&mqtt_msg_pool, ctx->net_timeout);
  106021:	ff 70 04             	pushl  0x4(%eax)
  106024:	89 d6                	mov    %edx,%esi
  106026:	68 64 8d 10 00       	push   $0x108d64
  10602b:	e8 b5 b9 ff ff       	call   1019e5 <net_buf_alloc>
  106030:	5a                   	pop    %edx
  106031:	89 c3                	mov    %eax,%ebx
  106033:	59                   	pop    %ecx
	if (data == NULL) {
  106034:	85 c0                	test   %eax,%eax
  106036:	74 2f                	je     106067 <mqtt_linearize_buffer.constprop.1+0x63>
  106038:	89 f2                	mov    %esi,%edx
  10603a:	31 c0                	xor    %eax,%eax
		bytes += buf->len;
  10603c:	0f b7 4a 14          	movzwl 0x14(%edx),%ecx
		buf = buf->frags;
  106040:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
  106042:	01 c8                	add    %ecx,%eax
	while (buf) {
  106044:	85 d2                	test   %edx,%edx
  106046:	75 f4                	jne    10603c <mqtt_linearize_buffer.constprop.1+0x38>
		return NULL;
	}

	offset = net_buf_frags_len(rx) - data_len;
  106048:	29 f8                	sub    %edi,%eax
	rc = net_nbuf_linear_copy(data, rx, offset, data_len);
  10604a:	0f b7 d7             	movzwl %di,%edx
  10604d:	0f b7 c0             	movzwl %ax,%eax
  106050:	52                   	push   %edx
  106051:	50                   	push   %eax
  106052:	56                   	push   %esi
  106053:	53                   	push   %ebx
  106054:	e8 78 d4 ff ff       	call   1034d1 <net_nbuf_linear_copy>
  106059:	83 c4 10             	add    $0x10,%esp
	if (rc != 0) {
  10605c:	85 c0                	test   %eax,%eax
  10605e:	74 09                	je     106069 <mqtt_linearize_buffer.constprop.1+0x65>
	}

	return data;

exit_error:
	net_nbuf_unref(data);
  106060:	53                   	push   %ebx
  106061:	e8 f6 d2 ff ff       	call   10335c <net_nbuf_unref>
  106066:	58                   	pop    %eax

	return NULL;
  106067:	31 db                	xor    %ebx,%ebx
}
  106069:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10606c:	89 d8                	mov    %ebx,%eax
  10606e:	5b                   	pop    %ebx
  10606f:	5e                   	pop    %esi
  106070:	5f                   	pop    %edi
  106071:	5d                   	pop    %ebp
  106072:	c3                   	ret    

00106073 <mqtt_recv>:
}

static
void mqtt_recv(struct net_context *net_ctx, struct net_buf *buf, int status,
	       void *data)
{
  106073:	55                   	push   %ebp
  106074:	89 e5                	mov    %esp,%ebp
  106076:	53                   	push   %ebx
  106077:	8b 55 14             	mov    0x14(%ebp),%edx
  10607a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct mqtt_ctx *mqtt = (struct mqtt_ctx *)data;

	/* net_ctx is already referenced to by the mqtt_ctx struct */
	ARG_UNUSED(net_ctx);

	if (status || !buf) {
  10607d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  106081:	75 29                	jne    1060ac <mqtt_recv+0x39>
  106083:	85 db                	test   %ebx,%ebx
  106085:	74 25                	je     1060ac <mqtt_recv+0x39>
	return (void *)ROUND_UP((buf->__buf + buf->size), sizeof(int));
  106087:	0f b7 43 16          	movzwl 0x16(%ebx),%eax
  10608b:	8d 44 03 1b          	lea    0x1b(%ebx,%eax,1),%eax
  10608f:	83 e0 fc             	and    $0xfffffffc,%eax
		return;
	}

	if (net_nbuf_appdatalen(buf) == 0) {
  106092:	66 83 78 24 00       	cmpw   $0x0,0x24(%eax)
  106097:	74 07                	je     1060a0 <mqtt_recv+0x2d>
		goto lb_exit;
	}

	mqtt->rcv(mqtt, buf);
  106099:	53                   	push   %ebx
  10609a:	52                   	push   %edx
  10609b:	ff 52 24             	call   *0x24(%edx)
  10609e:	58                   	pop    %eax
  10609f:	5a                   	pop    %edx

lb_exit:
	net_nbuf_unref(buf);
  1060a0:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1060a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1060a6:	c9                   	leave  
	net_nbuf_unref(buf);
  1060a7:	e9 b0 d2 ff ff       	jmp    10335c <net_nbuf_unref>
}
  1060ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1060af:	c9                   	leave  
  1060b0:	c3                   	ret    

001060b1 <mqtt_tx_connect>:
{
  1060b1:	55                   	push   %ebp
  1060b2:	89 e5                	mov    %esp,%ebp
  1060b4:	57                   	push   %edi
  1060b5:	56                   	push   %esi
  1060b6:	53                   	push   %ebx
  1060b7:	51                   	push   %ecx
  1060b8:	8b 7d 08             	mov    0x8(%ebp),%edi
  1060bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	data = net_buf_alloc(&mqtt_msg_pool, ctx->net_timeout);
  1060be:	ff 77 04             	pushl  0x4(%edi)
  1060c1:	68 64 8d 10 00       	push   $0x108d64
  1060c6:	e8 1a b9 ff ff       	call   1019e5 <net_buf_alloc>
  1060cb:	5e                   	pop    %esi
	if (data == NULL) {
  1060cc:	85 c0                	test   %eax,%eax
	data = net_buf_alloc(&mqtt_msg_pool, ctx->net_timeout);
  1060ce:	5a                   	pop    %edx
  1060cf:	89 c6                	mov    %eax,%esi
	if (data == NULL) {
  1060d1:	74 63                	je     106136 <mqtt_tx_connect+0x85>
	ctx->clean_session = msg->clean_session ? 1 : 0;
  1060d3:	8a 13                	mov    (%ebx),%dl
  1060d5:	8a 47 29             	mov    0x29(%edi),%al
  1060d8:	83 e2 01             	and    $0x1,%edx
  1060db:	83 e0 fe             	and    $0xfffffffe,%eax
  1060de:	09 d0                	or     %edx,%eax
  1060e0:	88 47 29             	mov    %al,0x29(%edi)
	rc = mqtt_pack_connect(data->data, &data->len, MSG_SIZE, msg);
  1060e3:	8d 46 14             	lea    0x14(%esi),%eax
  1060e6:	53                   	push   %ebx
  1060e7:	68 80 00 00 00       	push   $0x80
  1060ec:	50                   	push   %eax
  1060ed:	ff 76 10             	pushl  0x10(%esi)
  1060f0:	e8 64 f7 ff ff       	call   105859 <mqtt_pack_connect>
  1060f5:	83 c4 10             	add    $0x10,%esp
	if (rc != 0) {
  1060f8:	85 c0                	test   %eax,%eax
  1060fa:	75 43                	jne    10613f <mqtt_tx_connect+0x8e>
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  1060fc:	ff 77 04             	pushl  0x4(%edi)
  1060ff:	ff 37                	pushl  (%edi)
  106101:	e8 2e d2 ff ff       	call   103334 <net_nbuf_get_tx>
  106106:	5b                   	pop    %ebx
  106107:	89 c3                	mov    %eax,%ebx
  106109:	5a                   	pop    %edx
		rc = -ENOMEM;
  10610a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (tx == NULL) {
  10610f:	85 db                	test   %ebx,%ebx
  106111:	74 3c                	je     10614f <mqtt_tx_connect+0x9e>
	net_buf_frag_add(tx, data);
  106113:	56                   	push   %esi
  106114:	53                   	push   %ebx
  106115:	e8 74 ba ff ff       	call   101b8e <net_buf_frag_add>
  10611a:	5a                   	pop    %edx
  10611b:	59                   	pop    %ecx
	rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  10611c:	6a 00                	push   $0x0
  10611e:	6a 00                	push   $0x0
  106120:	ff 77 04             	pushl  0x4(%edi)
  106123:	6a 00                	push   $0x0
  106125:	53                   	push   %ebx
  106126:	e8 ac ce ff ff       	call   102fd7 <net_context_send>
  10612b:	83 c4 14             	add    $0x14,%esp
	if (rc < 0) {
  10612e:	85 c0                	test   %eax,%eax
  106130:	78 16                	js     106148 <mqtt_tx_connect+0x97>
	tx = NULL;
  106132:	31 db                	xor    %ebx,%ebx
  106134:	eb 17                	jmp    10614d <mqtt_tx_connect+0x9c>
	struct net_buf *tx = NULL;
  106136:	31 db                	xor    %ebx,%ebx
		rc = -ENOMEM;
  106138:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  10613d:	eb 10                	jmp    10614f <mqtt_tx_connect+0x9e>
		rc = -EINVAL;
  10613f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	struct net_buf *tx = NULL;
  106144:	31 db                	xor    %ebx,%ebx
  106146:	eb 07                	jmp    10614f <mqtt_tx_connect+0x9e>
		rc = -EIO;
  106148:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	data = NULL;
  10614d:	31 f6                	xor    %esi,%esi
	net_nbuf_unref(data);
  10614f:	56                   	push   %esi
  106150:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106153:	e8 04 d2 ff ff       	call   10335c <net_nbuf_unref>
	net_nbuf_unref(tx);
  106158:	89 1c 24             	mov    %ebx,(%esp)
  10615b:	e8 fc d1 ff ff       	call   10335c <net_nbuf_unref>
  106160:	58                   	pop    %eax
}
  106161:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106164:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106167:	5b                   	pop    %ebx
  106168:	5e                   	pop    %esi
  106169:	5f                   	pop    %edi
  10616a:	5d                   	pop    %ebp
  10616b:	c3                   	ret    

0010616c <mqtt_tx_disconnect>:
{
  10616c:	55                   	push   %ebp
  10616d:	89 e5                	mov    %esp,%ebp
  10616f:	57                   	push   %edi
  106170:	56                   	push   %esi
  106171:	53                   	push   %ebx
  106172:	83 ec 08             	sub    $0x8,%esp
	rc = mqtt_pack_disconnect(msg, &len, sizeof(msg));
  106175:	8d 45 f0             	lea    -0x10(%ebp),%eax
  106178:	8d 7d f2             	lea    -0xe(%ebp),%edi
{
  10617b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	rc = mqtt_pack_disconnect(msg, &len, sizeof(msg));
  10617e:	6a 02                	push   $0x2
  106180:	50                   	push   %eax
  106181:	57                   	push   %edi
  106182:	e8 f2 fb ff ff       	call   105d79 <mqtt_pack_disconnect>
  106187:	83 c4 0c             	add    $0xc,%esp
	if (rc != 0) {
  10618a:	85 c0                	test   %eax,%eax
  10618c:	75 63                	jne    1061f1 <mqtt_tx_disconnect+0x85>
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  10618e:	ff 73 04             	pushl  0x4(%ebx)
  106191:	ff 33                	pushl  (%ebx)
  106193:	e8 9c d1 ff ff       	call   103334 <net_nbuf_get_tx>
  106198:	59                   	pop    %ecx
  106199:	5e                   	pop    %esi
  10619a:	89 c6                	mov    %eax,%esi
	if (tx == NULL) {
  10619c:	85 f6                	test   %esi,%esi
		rc = -ENOMEM;
  10619e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (tx == NULL) {
  1061a3:	74 5a                	je     1061ff <mqtt_tx_disconnect+0x93>
	rc = net_nbuf_append(tx, len, msg, ctx->net_timeout);
  1061a5:	ff 73 04             	pushl  0x4(%ebx)
  1061a8:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  1061ac:	57                   	push   %edi
  1061ad:	50                   	push   %eax
  1061ae:	56                   	push   %esi
  1061af:	e8 78 d4 ff ff       	call   10362c <net_nbuf_append>
  1061b4:	88 c2                	mov    %al,%dl
  1061b6:	83 c4 10             	add    $0x10,%esp
		rc = -ENOMEM;
  1061b9:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (rc != true) {
  1061be:	84 d2                	test   %dl,%dl
  1061c0:	74 3d                	je     1061ff <mqtt_tx_disconnect+0x93>
	rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  1061c2:	6a 00                	push   $0x0
  1061c4:	6a 00                	push   $0x0
  1061c6:	ff 73 04             	pushl  0x4(%ebx)
  1061c9:	6a 00                	push   $0x0
  1061cb:	56                   	push   %esi
  1061cc:	e8 06 ce ff ff       	call   102fd7 <net_context_send>
  1061d1:	83 c4 14             	add    $0x14,%esp
	if (rc < 0) {
  1061d4:	85 c0                	test   %eax,%eax
  1061d6:	78 22                	js     1061fa <mqtt_tx_disconnect+0x8e>
	if (ctx->disconnect) {
  1061d8:	8b 53 0c             	mov    0xc(%ebx),%edx
	tx = NULL;
  1061db:	31 f6                	xor    %esi,%esi
	ctx->connected = 0;
  1061dd:	80 63 29 fd          	andb   $0xfd,0x29(%ebx)
	if (ctx->disconnect) {
  1061e1:	85 d2                	test   %edx,%edx
  1061e3:	74 1a                	je     1061ff <mqtt_tx_disconnect+0x93>
  1061e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		ctx->disconnect(ctx);
  1061e8:	53                   	push   %ebx
  1061e9:	ff d2                	call   *%edx
  1061eb:	5a                   	pop    %edx
  1061ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1061ef:	eb 0e                	jmp    1061ff <mqtt_tx_disconnect+0x93>
		rc = -EINVAL;
  1061f1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	struct net_buf *tx = NULL;
  1061f6:	31 f6                	xor    %esi,%esi
  1061f8:	eb 05                	jmp    1061ff <mqtt_tx_disconnect+0x93>
		rc = -EIO;
  1061fa:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	net_nbuf_unref(tx);
  1061ff:	56                   	push   %esi
  106200:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106203:	e8 54 d1 ff ff       	call   10335c <net_nbuf_unref>
  106208:	58                   	pop    %eax
}
  106209:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10620c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10620f:	5b                   	pop    %ebx
  106210:	5e                   	pop    %esi
  106211:	5f                   	pop    %edi
  106212:	5d                   	pop    %ebp
  106213:	c3                   	ret    

00106214 <mqtt_tx_puback>:
{
  106214:	55                   	push   %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBACK);
  106215:	b9 04 00 00 00       	mov    $0x4,%ecx
{
  10621a:	89 e5                	mov    %esp,%ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBACK);
  10621c:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  106220:	8b 45 08             	mov    0x8(%ebp),%eax
}
  106223:	5d                   	pop    %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBACK);
  106224:	e9 c1 fc ff ff       	jmp    105eea <mqtt_tx_pub_msgs>

00106229 <mqtt_tx_pubrec>:
{
  106229:	55                   	push   %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBREC);
  10622a:	b9 05 00 00 00       	mov    $0x5,%ecx
{
  10622f:	89 e5                	mov    %esp,%ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBREC);
  106231:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  106235:	8b 45 08             	mov    0x8(%ebp),%eax
}
  106238:	5d                   	pop    %ebp
	return mqtt_tx_pub_msgs(ctx, id, MQTT_PUBREC);
  106239:	e9 ac fc ff ff       	jmp    105eea <mqtt_tx_pub_msgs>

0010623e <mqtt_tx_publish>:
{
  10623e:	55                   	push   %ebp
  10623f:	89 e5                	mov    %esp,%ebp
  106241:	57                   	push   %edi
  106242:	56                   	push   %esi
  106243:	53                   	push   %ebx
  106244:	51                   	push   %ecx
  106245:	8b 7d 08             	mov    0x8(%ebp),%edi
	data = net_buf_alloc(&mqtt_msg_pool, ctx->net_timeout);
  106248:	ff 77 04             	pushl  0x4(%edi)
  10624b:	68 64 8d 10 00       	push   $0x108d64
  106250:	e8 90 b7 ff ff       	call   1019e5 <net_buf_alloc>
  106255:	5b                   	pop    %ebx
	if (data == NULL) {
  106256:	85 c0                	test   %eax,%eax
	data = net_buf_alloc(&mqtt_msg_pool, ctx->net_timeout);
  106258:	5e                   	pop    %esi
  106259:	89 c3                	mov    %eax,%ebx
	if (data == NULL) {
  10625b:	74 55                	je     1062b2 <mqtt_tx_publish+0x74>
	rc = mqtt_pack_publish(data->data, &data->len, data->size, msg);
  10625d:	ff 75 0c             	pushl  0xc(%ebp)
  106260:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  106264:	50                   	push   %eax
  106265:	8d 43 14             	lea    0x14(%ebx),%eax
  106268:	50                   	push   %eax
  106269:	ff 73 10             	pushl  0x10(%ebx)
  10626c:	e8 c4 f8 ff ff       	call   105b35 <mqtt_pack_publish>
  106271:	83 c4 10             	add    $0x10,%esp
	if (rc != 0) {
  106274:	85 c0                	test   %eax,%eax
  106276:	75 43                	jne    1062bb <mqtt_tx_publish+0x7d>
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  106278:	ff 77 04             	pushl  0x4(%edi)
  10627b:	ff 37                	pushl  (%edi)
  10627d:	e8 b2 d0 ff ff       	call   103334 <net_nbuf_get_tx>
  106282:	5e                   	pop    %esi
  106283:	89 c6                	mov    %eax,%esi
  106285:	5a                   	pop    %edx
		rc = -ENOMEM;
  106286:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	if (tx == NULL) {
  10628b:	85 f6                	test   %esi,%esi
  10628d:	74 3c                	je     1062cb <mqtt_tx_publish+0x8d>
	net_buf_frag_add(tx, data);
  10628f:	53                   	push   %ebx
  106290:	56                   	push   %esi
  106291:	e8 f8 b8 ff ff       	call   101b8e <net_buf_frag_add>
  106296:	5a                   	pop    %edx
  106297:	59                   	pop    %ecx
	rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  106298:	6a 00                	push   $0x0
  10629a:	6a 00                	push   $0x0
  10629c:	ff 77 04             	pushl  0x4(%edi)
  10629f:	6a 00                	push   $0x0
  1062a1:	56                   	push   %esi
  1062a2:	e8 30 cd ff ff       	call   102fd7 <net_context_send>
  1062a7:	83 c4 14             	add    $0x14,%esp
	if (rc < 0) {
  1062aa:	85 c0                	test   %eax,%eax
  1062ac:	78 16                	js     1062c4 <mqtt_tx_publish+0x86>
	tx = NULL;
  1062ae:	31 f6                	xor    %esi,%esi
  1062b0:	eb 17                	jmp    1062c9 <mqtt_tx_publish+0x8b>
	struct net_buf *tx = NULL;
  1062b2:	31 f6                	xor    %esi,%esi
		rc = -ENOMEM;
  1062b4:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  1062b9:	eb 10                	jmp    1062cb <mqtt_tx_publish+0x8d>
		rc = -EINVAL;
  1062bb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	struct net_buf *tx = NULL;
  1062c0:	31 f6                	xor    %esi,%esi
  1062c2:	eb 07                	jmp    1062cb <mqtt_tx_publish+0x8d>
		rc = -EIO;
  1062c4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	data = NULL;
  1062c9:	31 db                	xor    %ebx,%ebx
	net_nbuf_unref(data);
  1062cb:	53                   	push   %ebx
  1062cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1062cf:	e8 88 d0 ff ff       	call   10335c <net_nbuf_unref>
	net_nbuf_unref(tx);
  1062d4:	89 34 24             	mov    %esi,(%esp)
  1062d7:	e8 80 d0 ff ff       	call   10335c <net_nbuf_unref>
  1062dc:	58                   	pop    %eax
}
  1062dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1062e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1062e3:	5b                   	pop    %ebx
  1062e4:	5e                   	pop    %esi
  1062e5:	5f                   	pop    %edi
  1062e6:	5d                   	pop    %ebp
  1062e7:	c3                   	ret    

001062e8 <mqtt_tx_pingreq>:
{
  1062e8:	55                   	push   %ebp
  1062e9:	89 e5                	mov    %esp,%ebp
  1062eb:	57                   	push   %edi
  1062ec:	56                   	push   %esi
  1062ed:	53                   	push   %ebx
	rc = mqtt_pack_pingreq(msg, &len, sizeof(msg));
  1062ee:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1062f1:	8d 7d f2             	lea    -0xe(%ebp),%edi
{
  1062f4:	53                   	push   %ebx
	rc = mqtt_pack_pingreq(msg, &len, sizeof(msg));
  1062f5:	6a 02                	push   $0x2
  1062f7:	50                   	push   %eax
  1062f8:	57                   	push   %edi
  1062f9:	e8 56 fa ff ff       	call   105d54 <mqtt_pack_pingreq>
  1062fe:	83 c4 0c             	add    $0xc,%esp
	if (rc != 0) {
  106301:	85 c0                	test   %eax,%eax
  106303:	75 50                	jne    106355 <mqtt_tx_pingreq+0x6d>
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  106305:	8b 45 08             	mov    0x8(%ebp),%eax
		rc = -ENOMEM;
  106308:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
	tx = net_nbuf_get_tx(ctx->net_ctx, ctx->net_timeout);
  10630d:	ff 70 04             	pushl  0x4(%eax)
  106310:	ff 30                	pushl  (%eax)
  106312:	e8 1d d0 ff ff       	call   103334 <net_nbuf_get_tx>
  106317:	5a                   	pop    %edx
  106318:	89 c6                	mov    %eax,%esi
  10631a:	59                   	pop    %ecx
	if (tx == NULL) {
  10631b:	85 c0                	test   %eax,%eax
  10631d:	74 44                	je     106363 <mqtt_tx_pingreq+0x7b>
	rc = net_nbuf_append(tx, len, msg, ctx->net_timeout);
  10631f:	8b 45 08             	mov    0x8(%ebp),%eax
  106322:	ff 70 04             	pushl  0x4(%eax)
  106325:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  106329:	57                   	push   %edi
  10632a:	50                   	push   %eax
  10632b:	56                   	push   %esi
  10632c:	e8 fb d2 ff ff       	call   10362c <net_nbuf_append>
  106331:	83 c4 10             	add    $0x10,%esp
	if (rc != true) {
  106334:	84 c0                	test   %al,%al
  106336:	74 2b                	je     106363 <mqtt_tx_pingreq+0x7b>
	rc = net_context_send(tx, NULL, ctx->net_timeout, NULL, NULL);
  106338:	8b 45 08             	mov    0x8(%ebp),%eax
  10633b:	6a 00                	push   $0x0
  10633d:	6a 00                	push   $0x0
  10633f:	ff 70 04             	pushl  0x4(%eax)
  106342:	6a 00                	push   $0x0
  106344:	56                   	push   %esi
  106345:	e8 8d cc ff ff       	call   102fd7 <net_context_send>
  10634a:	83 c4 14             	add    $0x14,%esp
  10634d:	89 c3                	mov    %eax,%ebx
	if (rc < 0) {
  10634f:	85 c0                	test   %eax,%eax
  106351:	79 07                	jns    10635a <mqtt_tx_pingreq+0x72>
  106353:	eb 09                	jmp    10635e <mqtt_tx_pingreq+0x76>
		rc = -EINVAL;
  106355:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	struct net_buf *tx = NULL;
  10635a:	31 f6                	xor    %esi,%esi
  10635c:	eb 05                	jmp    106363 <mqtt_tx_pingreq+0x7b>
		rc = -EIO;
  10635e:	bb fb ff ff ff       	mov    $0xfffffffb,%ebx
	net_nbuf_unref(tx);
  106363:	56                   	push   %esi
  106364:	e8 f3 cf ff ff       	call   10335c <net_nbuf_unref>
  106369:	58                   	pop    %eax
}
  10636a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10636d:	89 d8                	mov    %ebx,%eax
  10636f:	5b                   	pop    %ebx
  106370:	5e                   	pop    %esi
  106371:	5f                   	pop    %edi
  106372:	5d                   	pop    %ebp
  106373:	c3                   	ret    

00106374 <mqtt_rx_connack>:
{
  106374:	55                   	push   %ebp
  106375:	89 e5                	mov    %esp,%ebp
  106377:	53                   	push   %ebx
  106378:	83 ec 08             	sub    $0x8,%esp
	rc = mqtt_unpack_connack(data, len, &session, &connect_rc);
  10637b:	8d 55 fa             	lea    -0x6(%ebp),%edx
{
  10637e:	8b 45 0c             	mov    0xc(%ebp),%eax
	rc = mqtt_unpack_connack(data, len, &session, &connect_rc);
  106381:	52                   	push   %edx
  106382:	8d 55 fb             	lea    -0x5(%ebp),%edx
  106385:	52                   	push   %edx
{
  106386:	8b 5d 08             	mov    0x8(%ebp),%ebx
	rc = mqtt_unpack_connack(data, len, &session, &connect_rc);
  106389:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  10638d:	52                   	push   %edx
  10638e:	ff 70 10             	pushl  0x10(%eax)
  106391:	e8 88 f9 ff ff       	call   105d1e <mqtt_unpack_connack>
  106396:	83 c4 10             	add    $0x10,%esp
	if (rc != 0) {
  106399:	85 c0                	test   %eax,%eax
  10639b:	75 29                	jne    1063c6 <mqtt_rx_connack+0x52>
	switch (clean_session) {
  10639d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  1063a1:	75 23                	jne    1063c6 <mqtt_rx_connack+0x52>
		if (session == 0 && connect_rc == 0) {
  1063a3:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
  1063a7:	75 1d                	jne    1063c6 <mqtt_rx_connack+0x52>
  1063a9:	80 7d fa 00          	cmpb   $0x0,-0x6(%ebp)
  1063ad:	75 17                	jne    1063c6 <mqtt_rx_connack+0x52>
	if (ctx->connect) {
  1063af:	8b 53 08             	mov    0x8(%ebx),%edx
	ctx->connected = 1;
  1063b2:	80 4b 29 02          	orb    $0x2,0x29(%ebx)
	if (ctx->connect) {
  1063b6:	85 d2                	test   %edx,%edx
  1063b8:	74 11                	je     1063cb <mqtt_rx_connack+0x57>
  1063ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
		ctx->connect(ctx);
  1063bd:	53                   	push   %ebx
  1063be:	ff d2                	call   *%edx
  1063c0:	58                   	pop    %eax
  1063c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1063c4:	eb 05                	jmp    1063cb <mqtt_rx_connack+0x57>
		rc = -EINVAL;
  1063c6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  1063cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1063ce:	c9                   	leave  
  1063cf:	c3                   	ret    

001063d0 <mqtt_rx_puback>:
{
  1063d0:	55                   	push   %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBACK);
  1063d1:	b9 04 00 00 00       	mov    $0x4,%ecx
{
  1063d6:	89 e5                	mov    %esp,%ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBACK);
  1063d8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1063db:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1063de:	5d                   	pop    %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBACK);
  1063df:	e9 53 fa ff ff       	jmp    105e37 <mqtt_rx_pub_msgs>

001063e4 <mqtt_rx_pubcomp>:
{
  1063e4:	55                   	push   %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBCOMP);
  1063e5:	b9 07 00 00 00       	mov    $0x7,%ecx
{
  1063ea:	89 e5                	mov    %esp,%ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBCOMP);
  1063ec:	8b 55 0c             	mov    0xc(%ebp),%edx
  1063ef:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1063f2:	5d                   	pop    %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBCOMP);
  1063f3:	e9 3f fa ff ff       	jmp    105e37 <mqtt_rx_pub_msgs>

001063f8 <mqtt_rx_pubrec>:
{
  1063f8:	55                   	push   %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBREC);
  1063f9:	b9 05 00 00 00       	mov    $0x5,%ecx
{
  1063fe:	89 e5                	mov    %esp,%ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBREC);
  106400:	8b 55 0c             	mov    0xc(%ebp),%edx
  106403:	8b 45 08             	mov    0x8(%ebp),%eax
}
  106406:	5d                   	pop    %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBREC);
  106407:	e9 2b fa ff ff       	jmp    105e37 <mqtt_rx_pub_msgs>

0010640c <mqtt_rx_pubrel>:
{
  10640c:	55                   	push   %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBREL);
  10640d:	b9 06 00 00 00       	mov    $0x6,%ecx
{
  106412:	89 e5                	mov    %esp,%ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBREL);
  106414:	8b 55 0c             	mov    0xc(%ebp),%edx
  106417:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10641a:	5d                   	pop    %ebp
	return mqtt_rx_pub_msgs(ctx, rx, MQTT_PUBREL);
  10641b:	e9 17 fa ff ff       	jmp    105e37 <mqtt_rx_pub_msgs>

00106420 <mqtt_rx_pingresp>:
{
  106420:	55                   	push   %ebp
  106421:	89 e5                	mov    %esp,%ebp
  106423:	8b 45 0c             	mov    0xc(%ebp),%eax
	rc = mqtt_unpack_pingresp(rx->data, rx->len);
  106426:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  10642a:	52                   	push   %edx
  10642b:	ff 70 10             	pushl  0x10(%eax)
  10642e:	e8 ef f9 ff ff       	call   105e22 <mqtt_unpack_pingresp>
  106433:	5a                   	pop    %edx
	if (rc != 0) {
  106434:	85 c0                	test   %eax,%eax
	rc = mqtt_unpack_pingresp(rx->data, rx->len);
  106436:	59                   	pop    %ecx
	if (rc != 0) {
  106437:	74 05                	je     10643e <mqtt_rx_pingresp+0x1e>
		return -EINVAL;
  106439:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  10643e:	c9                   	leave  
  10643f:	c3                   	ret    

00106440 <mqtt_publisher_parser>:
{
  106440:	55                   	push   %ebp
  106441:	89 e5                	mov    %esp,%ebp
  106443:	56                   	push   %esi
  106444:	53                   	push   %ebx
  106445:	53                   	push   %ebx
  106446:	8b 5d 08             	mov    0x8(%ebp),%ebx
	data = mqtt_linearize_buffer(ctx, rx, MQTT_PUBLISHER_MIN_MSG_SIZE);
  106449:	8b 55 0c             	mov    0xc(%ebp),%edx
  10644c:	89 d8                	mov    %ebx,%eax
  10644e:	e8 b1 fb ff ff       	call   106004 <mqtt_linearize_buffer.constprop.1>
  106453:	89 c6                	mov    %eax,%esi
	if (!data) {
  106455:	85 c0                	test   %eax,%eax
  106457:	0f 84 83 00 00 00    	je     1064e0 <mqtt_publisher_parser+0xa0>
	pkt_type = MQTT_PACKET_TYPE(data->data[0]);
  10645d:	8b 40 10             	mov    0x10(%eax),%eax
  106460:	8a 10                	mov    (%eax),%dl
  106462:	c0 ea 04             	shr    $0x4,%dl
	switch (pkt_type) {
  106465:	8d 42 fe             	lea    -0x2(%edx),%eax
  106468:	3c 0b                	cmp    $0xb,%al
  10646a:	77 0a                	ja     106476 <mqtt_publisher_parser+0x36>
  10646c:	0f b6 c0             	movzbl %al,%eax
  10646f:	ff 24 85 70 81 10 00 	jmp    *0x108170(,%eax,4)
	pkt_type = MQTT_PACKET_TYPE(data->data[0]);
  106476:	0f b6 d2             	movzbl %dl,%edx
		rc = -EINVAL;
  106479:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10647e:	eb 73                	jmp    1064f3 <mqtt_publisher_parser+0xb3>
		if (!ctx->connected) {
  106480:	8a 43 29             	mov    0x29(%ebx),%al
  106483:	a8 02                	test   $0x2,%al
  106485:	75 62                	jne    1064e9 <mqtt_publisher_parser+0xa9>
			rc = mqtt_rx_connack(ctx, data, ctx->clean_session);
  106487:	83 e0 01             	and    $0x1,%eax
  10648a:	50                   	push   %eax
  10648b:	56                   	push   %esi
  10648c:	53                   	push   %ebx
  10648d:	e8 e2 fe ff ff       	call   106374 <mqtt_rx_connack>
  106492:	83 c4 0c             	add    $0xc,%esp
  106495:	ba 02 00 00 00       	mov    $0x2,%edx
  10649a:	eb 3e                	jmp    1064da <mqtt_publisher_parser+0x9a>
		rc = mqtt_rx_puback(ctx, data);
  10649c:	56                   	push   %esi
  10649d:	53                   	push   %ebx
  10649e:	e8 2d ff ff ff       	call   1063d0 <mqtt_rx_puback>
  1064a3:	5a                   	pop    %edx
		break;
  1064a4:	ba 04 00 00 00       	mov    $0x4,%edx
		rc = mqtt_rx_puback(ctx, data);
  1064a9:	59                   	pop    %ecx
		break;
  1064aa:	eb 2e                	jmp    1064da <mqtt_publisher_parser+0x9a>
		rc = mqtt_rx_pubrec(ctx, data);
  1064ac:	56                   	push   %esi
  1064ad:	53                   	push   %ebx
  1064ae:	e8 45 ff ff ff       	call   1063f8 <mqtt_rx_pubrec>
  1064b3:	5a                   	pop    %edx
		break;
  1064b4:	ba 05 00 00 00       	mov    $0x5,%edx
		rc = mqtt_rx_pubrec(ctx, data);
  1064b9:	59                   	pop    %ecx
		break;
  1064ba:	eb 1e                	jmp    1064da <mqtt_publisher_parser+0x9a>
		rc = mqtt_rx_pubcomp(ctx, data);
  1064bc:	56                   	push   %esi
  1064bd:	53                   	push   %ebx
  1064be:	e8 21 ff ff ff       	call   1063e4 <mqtt_rx_pubcomp>
  1064c3:	5a                   	pop    %edx
		break;
  1064c4:	ba 07 00 00 00       	mov    $0x7,%edx
		rc = mqtt_rx_pubcomp(ctx, data);
  1064c9:	59                   	pop    %ecx
		break;
  1064ca:	eb 0e                	jmp    1064da <mqtt_publisher_parser+0x9a>
		rc = mqtt_rx_pingresp(ctx, data);
  1064cc:	56                   	push   %esi
  1064cd:	53                   	push   %ebx
  1064ce:	e8 4d ff ff ff       	call   106420 <mqtt_rx_pingresp>
  1064d3:	5a                   	pop    %edx
		break;
  1064d4:	ba 0d 00 00 00       	mov    $0xd,%edx
		rc = mqtt_rx_pingresp(ctx, data);
  1064d9:	59                   	pop    %ecx
	if (rc != 0 && ctx->malformed) {
  1064da:	85 c0                	test   %eax,%eax
  1064dc:	75 15                	jne    1064f3 <mqtt_publisher_parser+0xb3>
  1064de:	eb 26                	jmp    106506 <mqtt_publisher_parser+0xc6>
		rc = -ENOMEM;
  1064e0:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	uint16_t pkt_type = MQTT_INVALID;
  1064e5:	31 d2                	xor    %edx,%edx
  1064e7:	eb 0a                	jmp    1064f3 <mqtt_publisher_parser+0xb3>
			rc = -EINVAL;
  1064e9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1064ee:	ba 02 00 00 00       	mov    $0x2,%edx
	if (rc != 0 && ctx->malformed) {
  1064f3:	8b 4b 20             	mov    0x20(%ebx),%ecx
  1064f6:	85 c9                	test   %ecx,%ecx
  1064f8:	74 0c                	je     106506 <mqtt_publisher_parser+0xc6>
		ctx->malformed(ctx, pkt_type);
  1064fa:	52                   	push   %edx
  1064fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1064fe:	53                   	push   %ebx
  1064ff:	ff d1                	call   *%ecx
  106501:	5a                   	pop    %edx
  106502:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106505:	59                   	pop    %ecx
	net_nbuf_unref(data);
  106506:	56                   	push   %esi
  106507:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10650a:	e8 4d ce ff ff       	call   10335c <net_nbuf_unref>
  10650f:	58                   	pop    %eax
}
  106510:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106513:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106516:	5b                   	pop    %ebx
  106517:	5e                   	pop    %esi
  106518:	5d                   	pop    %ebp
  106519:	c3                   	ret    

0010651a <mqtt_rx_suback>:
{
  10651a:	55                   	push   %ebp
  10651b:	89 e5                	mov    %esp,%ebp
  10651d:	56                   	push   %esi
  10651e:	53                   	push   %ebx
  10651f:	83 ec 08             	sub    $0x8,%esp
	rc = mqtt_unpack_suback(data, len, &pkt_id, &items,
  106522:	8d 55 f1             	lea    -0xf(%ebp),%edx
  106525:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  106528:	8b 45 0c             	mov    0xc(%ebp),%eax
	rc = mqtt_unpack_suback(data, len, &pkt_id, &items,
  10652b:	56                   	push   %esi
  10652c:	6a 01                	push   $0x1
  10652e:	52                   	push   %edx
  10652f:	8d 55 f2             	lea    -0xe(%ebp),%edx
  106532:	52                   	push   %edx
{
  106533:	8b 5d 08             	mov    0x8(%ebp),%ebx
	rc = mqtt_unpack_suback(data, len, &pkt_id, &items,
  106536:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  10653a:	52                   	push   %edx
  10653b:	ff 70 10             	pushl  0x10(%eax)
  10653e:	e8 36 f5 ff ff       	call   105a79 <mqtt_unpack_suback>
  106543:	83 c4 18             	add    $0x18,%esp
	if (rc != 0) {
  106546:	85 c0                	test   %eax,%eax
  106548:	74 07                	je     106551 <mqtt_rx_suback+0x37>
		return -EINVAL;
  10654a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10654f:	eb 1c                	jmp    10656d <mqtt_rx_suback+0x53>
	if (!ctx->subscribe) {
  106551:	8b 43 18             	mov    0x18(%ebx),%eax
  106554:	85 c0                	test   %eax,%eax
  106556:	74 f2                	je     10654a <mqtt_rx_suback+0x30>
	rc = ctx->subscribe(ctx, pkt_id, items, suback_qos);
  106558:	0f b6 55 f1          	movzbl -0xf(%ebp),%edx
  10655c:	56                   	push   %esi
  10655d:	52                   	push   %edx
  10655e:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  106562:	52                   	push   %edx
  106563:	53                   	push   %ebx
  106564:	ff d0                	call   *%eax
  106566:	83 c4 10             	add    $0x10,%esp
	if (rc != 0) {
  106569:	85 c0                	test   %eax,%eax
  10656b:	75 dd                	jne    10654a <mqtt_rx_suback+0x30>
}
  10656d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106570:	5b                   	pop    %ebx
  106571:	5e                   	pop    %esi
  106572:	5d                   	pop    %ebp
  106573:	c3                   	ret    

00106574 <mqtt_rx_publish>:
{
  106574:	55                   	push   %ebp
  106575:	89 e5                	mov    %esp,%ebp
  106577:	56                   	push   %esi
  106578:	53                   	push   %ebx
  106579:	83 ec 1c             	sub    $0x1c,%esp
	rc = mqtt_unpack_publish(rx->data, rx->len, &msg);
  10657c:	8d 75 dc             	lea    -0x24(%ebp),%esi
{
  10657f:	8b 45 0c             	mov    0xc(%ebp),%eax
  106582:	8b 5d 08             	mov    0x8(%ebp),%ebx
	rc = mqtt_unpack_publish(rx->data, rx->len, &msg);
  106585:	56                   	push   %esi
  106586:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  10658a:	52                   	push   %edx
  10658b:	ff 70 10             	pushl  0x10(%eax)
  10658e:	e8 a7 f6 ff ff       	call   105c3a <mqtt_unpack_publish>
  106593:	83 c4 0c             	add    $0xc,%esp
	if (rc != 0) {
  106596:	85 c0                	test   %eax,%eax
  106598:	75 22                	jne    1065bc <mqtt_rx_publish+0x48>
	rc = ctx->publish_rx(ctx, &msg, msg.pkt_id, MQTT_PUBLISH);
  10659a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  10659e:	6a 03                	push   $0x3
  1065a0:	50                   	push   %eax
  1065a1:	56                   	push   %esi
  1065a2:	53                   	push   %ebx
  1065a3:	ff 53 14             	call   *0x14(%ebx)
  1065a6:	83 c4 10             	add    $0x10,%esp
	if (rc != 0) {
  1065a9:	85 c0                	test   %eax,%eax
  1065ab:	75 0f                	jne    1065bc <mqtt_rx_publish+0x48>
	switch (msg.qos) {
  1065ad:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1065b0:	83 fa 01             	cmp    $0x1,%edx
  1065b3:	74 1b                	je     1065d0 <mqtt_rx_publish+0x5c>
  1065b5:	72 26                	jb     1065dd <mqtt_rx_publish+0x69>
  1065b7:	83 fa 02             	cmp    $0x2,%edx
  1065ba:	74 07                	je     1065c3 <mqtt_rx_publish+0x4f>
		rc = -EINVAL;
  1065bc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1065c1:	eb 1a                	jmp    1065dd <mqtt_rx_publish+0x69>
		rc = mqtt_tx_pubrec(ctx, msg.pkt_id);
  1065c3:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  1065c7:	50                   	push   %eax
  1065c8:	53                   	push   %ebx
  1065c9:	e8 5b fc ff ff       	call   106229 <mqtt_tx_pubrec>
  1065ce:	eb 0b                	jmp    1065db <mqtt_rx_publish+0x67>
		rc = mqtt_tx_puback(ctx, msg.pkt_id);
  1065d0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  1065d4:	50                   	push   %eax
  1065d5:	53                   	push   %ebx
  1065d6:	e8 39 fc ff ff       	call   106214 <mqtt_tx_puback>
  1065db:	5a                   	pop    %edx
  1065dc:	59                   	pop    %ecx
}
  1065dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1065e0:	5b                   	pop    %ebx
  1065e1:	5e                   	pop    %esi
  1065e2:	5d                   	pop    %ebp
  1065e3:	c3                   	ret    

001065e4 <mqtt_subscriber_parser>:
{
  1065e4:	55                   	push   %ebp
  1065e5:	89 e5                	mov    %esp,%ebp
  1065e7:	56                   	push   %esi
  1065e8:	53                   	push   %ebx
  1065e9:	53                   	push   %ebx
  1065ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
	data = mqtt_linearize_buffer(ctx, rx, MQTT_PUBLISHER_MIN_MSG_SIZE);
  1065ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  1065f0:	89 d8                	mov    %ebx,%eax
  1065f2:	e8 0d fa ff ff       	call   106004 <mqtt_linearize_buffer.constprop.1>
  1065f7:	89 c6                	mov    %eax,%esi
	if (!data) {
  1065f9:	85 c0                	test   %eax,%eax
  1065fb:	0f 84 83 00 00 00    	je     106684 <mqtt_subscriber_parser+0xa0>
	pkt_type = MQTT_PACKET_TYPE(data->data[0]);
  106601:	8b 40 10             	mov    0x10(%eax),%eax
  106604:	8a 10                	mov    (%eax),%dl
  106606:	c0 ea 04             	shr    $0x4,%dl
	switch (pkt_type) {
  106609:	8d 42 fe             	lea    -0x2(%edx),%eax
  10660c:	3c 0b                	cmp    $0xb,%al
  10660e:	77 0a                	ja     10661a <mqtt_subscriber_parser+0x36>
  106610:	0f b6 c0             	movzbl %al,%eax
  106613:	ff 24 85 a0 81 10 00 	jmp    *0x1081a0(,%eax,4)
	pkt_type = MQTT_PACKET_TYPE(data->data[0]);
  10661a:	0f b6 d2             	movzbl %dl,%edx
  10661d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  106622:	eb 73                	jmp    106697 <mqtt_subscriber_parser+0xb3>
		if (!ctx->connected) {
  106624:	8a 43 29             	mov    0x29(%ebx),%al
  106627:	a8 02                	test   $0x2,%al
  106629:	75 62                	jne    10668d <mqtt_subscriber_parser+0xa9>
			rc = mqtt_rx_connack(ctx, data, ctx->clean_session);
  10662b:	83 e0 01             	and    $0x1,%eax
  10662e:	50                   	push   %eax
  10662f:	56                   	push   %esi
  106630:	53                   	push   %ebx
  106631:	e8 3e fd ff ff       	call   106374 <mqtt_rx_connack>
  106636:	83 c4 0c             	add    $0xc,%esp
  106639:	ba 02 00 00 00       	mov    $0x2,%edx
  10663e:	eb 3e                	jmp    10667e <mqtt_subscriber_parser+0x9a>
		rc = mqtt_rx_publish(ctx, data);
  106640:	56                   	push   %esi
  106641:	53                   	push   %ebx
  106642:	e8 2d ff ff ff       	call   106574 <mqtt_rx_publish>
  106647:	5a                   	pop    %edx
		break;
  106648:	ba 03 00 00 00       	mov    $0x3,%edx
		rc = mqtt_rx_publish(ctx, data);
  10664d:	59                   	pop    %ecx
		break;
  10664e:	eb 2e                	jmp    10667e <mqtt_subscriber_parser+0x9a>
		rc = mqtt_rx_pubrel(ctx, data);
  106650:	56                   	push   %esi
  106651:	53                   	push   %ebx
  106652:	e8 b5 fd ff ff       	call   10640c <mqtt_rx_pubrel>
  106657:	5a                   	pop    %edx
		break;
  106658:	ba 06 00 00 00       	mov    $0x6,%edx
		rc = mqtt_rx_pubrel(ctx, data);
  10665d:	59                   	pop    %ecx
		break;
  10665e:	eb 1e                	jmp    10667e <mqtt_subscriber_parser+0x9a>
		rc = mqtt_rx_pubrel(ctx, data);
  106660:	56                   	push   %esi
  106661:	53                   	push   %ebx
  106662:	e8 a5 fd ff ff       	call   10640c <mqtt_rx_pubrel>
  106667:	5a                   	pop    %edx
		break;
  106668:	ba 0d 00 00 00       	mov    $0xd,%edx
		rc = mqtt_rx_pubrel(ctx, data);
  10666d:	59                   	pop    %ecx
		break;
  10666e:	eb 0e                	jmp    10667e <mqtt_subscriber_parser+0x9a>
		rc = mqtt_rx_suback(ctx, data);
  106670:	56                   	push   %esi
  106671:	53                   	push   %ebx
  106672:	e8 a3 fe ff ff       	call   10651a <mqtt_rx_suback>
  106677:	5a                   	pop    %edx
		break;
  106678:	ba 09 00 00 00       	mov    $0x9,%edx
		rc = mqtt_rx_suback(ctx, data);
  10667d:	59                   	pop    %ecx
	if (rc != 0 && ctx->malformed) {
  10667e:	85 c0                	test   %eax,%eax
  106680:	75 15                	jne    106697 <mqtt_subscriber_parser+0xb3>
  106682:	eb 26                	jmp    1066aa <mqtt_subscriber_parser+0xc6>
  106684:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	uint16_t pkt_type = MQTT_INVALID;
  106689:	31 d2                	xor    %edx,%edx
  10668b:	eb 0a                	jmp    106697 <mqtt_subscriber_parser+0xb3>
  10668d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  106692:	ba 02 00 00 00       	mov    $0x2,%edx
	if (rc != 0 && ctx->malformed) {
  106697:	8b 4b 20             	mov    0x20(%ebx),%ecx
  10669a:	85 c9                	test   %ecx,%ecx
  10669c:	74 0c                	je     1066aa <mqtt_subscriber_parser+0xc6>
		ctx->malformed(ctx, pkt_type);
  10669e:	52                   	push   %edx
  10669f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1066a2:	53                   	push   %ebx
  1066a3:	ff d1                	call   *%ecx
  1066a5:	5a                   	pop    %edx
  1066a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1066a9:	59                   	pop    %ecx
	net_nbuf_unref(data);
  1066aa:	56                   	push   %esi
  1066ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1066ae:	e8 a9 cc ff ff       	call   10335c <net_nbuf_unref>
  1066b3:	58                   	pop    %eax
}
  1066b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1066b7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1066ba:	5b                   	pop    %ebx
  1066bb:	5e                   	pop    %esi
  1066bc:	5d                   	pop    %ebp
  1066bd:	c3                   	ret    

001066be <mqtt_init>:

int mqtt_init(struct mqtt_ctx *ctx, enum mqtt_app app_type)
{
  1066be:	55                   	push   %ebp
  1066bf:	89 e5                	mov    %esp,%ebp
  1066c1:	56                   	push   %esi
  1066c2:	53                   	push   %ebx
  1066c3:	8b 75 08             	mov    0x8(%ebp),%esi
  1066c6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	/* So far, only clean session = 1 is supported */
	ctx->clean_session = 1;
  1066c9:	8a 46 29             	mov    0x29(%esi),%al
  1066cc:	83 c8 01             	or     $0x1,%eax
	ctx->connected = 0;
  1066cf:	83 e0 fd             	and    $0xfffffffd,%eax
  1066d2:	88 46 29             	mov    %al,0x29(%esi)

	/* Install the receiver callback, timeout is set to K_NO_WAIT.
	 * In this case, no return code is evaluated.
	 */
	(void)net_context_recv(ctx->net_ctx, mqtt_recv, K_NO_WAIT, ctx);
  1066d5:	56                   	push   %esi
  1066d6:	6a 00                	push   $0x0
  1066d8:	68 73 60 10 00       	push   $0x106073
  1066dd:	ff 36                	pushl  (%esi)
  1066df:	e8 60 c9 ff ff       	call   103044 <net_context_recv>
  1066e4:	83 c4 10             	add    $0x10,%esp

	ctx->app_type = app_type;
  1066e7:	88 5e 28             	mov    %bl,0x28(%esi)

	switch (ctx->app_type) {
  1066ea:	80 fb 01             	cmp    $0x1,%bl
  1066ed:	74 0e                	je     1066fd <mqtt_init+0x3f>
  1066ef:	80 fb 02             	cmp    $0x2,%bl
  1066f2:	75 14                	jne    106708 <mqtt_init+0x4a>
	case MQTT_APP_PUBLISHER:
		ctx->rcv = mqtt_publisher_parser;
		break;
	case MQTT_APP_SUBSCRIBER:
		ctx->rcv = mqtt_subscriber_parser;
  1066f4:	c7 46 24 e4 65 10 00 	movl   $0x1065e4,0x24(%esi)
  1066fb:	eb 07                	jmp    106704 <mqtt_init+0x46>
		ctx->rcv = mqtt_publisher_parser;
  1066fd:	c7 46 24 40 64 10 00 	movl   $0x106440,0x24(%esi)
		break;
	default:
		return -EINVAL;
	}

	return 0;
  106704:	31 c0                	xor    %eax,%eax
		break;
  106706:	eb 05                	jmp    10670d <mqtt_init+0x4f>
		return -EINVAL;
  106708:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  10670d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106710:	5b                   	pop    %ebx
  106711:	5e                   	pop    %esi
  106712:	5d                   	pop    %ebp
  106713:	c3                   	ret    

00106714 <k_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void k_cpu_idle(void)
{
  106714:	55                   	push   %ebp
  106715:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  106717:	fb                   	sti    
  106718:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  106719:	5d                   	pop    %ebp
  10671a:	c3                   	ret    

0010671b <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
  10671b:	55                   	push   %ebp
  10671c:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
  10671e:	e8 a4 10 00 00       	call   1077c7 <k_is_in_isr>
  106723:	85 c0                	test   %eax,%eax
  106725:	74 15                	je     10673c <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  106727:	e8 9b 10 00 00       	call   1077c7 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
  10672c:	ba d0 81 10 00       	mov    $0x1081d0,%edx
  106731:	85 c0                	test   %eax,%eax
  106733:	75 2e                	jne    106763 <_SysFatalErrorHandler+0x48>
  106735:	ba d4 81 10 00       	mov    $0x1081d4,%edx
  10673a:	eb 27                	jmp    106763 <_SysFatalErrorHandler+0x48>
	if (k_is_in_isr() || _is_thread_essential()) {
  10673c:	e8 97 10 00 00       	call   1077d8 <_is_thread_essential>
  106741:	85 c0                	test   %eax,%eax
  106743:	75 e2                	jne    106727 <_SysFatalErrorHandler+0xc>
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  106745:	ff 35 68 9a 10 00    	pushl  0x109a68
  10674b:	68 05 82 10 00       	push   $0x108205
  106750:	e8 63 b2 ff ff       	call   1019b8 <printk>
  106755:	58                   	pop    %eax
  106756:	5a                   	pop    %edx
	k_thread_abort(_current);
  106757:	ff 35 68 9a 10 00    	pushl  0x109a68
  10675d:	e8 f3 11 00 00       	call   107955 <k_thread_abort>
  106762:	59                   	pop    %ecx
		printk("Fatal fault in %s! Spinning...\n",
  106763:	52                   	push   %edx
  106764:	68 e5 81 10 00       	push   $0x1081e5
  106769:	e8 4a b2 ff ff       	call   1019b8 <printk>
  10676e:	58                   	pop    %eax
  10676f:	5a                   	pop    %edx
  106770:	eb fe                	jmp    106770 <_SysFatalErrorHandler+0x55>

00106772 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  106772:	53                   	push   %ebx
	movl $1, %eax
  106773:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  106778:	0f a2                	cpuid  
	movl %ebx, %eax
  10677a:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  10677c:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  106781:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  106784:	5b                   	pop    %ebx
	ret
  106785:	c3                   	ret    

00106786 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
  106786:	55                   	push   %ebp
  106787:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
  106789:	e8 e4 ff ff ff       	call   106772 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  10678e:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
  10678f:	a3 88 9b 10 00       	mov    %eax,0x109b88
}
  106794:	31 c0                	xor    %eax,%eax
  106796:	c3                   	ret    

00106797 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  106797:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  106798:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  10679b:	50                   	push   %eax
	pushl	%edx
  10679c:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  10679d:	57                   	push   %edi
	pushl	%esi
  10679e:	56                   	push   %esi
	pushl	%ebx
  10679f:	53                   	push   %ebx
	pushl	%ebp
  1067a0:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  1067a1:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  1067a5:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  1067a6:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  1067ad:	00 
	je	allDone
  1067ae:	74 01                	je     1067b1 <allDone>
	sti
  1067b0:	fb                   	sti    

001067b1 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
  1067b1:	54                   	push   %esp
#endif
	call	*%ecx			/* call exception handler */
  1067b2:	ff d1                	call   *%ecx

#ifndef CONFIG_X86_IAMCU
	addl	$0x4, %esp
  1067b4:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  1067b7:	5d                   	pop    %ebp
	popl	%ebp
  1067b8:	5d                   	pop    %ebp
	popl	%ebx
  1067b9:	5b                   	pop    %ebx
	popl	%esi
  1067ba:	5e                   	pop    %esi
	popl	%edi
  1067bb:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  1067bc:	5a                   	pop    %edx
	popl	%eax
  1067bd:	58                   	pop    %eax
	popl	%ecx
  1067be:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  1067bf:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  1067c2:	cf                   	iret   

001067c3 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  1067c3:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  1067c4:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  1067c8:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  1067cb:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  1067cc:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  1067cd:	b9 60 9a 10 00       	mov    $0x109a60,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  1067d2:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  1067d4:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  1067d7:	75 06                	jne    1067df <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  1067d9:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  1067db:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  1067de:	57                   	push   %edi

001067df <alreadyOnIntStack>:

#ifndef CONFIG_X86_IAMCU
	/* EAX has the interrupt handler argument, needs to go on
	 * stack for sys V calling convention
	 */
	push	%eax
  1067df:	50                   	push   %eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  1067e0:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  1067e1:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
  1067e3:	83 c4 04             	add    $0x4,%esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  1067e6:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  1067e7:	31 c0                	xor    %eax,%eax
  1067e9:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  1067ee:	b9 60 9a 10 00       	mov    $0x109a60,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  1067f3:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  1067f5:	75 20                	jne    106817 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  1067f7:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
  1067fa:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
  106800:	73 14                	jae    106816 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  106802:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
  106805:	74 0f                	je     106816 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  106807:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  106808:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
#endif
	call	_Swap
  106809:	e8 26 00 00 00       	call   106834 <_Swap>

#ifndef CONFIG_X86_IAMCU
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
  10680e:	83 c4 04             	add    $0x4,%esp

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  106811:	5f                   	pop    %edi
	popl	%ecx
  106812:	59                   	pop    %ecx
	popl	%edx
  106813:	5a                   	pop    %edx
	popl	%eax
  106814:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  106815:	cf                   	iret   

00106816 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  106816:	5c                   	pop    %esp

00106817 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  106817:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  106818:	59                   	pop    %ecx
	popl	%edx
  106819:	5a                   	pop    %edx
	popl	%eax
  10681a:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  10681b:	cf                   	iret   

0010681c <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  10681c:	6a 00                	push   $0x0

0010681e <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  10681e:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  10681f:	50                   	push   %eax
	pushl %ecx
  106820:	51                   	push   %ecx
	pushl %edx
  106821:	52                   	push   %edx
	pushl %edi
  106822:	57                   	push   %edi
	pushl %esi
  106823:	56                   	push   %esi
	pushl %ebx
  106824:	53                   	push   %ebx
	pushl %ebp
  106825:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  106826:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  10682a:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
  10682b:	54                   	push   %esp
#else
	mov	%esp, %edx
#endif

	/* re-enable interrupts */
	sti
  10682c:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
  10682d:	6a 00                	push   $0x0
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  10682f:	e8 a3 00 00 00       	call   1068d7 <_NanoFatalErrorHandler>

00106834 <_Swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  106834:	57                   	push   %edi

	movl	$_kernel, %edi
  106835:	bf 60 9a 10 00       	mov    $0x109a60,%edi

	pushl	%esi
  10683a:	56                   	push   %esi
	pushl	%ebx
  10683b:	53                   	push   %ebx
	pushl	%ebp
  10683c:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  10683d:	ff 35 04 84 10 00    	pushl  0x108404


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  106843:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  106846:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  106849:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  10684c:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  10684f:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
  106852:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  106853:	5d                   	pop    %ebp
	popl	%ebx
  106854:	5b                   	pop    %ebx
	popl	%esi
  106855:	5e                   	pop    %esi
	popl	%edi
  106856:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  106857:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  10685b:	9d                   	popf   
	 * will not do that for us.
	 */
	popl	%edx
	movl	%edx, (%esp)
#endif
	ret
  10685c:	c3                   	ret    

0010685d <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  10685d:	55                   	push   %ebp
  10685e:	89 e5                	mov    %esp,%ebp
  106860:	56                   	push   %esi
  106861:	53                   	push   %ebx
  106862:	8b 75 08             	mov    0x8(%ebp),%esi
  106865:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	_ASSERT_VALID_PRIO(priority, pEntry);

	unsigned long *pInitialThread;

#ifdef CONFIG_INIT_STACKS
	memset(pStackMem, 0xaa, stackSize);
  106868:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  106869:	01 f3                	add    %esi,%ebx
  10686b:	83 e3 fc             	and    $0xfffffffc,%ebx
	memset(pStackMem, 0xaa, stackSize);
  10686e:	68 aa 00 00 00       	push   $0xaa
  106873:	56                   	push   %esi
  106874:	e8 5f ac ff ff       	call   1014d8 <memset>
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  106879:	8b 45 1c             	mov    0x1c(%ebp),%eax
	memset(pStackMem, 0xaa, stackSize);
  10687c:	83 c4 0c             	add    $0xc,%esp
	*--pInitialThread = (unsigned long)parameter3;
  10687f:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  106882:	8b 45 18             	mov    0x18(%ebp),%eax
  106885:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  106888:	8b 45 14             	mov    0x14(%ebp),%eax
  10688b:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  10688e:	8b 45 10             	mov    0x10(%ebp),%eax
  106891:	89 43 f0             	mov    %eax,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  106894:	9c                   	pushf  
  106895:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  106896:	80 e4 cd             	and    $0xcd,%ah

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;

#else /* defined(CONFIG_GDB_INFO) || defined(CONFIG_DEBUG_INFO) */

	*--pInitialThread = (unsigned long)_thread_entry;
  106899:	c7 43 e8 e8 77 10 00 	movl   $0x1077e8,-0x18(%ebx)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  1068a0:	80 cc 02             	or     $0x2,%ah
	pInitialCtx -= 11;
  1068a3:	83 eb 2c             	sub    $0x2c,%ebx
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  1068a6:	89 43 18             	mov    %eax,0x18(%ebx)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  1068a9:	ff 75 24             	pushl  0x24(%ebp)
  1068ac:	6a 04                	push   $0x4
  1068ae:	ff 75 20             	pushl  0x20(%ebp)
  1068b1:	56                   	push   %esi
  1068b2:	e8 64 10 00 00       	call   10791b <_init_thread_base>
	thread->init_data = NULL;
  1068b7:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
	thread->fn_abort = NULL;
  1068be:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
	pInitialCtx -= 11;
  1068c5:	89 5e 28             	mov    %ebx,0x28(%esi)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  1068c8:	83 c4 10             	add    $0x10,%esp
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
  1068cb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1068ce:	5b                   	pop    %ebx
  1068cf:	5e                   	pop    %esi
  1068d0:	5d                   	pop    %ebp
  1068d1:	c3                   	ret    

001068d2 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  1068d2:	55                   	push   %ebp
  1068d3:	89 e5                	mov    %esp,%ebp
  1068d5:	5d                   	pop    %ebp
  1068d6:	c3                   	ret    

001068d7 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  1068d7:	55                   	push   %ebp
  1068d8:	89 e5                	mov    %esp,%ebp
  1068da:	57                   	push   %edi
  1068db:	56                   	push   %esi
  1068dc:	53                   	push   %ebx
  1068dd:	83 ec 28             	sub    $0x28,%esp
  1068e0:	8b 75 08             	mov    0x8(%ebp),%esi
  1068e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
	_debug_fatal_hook(pEsf);
  1068e6:	57                   	push   %edi
  1068e7:	e8 e6 ff ff ff       	call   1068d2 <_debug_fatal_hook>
  1068ec:	58                   	pop    %eax

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  1068ed:	83 fe 03             	cmp    $0x3,%esi
  1068f0:	74 3e                	je     106930 <_NanoFatalErrorHandler+0x59>
  1068f2:	77 06                	ja     1068fa <_NanoFatalErrorHandler+0x23>
  1068f4:	85 f6                	test   %esi,%esi
  1068f6:	74 0e                	je     106906 <_NanoFatalErrorHandler+0x2f>
  1068f8:	eb 4a                	jmp    106944 <_NanoFatalErrorHandler+0x6d>
  1068fa:	83 fe 05             	cmp    $0x5,%esi
  1068fd:	74 3e                	je     10693d <_NanoFatalErrorHandler+0x66>
  1068ff:	83 fe 06             	cmp    $0x6,%esi
  106902:	74 4d                	je     106951 <_NanoFatalErrorHandler+0x7a>
  106904:	eb 3e                	jmp    106944 <_NanoFatalErrorHandler+0x6d>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  106906:	e8 e0 a5 ff ff       	call   100eeb <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  10690b:	68 2a 82 10 00       	push   $0x10822a
  106910:	89 c3                	mov    %eax,%ebx
  106912:	e8 a1 b0 ff ff       	call   1019b8 <printk>
  106917:	58                   	pop    %eax
		if (vector >= 0) {
  106918:	85 db                	test   %ebx,%ebx
  10691a:	78 0d                	js     106929 <_NanoFatalErrorHandler+0x52>
			printk("%d ", vector);
  10691c:	53                   	push   %ebx
  10691d:	68 4c 82 10 00       	push   $0x10824c
  106922:	e8 91 b0 ff ff       	call   1019b8 <printk>
  106927:	5b                   	pop    %ebx
  106928:	58                   	pop    %eax
		}
		printk("*****\n");
  106929:	68 73 82 10 00       	push   $0x108273
  10692e:	eb 05                	jmp    106935 <_NanoFatalErrorHandler+0x5e>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  106930:	68 50 82 10 00       	push   $0x108250
  106935:	e8 7e b0 ff ff       	call   1019b8 <printk>
  10693a:	59                   	pop    %ecx
		break;
  10693b:	eb 14                	jmp    106951 <_NanoFatalErrorHandler+0x7a>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  10693d:	68 7a 82 10 00       	push   $0x10827a
  106942:	eb f1                	jmp    106935 <_NanoFatalErrorHandler+0x5e>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  106944:	56                   	push   %esi
  106945:	68 a0 82 10 00       	push   $0x1082a0
  10694a:	e8 69 b0 ff ff       	call   1019b8 <printk>
  10694f:	58                   	pop    %eax
  106950:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
  106951:	8b 47 04             	mov    0x4(%edi),%eax
  106954:	8b 4f 2c             	mov    0x2c(%edi),%ecx
  106957:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10695a:	8b 47 10             	mov    0x10(%edi),%eax
  10695d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106960:	8b 47 0c             	mov    0xc(%edi),%eax
  106963:	89 45 e8             	mov    %eax,-0x18(%ebp)
  106966:	8b 47 14             	mov    0x14(%edi),%eax
  106969:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10696c:	8b 47 1c             	mov    0x1c(%edi),%eax
  10696f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106972:	8b 47 08             	mov    0x8(%edi),%eax
  106975:	89 45 dc             	mov    %eax,-0x24(%ebp)
  106978:	8b 47 18             	mov    0x18(%edi),%eax
  10697b:	8b 17                	mov    (%edi),%edx
  10697d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  106980:	8b 47 24             	mov    0x24(%edi),%eax
  106983:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  106986:	89 55 d0             	mov    %edx,-0x30(%ebp)
  106989:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10698c:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
  106990:	e8 a0 09 00 00       	call   107335 <k_current_get>
  106995:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  106998:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10699b:	51                   	push   %ecx
  10699c:	52                   	push   %edx
  10699d:	ff 75 f0             	pushl  -0x10(%ebp)
  1069a0:	ff 75 ec             	pushl  -0x14(%ebp)
  1069a3:	ff 75 e8             	pushl  -0x18(%ebp)
  1069a6:	ff 75 e4             	pushl  -0x1c(%ebp)
  1069a9:	ff 75 e0             	pushl  -0x20(%ebp)
  1069ac:	ff 75 dc             	pushl  -0x24(%ebp)
  1069af:	ff 75 d8             	pushl  -0x28(%ebp)
  1069b2:	ff 75 d4             	pushl  -0x2c(%ebp)
  1069b5:	53                   	push   %ebx
  1069b6:	50                   	push   %eax
  1069b7:	68 c3 82 10 00       	push   $0x1082c3
  1069bc:	e8 f7 af ff ff       	call   1019b8 <printk>
  1069c1:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  1069c4:	57                   	push   %edi
  1069c5:	56                   	push   %esi
  1069c6:	e8 50 fd ff ff       	call   10671b <_SysFatalErrorHandler>

001069cb <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  1069cb:	55                   	push   %ebp
  1069cc:	89 e5                	mov    %esp,%ebp
  1069ce:	56                   	push   %esi
  1069cf:	89 c6                	mov    %eax,%esi
  1069d1:	53                   	push   %ebx
  1069d2:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
  1069d4:	50                   	push   %eax
  1069d5:	68 62 83 10 00       	push   $0x108362
  1069da:	e8 d9 af ff ff       	call   1019b8 <printk>
  1069df:	59                   	pop    %ecx
  1069e0:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  1069e1:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  1069e6:	0f a3 f0             	bt     %esi,%eax
  1069e9:	73 0f                	jae    1069fa <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  1069eb:	ff 73 20             	pushl  0x20(%ebx)
  1069ee:	68 7a 83 10 00       	push   $0x10837a
  1069f3:	e8 c0 af ff ff       	call   1019b8 <printk>
  1069f8:	58                   	pop    %eax
  1069f9:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  1069fa:	53                   	push   %ebx
  1069fb:	6a 06                	push   $0x6
  1069fd:	e8 d5 fe ff ff       	call   1068d7 <_NanoFatalErrorHandler>

00106a02 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  106a02:	55                   	push   %ebp
  106a03:	31 c0                	xor    %eax,%eax
  106a05:	89 e5                	mov    %esp,%ebp
  106a07:	8b 55 08             	mov    0x8(%ebp),%edx
  106a0a:	e8 bc ff ff ff       	call   1069cb <generic_exc_handle>

00106a0f <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  106a0f:	55                   	push   %ebp
  106a10:	b8 02 00 00 00       	mov    $0x2,%eax
  106a15:	89 e5                	mov    %esp,%ebp
  106a17:	8b 55 08             	mov    0x8(%ebp),%edx
  106a1a:	e8 ac ff ff ff       	call   1069cb <generic_exc_handle>

00106a1f <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  106a1f:	55                   	push   %ebp
  106a20:	b8 04 00 00 00       	mov    $0x4,%eax
  106a25:	89 e5                	mov    %esp,%ebp
  106a27:	8b 55 08             	mov    0x8(%ebp),%edx
  106a2a:	e8 9c ff ff ff       	call   1069cb <generic_exc_handle>

00106a2f <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  106a2f:	55                   	push   %ebp
  106a30:	b8 05 00 00 00       	mov    $0x5,%eax
  106a35:	89 e5                	mov    %esp,%ebp
  106a37:	8b 55 08             	mov    0x8(%ebp),%edx
  106a3a:	e8 8c ff ff ff       	call   1069cb <generic_exc_handle>

00106a3f <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  106a3f:	55                   	push   %ebp
  106a40:	b8 06 00 00 00       	mov    $0x6,%eax
  106a45:	89 e5                	mov    %esp,%ebp
  106a47:	8b 55 08             	mov    0x8(%ebp),%edx
  106a4a:	e8 7c ff ff ff       	call   1069cb <generic_exc_handle>

00106a4f <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  106a4f:	55                   	push   %ebp
  106a50:	b8 07 00 00 00       	mov    $0x7,%eax
  106a55:	89 e5                	mov    %esp,%ebp
  106a57:	8b 55 08             	mov    0x8(%ebp),%edx
  106a5a:	e8 6c ff ff ff       	call   1069cb <generic_exc_handle>

00106a5f <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  106a5f:	55                   	push   %ebp
  106a60:	b8 08 00 00 00       	mov    $0x8,%eax
  106a65:	89 e5                	mov    %esp,%ebp
  106a67:	8b 55 08             	mov    0x8(%ebp),%edx
  106a6a:	e8 5c ff ff ff       	call   1069cb <generic_exc_handle>

00106a6f <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  106a6f:	55                   	push   %ebp
  106a70:	b8 0a 00 00 00       	mov    $0xa,%eax
  106a75:	89 e5                	mov    %esp,%ebp
  106a77:	8b 55 08             	mov    0x8(%ebp),%edx
  106a7a:	e8 4c ff ff ff       	call   1069cb <generic_exc_handle>

00106a7f <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  106a7f:	55                   	push   %ebp
  106a80:	b8 0b 00 00 00       	mov    $0xb,%eax
  106a85:	89 e5                	mov    %esp,%ebp
  106a87:	8b 55 08             	mov    0x8(%ebp),%edx
  106a8a:	e8 3c ff ff ff       	call   1069cb <generic_exc_handle>

00106a8f <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  106a8f:	55                   	push   %ebp
  106a90:	b8 0c 00 00 00       	mov    $0xc,%eax
  106a95:	89 e5                	mov    %esp,%ebp
  106a97:	8b 55 08             	mov    0x8(%ebp),%edx
  106a9a:	e8 2c ff ff ff       	call   1069cb <generic_exc_handle>

00106a9f <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  106a9f:	55                   	push   %ebp
  106aa0:	b8 0d 00 00 00       	mov    $0xd,%eax
  106aa5:	89 e5                	mov    %esp,%ebp
  106aa7:	8b 55 08             	mov    0x8(%ebp),%edx
  106aaa:	e8 1c ff ff ff       	call   1069cb <generic_exc_handle>

00106aaf <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  106aaf:	55                   	push   %ebp
  106ab0:	b8 0e 00 00 00       	mov    $0xe,%eax
  106ab5:	89 e5                	mov    %esp,%ebp
  106ab7:	8b 55 08             	mov    0x8(%ebp),%edx
  106aba:	e8 0c ff ff ff       	call   1069cb <generic_exc_handle>

00106abf <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  106abf:	55                   	push   %ebp
  106ac0:	b8 10 00 00 00       	mov    $0x10,%eax
  106ac5:	89 e5                	mov    %esp,%ebp
  106ac7:	8b 55 08             	mov    0x8(%ebp),%edx
  106aca:	e8 fc fe ff ff       	call   1069cb <generic_exc_handle>

00106acf <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  106acf:	55                   	push   %ebp
  106ad0:	b8 11 00 00 00       	mov    $0x11,%eax
  106ad5:	89 e5                	mov    %esp,%ebp
  106ad7:	8b 55 08             	mov    0x8(%ebp),%edx
  106ada:	e8 ec fe ff ff       	call   1069cb <generic_exc_handle>

00106adf <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  106adf:	55                   	push   %ebp
  106ae0:	b8 12 00 00 00       	mov    $0x12,%eax
  106ae5:	89 e5                	mov    %esp,%ebp
  106ae7:	8b 55 08             	mov    0x8(%ebp),%edx
  106aea:	e8 dc fe ff ff       	call   1069cb <generic_exc_handle>

00106aef <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  106aef:	55                   	push   %ebp
  106af0:	89 e5                	mov    %esp,%ebp
  106af2:	56                   	push   %esi
  106af3:	53                   	push   %ebx
  106af4:	8b 45 08             	mov    0x8(%ebp),%eax
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  106af7:	8b 1c 85 e0 83 10 00 	mov    0x1083e0(,%eax,4),%ebx
  106afe:	8d 70 01             	lea    0x1(%eax),%esi
  106b01:	3b 1c b5 e0 83 10 00 	cmp    0x1083e0(,%esi,4),%ebx
  106b08:	73 0c                	jae    106b16 <_sys_device_do_config_level+0x27>
		struct device_config *device = info->config;

		device->init(info);
  106b0a:	8b 03                	mov    (%ebx),%eax
  106b0c:	53                   	push   %ebx
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  106b0d:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
  106b10:	ff 50 04             	call   *0x4(%eax)
  106b13:	58                   	pop    %eax
  106b14:	eb eb                	jmp    106b01 <_sys_device_do_config_level+0x12>
	}
}
  106b16:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106b19:	5b                   	pop    %ebx
  106b1a:	5e                   	pop    %esi
  106b1b:	5d                   	pop    %ebp
  106b1c:	c3                   	ret    

00106b1d <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  106b1d:	55                   	push   %ebp
  106b1e:	89 e5                	mov    %esp,%ebp
  106b20:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  106b21:	bb 90 8d 10 00       	mov    $0x108d90,%ebx
  106b26:	81 fb 14 8e 10 00    	cmp    $0x108e14,%ebx
  106b2c:	74 1f                	je     106b4d <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  106b2e:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  106b32:	75 05                	jne    106b39 <device_get_binding+0x1c>
	for (info = __device_init_start; info != __device_init_end; info++) {
  106b34:	83 c3 0c             	add    $0xc,%ebx
  106b37:	eb ed                	jmp    106b26 <device_get_binding+0x9>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  106b39:	8b 03                	mov    (%ebx),%eax
  106b3b:	ff 30                	pushl  (%eax)
  106b3d:	ff 75 08             	pushl  0x8(%ebp)
  106b40:	e8 a0 a8 ff ff       	call   1013e5 <strcmp>
  106b45:	5a                   	pop    %edx
  106b46:	85 c0                	test   %eax,%eax
  106b48:	59                   	pop    %ecx
  106b49:	75 e9                	jne    106b34 <device_get_binding+0x17>
  106b4b:	eb 02                	jmp    106b4f <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
  106b4d:	31 db                	xor    %ebx,%ebx
}
  106b4f:	89 d8                	mov    %ebx,%eax
  106b51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  106b54:	c9                   	leave  
  106b55:	c3                   	ret    

00106b56 <_get_errno>:
 */
const int _k_neg_eagain = -EAGAIN;

#ifdef CONFIG_ERRNO
int *_get_errno(void)
{
  106b56:	55                   	push   %ebp
	return &_current->errno_var;
  106b57:	a1 68 9a 10 00       	mov    0x109a68,%eax
{
  106b5c:	89 e5                	mov    %esp,%ebp
	return &_current->errno_var;
  106b5e:	83 c0 34             	add    $0x34,%eax
}
  106b61:	5d                   	pop    %ebp
  106b62:	c3                   	ret    

00106b63 <_ready_thread>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  106b63:	8a 50 09             	mov    0x9(%eax),%dl
  106b66:	88 d1                	mov    %dl,%cl
  106b68:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
  106b6b:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
  106b6e:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
  106b71:	75 11                	jne    106b84 <_ready_thread+0x21>
  106b73:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  106b77:	75 0b                	jne    106b84 <_ready_thread+0x21>
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
  106b79:	55                   	push   %ebp
  106b7a:	89 e5                	mov    %esp,%ebp

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
  106b7c:	50                   	push   %eax
  106b7d:	e8 02 05 00 00       	call   107084 <_add_thread_to_ready_q>
  106b82:	58                   	pop    %eax
	}
}
  106b83:	c9                   	leave  
  106b84:	c3                   	ret    

00106b85 <_must_switch_threads>:
	return _is_preempt(_current) && __must_switch_threads();
  106b85:	8b 15 68 9a 10 00    	mov    0x109a68,%edx
  106b8b:	66 83 7a 0a 7f       	cmpw   $0x7f,0xa(%edx)
  106b90:	77 12                	ja     106ba4 <_must_switch_threads+0x1f>
{
  106b92:	55                   	push   %ebp
  106b93:	89 e5                	mov    %esp,%ebp
	return _is_preempt(_current) && __must_switch_threads();
  106b95:	e8 4e 06 00 00       	call   1071e8 <__must_switch_threads>
}
  106b9a:	5d                   	pop    %ebp
	return _is_preempt(_current) && __must_switch_threads();
  106b9b:	85 c0                	test   %eax,%eax
  106b9d:	0f 95 c0             	setne  %al
  106ba0:	0f b6 c0             	movzbl %al,%eax
}
  106ba3:	c3                   	ret    
  106ba4:	31 c0                	xor    %eax,%eax
  106ba6:	c3                   	ret    

00106ba7 <_find_first_thread_to_unpend.constprop.10>:
{
	return (struct k_thread *)sys_dlist_peek_head(wait_q);
}

static inline struct k_thread *
_find_first_thread_to_unpend(_wait_q_t *wait_q, struct k_thread *from)
  106ba7:	55                   	push   %ebp
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	extern volatile int _handling_timeouts;

	if (_handling_timeouts) {
  106ba8:	8b 15 90 9b 10 00    	mov    0x109b90,%edx
  106bae:	85 d2                	test   %edx,%edx
_find_first_thread_to_unpend(_wait_q_t *wait_q, struct k_thread *from)
  106bb0:	89 e5                	mov    %esp,%ebp
  106bb2:	8b 10                	mov    (%eax),%edx
	if (_handling_timeouts) {
  106bb4:	74 1b                	je     106bd1 <_find_first_thread_to_unpend.constprop.10+0x2a>
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  106bb6:	39 d0                	cmp    %edx,%eax
  106bb8:	75 11                	jne    106bcb <_find_first_thread_to_unpend.constprop.10+0x24>
  106bba:	31 d2                	xor    %edx,%edx
  106bbc:	eb 0d                	jmp    106bcb <_find_first_thread_to_unpend.constprop.10+0x24>

		/* skip threads that have an expired timeout */
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
			struct k_thread *thread = (struct k_thread *)cur;

			if (_is_thread_timeout_expired(thread)) {
  106bbe:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
  106bc2:	75 13                	jne    106bd7 <_find_first_thread_to_unpend.constprop.10+0x30>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  106bc4:	3b 50 04             	cmp    0x4(%eax),%edx
  106bc7:	74 0c                	je     106bd5 <_find_first_thread_to_unpend.constprop.10+0x2e>
  106bc9:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  106bcb:	85 d2                	test   %edx,%edx
  106bcd:	75 ef                	jne    106bbe <_find_first_thread_to_unpend.constprop.10+0x17>
  106bcf:	eb 04                	jmp    106bd5 <_find_first_thread_to_unpend.constprop.10+0x2e>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  106bd1:	39 d0                	cmp    %edx,%eax
  106bd3:	75 02                	jne    106bd7 <_find_first_thread_to_unpend.constprop.10+0x30>
  106bd5:	31 d2                	xor    %edx,%edx
	ARG_UNUSED(from);
#endif

	return (struct k_thread *)sys_dlist_peek_head(wait_q);

}
  106bd7:	89 d0                	mov    %edx,%eax
  106bd9:	5d                   	pop    %ebp
  106bda:	c3                   	ret    

00106bdb <_abort_timeout>:
	}
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
  106bdb:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  106bdc:	8b 48 10             	mov    0x10(%eax),%ecx
{
  106bdf:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  106be1:	83 f9 ff             	cmp    $0xffffffff,%ecx
  106be4:	74 24                	je     106c0a <_abort_timeout+0x2f>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  106be6:	3b 05 70 9a 10 00    	cmp    0x109a70,%eax
  106bec:	74 05                	je     106bf3 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
  106bee:	8b 10                	mov    (%eax),%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  106bf0:	01 4a 10             	add    %ecx,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  106bf3:	8b 50 04             	mov    0x4(%eax),%edx
  106bf6:	8b 08                	mov    (%eax),%ecx
  106bf8:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  106bfa:	8b 08                	mov    (%eax),%ecx
  106bfc:	89 51 04             	mov    %edx,0x4(%ecx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  106bff:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)

	return 0;
  106c06:	31 c0                	xor    %eax,%eax
  106c08:	eb 03                	jmp    106c0d <_abort_timeout+0x32>
		return _INACTIVE;
  106c0a:	83 c8 ff             	or     $0xffffffff,%eax
}
  106c0d:	5d                   	pop    %ebp
  106c0e:	c3                   	ret    

00106c0f <k_fifo_init>:
SYS_INIT(init_fifo_module, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

#endif /* CONFIG_OBJECT_TRACING */

void k_fifo_init(struct k_fifo *fifo)
{
  106c0f:	55                   	push   %ebp
  106c10:	89 e5                	mov    %esp,%ebp
  106c12:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = NULL;
  106c15:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	list->tail = NULL;
  106c1c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	list->head = (sys_dnode_t *)list;
  106c23:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  106c25:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&fifo->wait_q);

	_INIT_OBJ_POLL_EVENT(fifo);

	SYS_TRACING_OBJ_INIT(k_fifo, fifo);
}
  106c28:	5d                   	pop    %ebp
  106c29:	c3                   	ret    

00106c2a <k_fifo_put_list>:

	irq_unlock(key);
}

void k_fifo_put_list(struct k_fifo *fifo, void *head, void *tail)
{
  106c2a:	55                   	push   %ebp
  106c2b:	89 e5                	mov    %esp,%ebp
  106c2d:	57                   	push   %edi
  106c2e:	56                   	push   %esi
  106c2f:	53                   	push   %ebx
  106c30:	83 ec 0c             	sub    $0xc,%esp
  106c33:	8b 45 10             	mov    0x10(%ebp),%eax
  106c36:	8b 75 08             	mov    0x8(%ebp),%esi
  106c39:	8b 7d 0c             	mov    0xc(%ebp),%edi
  106c3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	__asm__ volatile (
  106c3f:	9c                   	pushf  
  106c40:	fa                   	cli    
  106c41:	8f 45 e8             	popl   -0x18(%ebp)
	return list->head == list;
  106c44:	8b 06                	mov    (%esi),%eax
  106c46:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
  106c49:	39 c6                	cmp    %eax,%esi
  106c4b:	75 07                	jne    106c54 <k_fifo_put_list+0x2a>
  106c4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	unsigned int key;

	key = irq_lock();

	first_thread = _peek_first_pending_thread(&fifo->wait_q);
	while (head && ((thread = _unpend_first_thread(&fifo->wait_q)))) {
  106c54:	85 ff                	test   %edi,%edi
  106c56:	74 50                	je     106ca8 <k_fifo_put_list+0x7e>

/* unpend the first thread from a wait queue */
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);
  106c58:	89 f0                	mov    %esi,%eax
  106c5a:	e8 48 ff ff ff       	call   106ba7 <_find_first_thread_to_unpend.constprop.10>
  106c5f:	89 c3                	mov    %eax,%ebx

	if (thread) {
  106c61:	85 c0                	test   %eax,%eax
  106c63:	74 2f                	je     106c94 <k_fifo_put_list+0x6a>
	node->prev->next = node->next;
  106c65:	8b 40 04             	mov    0x4(%eax),%eax
  106c68:	8b 0b                	mov    (%ebx),%ecx
  106c6a:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  106c6c:	8b 0b                	mov    (%ebx),%ecx
  106c6e:	89 41 04             	mov    %eax,0x4(%ecx)

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  106c71:	8d 43 10             	lea    0x10(%ebx),%eax
	thread->base.thread_state &= ~_THREAD_PENDING;
  106c74:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
  106c78:	e8 5e ff ff ff       	call   106bdb <_abort_timeout>
	_ready_thread(thread);
  106c7d:	89 d8                	mov    %ebx,%eax
  106c7f:	e8 df fe ff ff       	call   106b63 <_ready_thread>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  106c84:	8b 43 28             	mov    0x28(%ebx),%eax
  106c87:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
_set_thread_return_value_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	_set_thread_return_value(thread, value);
	thread->base.swap_data = data;
  106c8d:	89 7b 0c             	mov    %edi,0xc(%ebx)
		prepare_thread_to_run(thread, head);
		head = *(void **)head;
  106c90:	8b 3f                	mov    (%edi),%edi
  106c92:	eb c0                	jmp    106c54 <k_fifo_put_list+0x2a>
	if (!list->tail) {
  106c94:	8b 46 0c             	mov    0xc(%esi),%eax
  106c97:	85 c0                	test   %eax,%eax
  106c99:	75 05                	jne    106ca0 <k_fifo_put_list+0x76>
		list->head = (sys_snode_t *)head;
  106c9b:	89 7e 08             	mov    %edi,0x8(%esi)
  106c9e:	eb 02                	jmp    106ca2 <k_fifo_put_list+0x78>
		list->tail->next = (sys_snode_t *)head;
  106ca0:	89 38                	mov    %edi,(%eax)
		list->tail = (sys_snode_t *)tail;
  106ca2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106ca5:	89 46 0c             	mov    %eax,0xc(%esi)

	if (head) {
		sys_slist_append_list(&fifo->data_q, head, tail);
	}

	if (first_thread) {
  106ca8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  106cac:	74 24                	je     106cd2 <k_fifo_put_list+0xa8>
		if (!_is_in_isr() && _must_switch_threads()) {
  106cae:	83 3d 60 9a 10 00 00 	cmpl   $0x0,0x109a60
  106cb5:	75 1b                	jne    106cd2 <k_fifo_put_list+0xa8>
  106cb7:	e8 c9 fe ff ff       	call   106b85 <_must_switch_threads>
  106cbc:	85 c0                	test   %eax,%eax
  106cbe:	74 12                	je     106cd2 <k_fifo_put_list+0xa8>
			(void)_Swap(key);
  106cc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106cc3:	89 45 08             	mov    %eax,0x8(%ebp)
			return;
		}
	}

	irq_unlock(key);
}
  106cc6:	83 c4 0c             	add    $0xc,%esp
  106cc9:	5b                   	pop    %ebx
  106cca:	5e                   	pop    %esi
  106ccb:	5f                   	pop    %edi
  106ccc:	5d                   	pop    %ebp
			(void)_Swap(key);
  106ccd:	e9 62 fb ff ff       	jmp    106834 <_Swap>
  106cd2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106cd5:	0f ba e0 09          	bt     $0x9,%eax
  106cd9:	73 01                	jae    106cdc <k_fifo_put_list+0xb2>
	__asm__ volatile (
  106cdb:	fb                   	sti    
}
  106cdc:	83 c4 0c             	add    $0xc,%esp
  106cdf:	5b                   	pop    %ebx
  106ce0:	5e                   	pop    %esi
  106ce1:	5f                   	pop    %edi
  106ce2:	5d                   	pop    %ebp
  106ce3:	c3                   	ret    

00106ce4 <k_fifo_get>:
	 */
	return k_fifo_put_list(fifo, list->head, list->tail);
}

void *k_fifo_get(struct k_fifo *fifo, int32_t timeout)
{
  106ce4:	55                   	push   %ebp
  106ce5:	89 e5                	mov    %esp,%ebp
  106ce7:	53                   	push   %ebx
  106ce8:	8b 55 08             	mov    0x8(%ebp),%edx
  106ceb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	__asm__ volatile (
  106cee:	9c                   	pushf  
  106cef:	fa                   	cli    
  106cf0:	5b                   	pop    %ebx
  106cf1:	8b 42 08             	mov    0x8(%edx),%eax
	unsigned int key;
	void *data;

	key = irq_lock();

	if (likely(!sys_slist_is_empty(&fifo->data_q))) {
  106cf4:	85 c0                	test   %eax,%eax
  106cf6:	74 16                	je     106d0e <k_fifo_get+0x2a>
	list->head = node->next;
  106cf8:	8b 08                	mov    (%eax),%ecx
	if (list->tail == node) {
  106cfa:	3b 42 0c             	cmp    0xc(%edx),%eax
	list->head = node->next;
  106cfd:	89 4a 08             	mov    %ecx,0x8(%edx)
	if (list->tail == node) {
  106d00:	75 03                	jne    106d05 <k_fifo_get+0x21>
		list->tail = list->head;
  106d02:	89 4a 0c             	mov    %ecx,0xc(%edx)
  106d05:	0f ba e3 09          	bt     $0x9,%ebx
  106d09:	73 2e                	jae    106d39 <k_fifo_get+0x55>
	__asm__ volatile (
  106d0b:	fb                   	sti    
  106d0c:	eb 2b                	jmp    106d39 <k_fifo_get+0x55>
		data = sys_slist_get_not_empty(&fifo->data_q);
		irq_unlock(key);
		return data;
	}

	if (timeout == K_NO_WAIT) {
  106d0e:	85 c9                	test   %ecx,%ecx
  106d10:	75 0b                	jne    106d1d <k_fifo_get+0x39>
  106d12:	0f ba e3 09          	bt     $0x9,%ebx
  106d16:	73 01                	jae    106d19 <k_fifo_get+0x35>
  106d18:	fb                   	sti    
		irq_unlock(key);
		return NULL;
  106d19:	31 c0                	xor    %eax,%eax
  106d1b:	eb 1c                	jmp    106d39 <k_fifo_get+0x55>
	}

	_pend_current_thread(&fifo->wait_q, timeout);
  106d1d:	51                   	push   %ecx
  106d1e:	52                   	push   %edx
  106d1f:	e8 9f 04 00 00       	call   1071c3 <_pend_current_thread>
  106d24:	58                   	pop    %eax
  106d25:	5a                   	pop    %edx

	return _Swap(key) ? NULL : _current->base.swap_data;
  106d26:	53                   	push   %ebx
  106d27:	e8 08 fb ff ff       	call   106834 <_Swap>
  106d2c:	59                   	pop    %ecx
  106d2d:	85 c0                	test   %eax,%eax
  106d2f:	75 e8                	jne    106d19 <k_fifo_get+0x35>
  106d31:	a1 68 9a 10 00       	mov    0x109a68,%eax
  106d36:	8b 40 0c             	mov    0xc(%eax),%eax
}
  106d39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  106d3c:	c9                   	leave  
  106d3d:	c3                   	ret    

00106d3e <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
  106d3e:	55                   	push   %ebp
  106d3f:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  106d41:	6a 02                	push   $0x2
  106d43:	e8 a7 fd ff ff       	call   106aef <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  106d48:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  106d4f:	e8 9b fd ff ff       	call   106aef <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  106d54:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  106d5b:	e8 8f fd ff ff       	call   106aef <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  106d60:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  106d67:	e8 83 fd ff ff       	call   106aef <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  106d6c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  106d73:	e8 77 fd ff ff       	call   106aef <_sys_device_do_config_level>
  106d78:	58                   	pop    %eax
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  106d79:	e8 24 0b 00 00       	call   1078a2 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  106d7e:	e8 be 95 ff ff       	call   100341 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  106d83:	80 25 a8 c4 10 00 fe 	andb   $0xfe,0x10c4a8
}
  106d8a:	c9                   	leave  
  106d8b:	c3                   	ret    

00106d8c <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  106d8c:	55                   	push   %ebp
  106d8d:	89 e5                	mov    %esp,%ebp
  106d8f:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
  106d92:	8d 45 c8             	lea    -0x38(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
  106d95:	c6 45 d0 01          	movb   $0x1,-0x30(%ebp)
	_current = dummy_thread;
  106d99:	a3 68 9a 10 00       	mov    %eax,0x109a68
	dummy_thread->base.user_options = K_ESSENTIAL;
  106d9e:	b8 1c 00 00 00       	mov    $0x1c,%eax
  106da3:	8d 90 60 9a 10 00    	lea    0x109a60(%eax),%edx
  106da9:	83 c0 08             	add    $0x8,%eax
	list->head = (sys_dnode_t *)list;
  106dac:	89 90 58 9a 10 00    	mov    %edx,0x109a58(%eax)
	list->tail = (sys_dnode_t *)list;
  106db2:	89 90 5c 9a 10 00    	mov    %edx,0x109a5c(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  106db8:	3d 1c 01 00 00       	cmp    $0x11c,%eax
  106dbd:	75 e4                	jne    106da3 <_Cstart+0x17>
	_new_thread(_main_stack, MAIN_STACK_SIZE,
  106dbf:	6a 01                	push   $0x1
  106dc1:	6a 00                	push   $0x0
  106dc3:	6a 00                	push   $0x0
  106dc5:	6a 00                	push   $0x0
  106dc7:	6a 00                	push   $0x0
  106dc9:	68 3e 6d 10 00       	push   $0x106d3e
  106dce:	68 00 08 00 00       	push   $0x800
  106dd3:	68 a0 c4 10 00       	push   $0x10c4a0
	_ready_q.cache = _main_thread;
  106dd8:	c7 05 74 9a 10 00 a0 	movl   $0x10c4a0,0x109a74
  106ddf:	c4 10 00 
	_new_thread(_main_stack, MAIN_STACK_SIZE,
  106de2:	e8 76 fa ff ff       	call   10685d <_new_thread>
  106de7:	83 c4 20             	add    $0x20,%esp
	thread->base.thread_state &= ~_THREAD_PRESTART;
  106dea:	80 25 a9 c4 10 00 fb 	andb   $0xfb,0x10c4a9
	_add_thread_to_ready_q(_main_thread);
  106df1:	68 a0 c4 10 00       	push   $0x10c4a0
  106df6:	e8 89 02 00 00       	call   107084 <_add_thread_to_ready_q>
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  106dfb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106e02:	6a 0f                	push   $0xf
  106e04:	6a 00                	push   $0x0
  106e06:	6a 00                	push   $0x0
  106e08:	6a 00                	push   $0x0
  106e0a:	68 d9 7c 10 00       	push   $0x107cd9
  106e0f:	68 00 01 00 00       	push   $0x100
  106e14:	68 a0 c3 10 00       	push   $0x10c3a0
  106e19:	e8 3f fa ff ff       	call   10685d <_new_thread>
  106e1e:	83 c4 20             	add    $0x20,%esp
	_add_thread_to_ready_q(_idle_thread);
  106e21:	68 a0 c3 10 00       	push   $0x10c3a0
  106e26:	80 25 a9 c3 10 00 fb 	andb   $0xfb,0x10c3a9
  106e2d:	e8 52 02 00 00       	call   107084 <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  106e32:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
	list->head = (sys_dnode_t *)list;
  106e39:	c7 05 6c 9a 10 00 6c 	movl   $0x109a6c,0x109a6c
  106e40:	9a 10 00 
	list->tail = (sys_dnode_t *)list;
  106e43:	c7 05 70 9a 10 00 6c 	movl   $0x109a6c,0x109a70
  106e4a:	9a 10 00 
	_kernel.nested = 0;
  106e4d:	c7 05 60 9a 10 00 00 	movl   $0x0,0x109a60
  106e54:	00 00 00 
	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  106e57:	c7 05 64 9a 10 00 a0 	movl   $0x10c3a0,0x109a64
  106e5e:	c3 10 00 
	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  106e61:	c7 05 8c 9b 10 00 00 	movl   $0x800,0x109b8c
  106e68:	08 00 00 
	_dummy_exception_vector_stub = &_exception_enter;
  106e6b:	c7 05 84 9b 10 00 97 	movl   $0x106797,0x109b84
  106e72:	67 10 00 
  106e75:	e8 75 fc ff ff       	call   106aef <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  106e7a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106e81:	e8 69 fc ff ff       	call   106aef <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  106e86:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106e8d:	e8 5d fc ff ff       	call   106aef <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
  106e92:	c7 04 24 08 84 10 00 	movl   $0x108408,(%esp)
  106e99:	68 24 84 10 00       	push   $0x108424
  106e9e:	e8 15 ab ff ff       	call   1019b8 <printk>
  106ea3:	58                   	pop    %eax
  106ea4:	5a                   	pop    %edx
	__asm__ volatile (
  106ea5:	9c                   	pushf  
  106ea6:	fa                   	cli    
  106ea7:	58                   	pop    %eax
	_Swap(irq_lock());
  106ea8:	50                   	push   %eax
  106ea9:	e8 86 f9 ff ff       	call   106834 <_Swap>
  106eae:	59                   	pop    %ecx

00106eaf <k_lifo_put>:

	SYS_TRACING_OBJ_INIT(k_lifo, lifo);
}

void k_lifo_put(struct k_lifo *lifo, void *data)
{
  106eaf:	55                   	push   %ebp
  106eb0:	89 e5                	mov    %esp,%ebp
  106eb2:	57                   	push   %edi
  106eb3:	56                   	push   %esi
  106eb4:	53                   	push   %ebx
  106eb5:	8b 45 08             	mov    0x8(%ebp),%eax
  106eb8:	8b 7d 0c             	mov    0xc(%ebp),%edi
  106ebb:	9c                   	pushf  
  106ebc:	fa                   	cli    
  106ebd:	5e                   	pop    %esi
	if (_handling_timeouts) {
  106ebe:	8b 15 90 9b 10 00    	mov    0x109b90,%edx
  106ec4:	8b 18                	mov    (%eax),%ebx
  106ec6:	85 d2                	test   %edx,%edx
  106ec8:	74 22                	je     106eec <k_lifo_put+0x3d>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  106eca:	39 d8                	cmp    %ebx,%eax
  106ecc:	75 15                	jne    106ee3 <k_lifo_put+0x34>
  106ece:	31 db                	xor    %ebx,%ebx
  106ed0:	eb 11                	jmp    106ee3 <k_lifo_put+0x34>
			if (_is_thread_timeout_expired(thread)) {
  106ed2:	83 7b 20 fe          	cmpl   $0xfffffffe,0x20(%ebx)
  106ed6:	75 24                	jne    106efc <k_lifo_put+0x4d>
	return (node == list->tail) ? NULL : node->next;
  106ed8:	3b 58 04             	cmp    0x4(%eax),%ebx
  106edb:	0f 84 a1 00 00 00    	je     106f82 <k_lifo_put+0xd3>
  106ee1:	8b 1b                	mov    (%ebx),%ebx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  106ee3:	85 db                	test   %ebx,%ebx
  106ee5:	75 eb                	jne    106ed2 <k_lifo_put+0x23>
  106ee7:	e9 96 00 00 00       	jmp    106f82 <k_lifo_put+0xd3>
	if (thread) {
  106eec:	85 db                	test   %ebx,%ebx
  106eee:	0f 84 8e 00 00 00    	je     106f82 <k_lifo_put+0xd3>
  106ef4:	39 d8                	cmp    %ebx,%eax
  106ef6:	0f 84 86 00 00 00    	je     106f82 <k_lifo_put+0xd3>
	node->prev->next = node->next;
  106efc:	8b 43 04             	mov    0x4(%ebx),%eax
  106eff:	8b 13                	mov    (%ebx),%edx
  106f01:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  106f03:	8b 13                	mov    (%ebx),%edx
  106f05:	89 42 04             	mov    %eax,0x4(%edx)
  106f08:	8d 43 10             	lea    0x10(%ebx),%eax
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  106f0b:	8b 53 20             	mov    0x20(%ebx),%edx
	thread->base.thread_state &= ~_THREAD_PENDING;
  106f0e:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
  106f12:	83 fa ff             	cmp    $0xffffffff,%edx
  106f15:	74 23                	je     106f3a <k_lifo_put+0x8b>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  106f17:	3b 05 70 9a 10 00    	cmp    0x109a70,%eax
  106f1d:	74 06                	je     106f25 <k_lifo_put+0x76>
	return (node == list->tail) ? NULL : node->next;
  106f1f:	8b 43 10             	mov    0x10(%ebx),%eax
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  106f22:	01 50 10             	add    %edx,0x10(%eax)
	node->prev->next = node->next;
  106f25:	8b 43 14             	mov    0x14(%ebx),%eax
  106f28:	8b 53 10             	mov    0x10(%ebx),%edx
  106f2b:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  106f2d:	8b 53 10             	mov    0x10(%ebx),%edx
  106f30:	89 42 04             	mov    %eax,0x4(%edx)
	timeout->delta_ticks_from_prev = _INACTIVE;
  106f33:	c7 43 20 ff ff ff ff 	movl   $0xffffffff,0x20(%ebx)
	thread->base.thread_state &= ~_THREAD_PRESTART;
  106f3a:	8a 43 09             	mov    0x9(%ebx),%al
  106f3d:	88 c2                	mov    %al,%dl
  106f3f:	83 e2 fb             	and    $0xfffffffb,%edx
	return !(_is_thread_prevented_from_running(thread) ||
  106f42:	a8 1b                	test   $0x1b,%al
	thread->base.thread_state &= ~_THREAD_PRESTART;
  106f44:	88 53 09             	mov    %dl,0x9(%ebx)
	return !(_is_thread_prevented_from_running(thread) ||
  106f47:	75 06                	jne    106f4f <k_lifo_put+0xa0>
  106f49:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  106f4d:	74 3d                	je     106f8c <k_lifo_put+0xdd>
	*(unsigned int *)(thread->callee_saved.esp) = value;
  106f4f:	8b 43 28             	mov    0x28(%ebx),%eax
  106f52:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  106f58:	89 7b 0c             	mov    %edi,0xc(%ebx)
		_ready_thread(first_pending_thread);

		_set_thread_return_value_with_data(first_pending_thread,
						   0, data);

		if (!_is_in_isr() && _must_switch_threads()) {
  106f5b:	83 3d 60 9a 10 00 00 	cmpl   $0x0,0x109a60
  106f62:	75 15                	jne    106f79 <k_lifo_put+0xca>
	return _is_preempt(_current) && __must_switch_threads();
  106f64:	a1 68 9a 10 00       	mov    0x109a68,%eax
  106f69:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  106f6e:	77 09                	ja     106f79 <k_lifo_put+0xca>
  106f70:	e8 73 02 00 00       	call   1071e8 <__must_switch_threads>
  106f75:	85 c0                	test   %eax,%eax
  106f77:	75 1c                	jne    106f95 <k_lifo_put+0xe6>
  106f79:	0f ba e6 09          	bt     $0x9,%esi
  106f7d:	73 25                	jae    106fa4 <k_lifo_put+0xf5>
	__asm__ volatile (
  106f7f:	fb                   	sti    
  106f80:	eb 22                	jmp    106fa4 <k_lifo_put+0xf5>
			(void)_Swap(key);
			return;
		}
	} else {
		*(void **)data = lifo->list;
  106f82:	8b 50 08             	mov    0x8(%eax),%edx
  106f85:	89 17                	mov    %edx,(%edi)
		lifo->list = data;
  106f87:	89 78 08             	mov    %edi,0x8(%eax)
  106f8a:	eb ed                	jmp    106f79 <k_lifo_put+0xca>
		_add_thread_to_ready_q(thread);
  106f8c:	53                   	push   %ebx
  106f8d:	e8 f2 00 00 00       	call   107084 <_add_thread_to_ready_q>
  106f92:	58                   	pop    %eax
  106f93:	eb ba                	jmp    106f4f <k_lifo_put+0xa0>
			(void)_Swap(key);
  106f95:	89 75 08             	mov    %esi,0x8(%ebp)
	}

	irq_unlock(key);
}
  106f98:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106f9b:	5b                   	pop    %ebx
  106f9c:	5e                   	pop    %esi
  106f9d:	5f                   	pop    %edi
  106f9e:	5d                   	pop    %ebp
			(void)_Swap(key);
  106f9f:	e9 90 f8 ff ff       	jmp    106834 <_Swap>
}
  106fa4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106fa7:	5b                   	pop    %ebx
  106fa8:	5e                   	pop    %esi
  106fa9:	5f                   	pop    %edi
  106faa:	5d                   	pop    %ebp
  106fab:	c3                   	ret    

00106fac <k_lifo_get>:

void *k_lifo_get(struct k_lifo *lifo, int32_t timeout)
{
  106fac:	55                   	push   %ebp
  106fad:	89 e5                	mov    %esp,%ebp
  106faf:	56                   	push   %esi
  106fb0:	53                   	push   %ebx
  106fb1:	8b 45 08             	mov    0x8(%ebp),%eax
  106fb4:	8b 55 0c             	mov    0xc(%ebp),%edx
	__asm__ volatile (
  106fb7:	9c                   	pushf  
  106fb8:	fa                   	cli    
  106fb9:	5e                   	pop    %esi
	unsigned int key;
	void *data;

	key = irq_lock();

	if (likely(lifo->list)) {
  106fba:	8b 58 08             	mov    0x8(%eax),%ebx
  106fbd:	85 db                	test   %ebx,%ebx
  106fbf:	74 07                	je     106fc8 <k_lifo_get+0x1c>
		data = lifo->list;
		lifo->list = *(void **)data;
  106fc1:	8b 13                	mov    (%ebx),%edx
  106fc3:	89 50 08             	mov    %edx,0x8(%eax)
  106fc6:	eb 04                	jmp    106fcc <k_lifo_get+0x20>
		irq_unlock(key);
		return data;
	}

	if (timeout == K_NO_WAIT) {
  106fc8:	85 d2                	test   %edx,%edx
  106fca:	75 09                	jne    106fd5 <k_lifo_get+0x29>
  106fcc:	0f ba e6 09          	bt     $0x9,%esi
  106fd0:	73 1f                	jae    106ff1 <k_lifo_get+0x45>
	__asm__ volatile (
  106fd2:	fb                   	sti    
  106fd3:	eb 1c                	jmp    106ff1 <k_lifo_get+0x45>
		irq_unlock(key);
		return NULL;
	}

	_pend_current_thread(&lifo->wait_q, timeout);
  106fd5:	52                   	push   %edx
  106fd6:	50                   	push   %eax
  106fd7:	e8 e7 01 00 00       	call   1071c3 <_pend_current_thread>
  106fdc:	58                   	pop    %eax
  106fdd:	5a                   	pop    %edx

	return _Swap(key) ? NULL : _current->base.swap_data;
  106fde:	56                   	push   %esi
  106fdf:	e8 50 f8 ff ff       	call   106834 <_Swap>
  106fe4:	59                   	pop    %ecx
  106fe5:	85 c0                	test   %eax,%eax
  106fe7:	75 08                	jne    106ff1 <k_lifo_get+0x45>
  106fe9:	a1 68 9a 10 00       	mov    0x109a68,%eax
  106fee:	8b 58 0c             	mov    0xc(%eax),%ebx
}
  106ff1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106ff4:	89 d8                	mov    %ebx,%eax
  106ff6:	5b                   	pop    %ebx
  106ff7:	5e                   	pop    %esi
  106ff8:	5d                   	pop    %ebp
  106ff9:	c3                   	ret    

00106ffa <_get_highest_ready_prio>:
{
  106ffa:	55                   	push   %ebp
  106ffb:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  106ffd:	0f bc 05 78 9a 10 00 	bsf    0x109a78,%eax
  107004:	75 05                	jne    10700b <_get_highest_ready_prio+0x11>
  107006:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
  10700b:	83 e8 10             	sub    $0x10,%eax
}
  10700e:	5d                   	pop    %ebp
  10700f:	c3                   	ret    

00107010 <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
  107010:	55                   	push   %ebp
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
  107011:	89 42 08             	mov    %eax,0x8(%edx)
{
  107014:	89 e5                	mov    %esp,%ebp
	timeout->wait_q = (sys_dlist_t *)wait_q;
  107016:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
  107019:	53                   	push   %ebx
	return list->head == list;
  10701a:	a1 6c 9a 10 00       	mov    0x109a6c,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
  10701f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  107022:	85 c0                	test   %eax,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
  107024:	89 5a 10             	mov    %ebx,0x10(%edx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  107027:	74 07                	je     107030 <_add_timeout+0x20>
  107029:	3d 6c 9a 10 00       	cmp    $0x109a6c,%eax
  10702e:	75 1d                	jne    10704d <_add_timeout+0x3d>
	node->next = list;
  107030:	c7 02 6c 9a 10 00    	movl   $0x109a6c,(%edx)
	node->prev = list->tail;
  107036:	a1 70 9a 10 00       	mov    0x109a70,%eax
  10703b:	89 42 04             	mov    %eax,0x4(%edx)
	list->tail->next = node;
  10703e:	a1 70 9a 10 00       	mov    0x109a70,%eax
  107043:	89 10                	mov    %edx,(%eax)
	list->tail = node;
  107045:	89 15 70 9a 10 00    	mov    %edx,0x109a70
  10704b:	eb 34                	jmp    107081 <_add_timeout+0x71>
		if (*delta <= in_q->delta_ticks_from_prev) {
  10704d:	8b 4a 10             	mov    0x10(%edx),%ecx
  107050:	8b 58 10             	mov    0x10(%eax),%ebx
  107053:	39 d9                	cmp    %ebx,%ecx
  107055:	7f 17                	jg     10706e <_add_timeout+0x5e>
			in_q->delta_ticks_from_prev -= *delta;
  107057:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
  107059:	8b 48 04             	mov    0x4(%eax),%ecx
  10705c:	89 58 10             	mov    %ebx,0x10(%eax)
  10705f:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
  107062:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
  107064:	8b 48 04             	mov    0x4(%eax),%ecx
  107067:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
  107069:	89 50 04             	mov    %edx,0x4(%eax)
  10706c:	eb 13                	jmp    107081 <_add_timeout+0x71>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  10706e:	29 d9                	sub    %ebx,%ecx
  107070:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
  107073:	3b 05 70 9a 10 00    	cmp    0x109a70,%eax
  107079:	74 b5                	je     107030 <_add_timeout+0x20>
  10707b:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  10707d:	85 c0                	test   %eax,%eax
  10707f:	eb ad                	jmp    10702e <_add_timeout+0x1e>

inserted:
	K_DEBUG("after adding timeout %p\n", timeout);
	_dump_timeout(timeout, 0);
	_dump_timeout_q();
}
  107081:	5b                   	pop    %ebx
  107082:	5d                   	pop    %ebp
  107083:	c3                   	ret    

00107084 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  107084:	55                   	push   %ebp
  107085:	89 e5                	mov    %esp,%ebp
  107087:	56                   	push   %esi
  107088:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  107089:	bb 01 00 00 00       	mov    $0x1,%ebx
  10708e:	8b 45 08             	mov    0x8(%ebp),%eax
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  107091:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
  107095:	8d 4a 10             	lea    0x10(%edx),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];
  107098:	83 c2 12             	add    $0x12,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
  10709b:	89 ce                	mov    %ecx,%esi
  10709d:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  1070a0:	d3 e3                	shl    %cl,%ebx
  1070a2:	8d 0c d5 6c 9a 10 00 	lea    0x109a6c(,%edx,8),%ecx
	*bmap |= _get_ready_q_prio_bit(prio);
  1070a9:	09 1c b5 78 9a 10 00 	or     %ebx,0x109a78(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
  1070b0:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
  1070b2:	8b 0c d5 70 9a 10 00 	mov    0x109a70(,%edx,8),%ecx
  1070b9:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
  1070bc:	8b 0c d5 70 9a 10 00 	mov    0x109a70(,%edx,8),%ecx
  1070c3:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  1070c5:	89 04 d5 70 9a 10 00 	mov    %eax,0x109a70(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  1070cc:	8b 15 74 9a 10 00    	mov    0x109a74,%edx
  1070d2:	8a 5a 0a             	mov    0xa(%edx),%bl
  1070d5:	38 58 0a             	cmp    %bl,0xa(%eax)
  1070d8:	7c 02                	jl     1070dc <_add_thread_to_ready_q+0x58>
  1070da:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
  1070dc:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  1070dd:	a3 74 9a 10 00       	mov    %eax,0x109a74
}
  1070e2:	5e                   	pop    %esi
  1070e3:	5d                   	pop    %ebp
  1070e4:	c3                   	ret    

001070e5 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  1070e5:	55                   	push   %ebp
  1070e6:	89 e5                	mov    %esp,%ebp
  1070e8:	53                   	push   %ebx
  1070e9:	8b 45 08             	mov    0x8(%ebp),%eax
	node->prev->next = node->next;
  1070ec:	8b 48 04             	mov    0x4(%eax),%ecx
  1070ef:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  1070f1:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  1070f5:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  1070f7:	8b 18                	mov    (%eax),%ebx
  1070f9:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
  1070fc:	8d 0c d5 fc 9a 10 00 	lea    0x109afc(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  107103:	3b 0c d5 fc 9a 10 00 	cmp    0x109afc(,%edx,8),%ecx
  10710a:	75 1c                	jne    107128 <_remove_thread_from_ready_q+0x43>
		_clear_ready_q_prio_bit(thread->base.prio);
  10710c:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
  107110:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  107113:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
  107118:	89 cb                	mov    %ecx,%ebx
  10711a:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  10711d:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
  10711f:	f7 d2                	not    %edx
  107121:	21 14 9d 78 9a 10 00 	and    %edx,0x109a78(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  107128:	8b 15 74 9a 10 00    	mov    0x109a74,%edx
  10712e:	39 d0                	cmp    %edx,%eax
  107130:	75 0c                	jne    10713e <_remove_thread_from_ready_q+0x59>
	int prio = _get_highest_ready_prio();
  107132:	e8 c3 fe ff ff       	call   106ffa <_get_highest_ready_prio>
  107137:	8b 14 c5 fc 9a 10 00 	mov    0x109afc(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
  10713e:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  10713f:	89 15 74 9a 10 00    	mov    %edx,0x109a74
}
  107145:	5d                   	pop    %ebp
  107146:	c3                   	ret    

00107147 <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  107147:	55                   	push   %ebp
  107148:	89 e5                	mov    %esp,%ebp
  10714a:	57                   	push   %edi
  10714b:	56                   	push   %esi
  10714c:	53                   	push   %ebx
  10714d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  107150:	8b 5d 08             	mov    0x8(%ebp),%ebx
  107153:	8b 45 10             	mov    0x10(%ebp),%eax
	return list->head == list;
  107156:	8b 31                	mov    (%ecx),%esi
	return sys_dlist_is_empty(list) ? NULL : list->head;
  107158:	39 f1                	cmp    %esi,%ecx
  10715a:	75 0b                	jne    107167 <_pend_thread+0x20>
  10715c:	31 f6                	xor    %esi,%esi
  10715e:	eb 07                	jmp    107167 <_pend_thread+0x20>
	return (node == list->tail) ? NULL : node->next;
  107160:	3b 71 04             	cmp    0x4(%ecx),%esi
  107163:	74 20                	je     107185 <_pend_thread+0x3e>
  107165:	8b 36                	mov    (%esi),%esi
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
  107167:	85 f6                	test   %esi,%esi
  107169:	74 1a                	je     107185 <_pend_thread+0x3e>
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
  10716b:	8a 56 0a             	mov    0xa(%esi),%dl
  10716e:	38 53 0a             	cmp    %dl,0xa(%ebx)
  107171:	7d ed                	jge    107160 <_pend_thread+0x19>
		node->prev = insert_point->prev;
  107173:	8b 56 04             	mov    0x4(%esi),%edx
		node->next = insert_point;
  107176:	89 33                	mov    %esi,(%ebx)
		node->prev = insert_point->prev;
  107178:	89 53 04             	mov    %edx,0x4(%ebx)
		insert_point->prev->next = node;
  10717b:	8b 56 04             	mov    0x4(%esi),%edx
  10717e:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
  107180:	89 5e 04             	mov    %ebx,0x4(%esi)
  107183:	eb 10                	jmp    107195 <_pend_thread+0x4e>
	node->next = list;
  107185:	89 0b                	mov    %ecx,(%ebx)
	node->prev = list->tail;
  107187:	8b 51 04             	mov    0x4(%ecx),%edx
  10718a:	89 53 04             	mov    %edx,0x4(%ebx)
	list->tail->next = node;
  10718d:	8b 51 04             	mov    0x4(%ecx),%edx
  107190:	89 1a                	mov    %ebx,(%edx)
	list->tail = node;
  107192:	89 59 04             	mov    %ebx,0x4(%ecx)
	thread->base.thread_state |= _THREAD_PENDING;
  107195:	80 4b 09 02          	orb    $0x2,0x9(%ebx)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
  107199:	83 f8 ff             	cmp    $0xffffffff,%eax
  10719c:	74 20                	je     1071be <_pend_thread+0x77>
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  10719e:	bf 0a 00 00 00       	mov    $0xa,%edi
  1071a3:	83 c0 09             	add    $0x9,%eax
  1071a6:	31 d2                	xor    %edx,%edx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  1071a8:	8d 73 10             	lea    0x10(%ebx),%esi
  1071ab:	f7 f7                	div    %edi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
  1071ad:	40                   	inc    %eax
  1071ae:	89 f2                	mov    %esi,%edx
  1071b0:	89 45 08             	mov    %eax,0x8(%ebp)
  1071b3:	89 d8                	mov    %ebx,%eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
  1071b5:	5b                   	pop    %ebx
  1071b6:	5e                   	pop    %esi
  1071b7:	5f                   	pop    %edi
  1071b8:	5d                   	pop    %ebp
  1071b9:	e9 52 fe ff ff       	jmp    107010 <_add_timeout>
  1071be:	5b                   	pop    %ebx
  1071bf:	5e                   	pop    %esi
  1071c0:	5f                   	pop    %edi
  1071c1:	5d                   	pop    %ebp
  1071c2:	c3                   	ret    

001071c3 <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
  1071c3:	55                   	push   %ebp
  1071c4:	89 e5                	mov    %esp,%ebp
	_remove_thread_from_ready_q(_current);
  1071c6:	ff 35 68 9a 10 00    	pushl  0x109a68
  1071cc:	e8 14 ff ff ff       	call   1070e5 <_remove_thread_from_ready_q>
  1071d1:	58                   	pop    %eax
	_pend_thread(_current, wait_q, timeout);
  1071d2:	ff 75 0c             	pushl  0xc(%ebp)
  1071d5:	ff 75 08             	pushl  0x8(%ebp)
  1071d8:	ff 35 68 9a 10 00    	pushl  0x109a68
  1071de:	e8 64 ff ff ff       	call   107147 <_pend_thread>
  1071e3:	83 c4 0c             	add    $0xc,%esp
}
  1071e6:	c9                   	leave  
  1071e7:	c3                   	ret    

001071e8 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
  1071e8:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  1071e9:	a1 68 9a 10 00       	mov    0x109a68,%eax
{
  1071ee:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  1071f0:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  1071f4:	e8 01 fe ff ff       	call   106ffa <_get_highest_ready_prio>
#else
	return 0;
#endif
}
  1071f9:	5d                   	pop    %ebp
	return prio1 < prio2;
  1071fa:	39 c2                	cmp    %eax,%edx
  1071fc:	0f 9f c0             	setg   %al
  1071ff:	0f b6 c0             	movzbl %al,%eax
  107202:	c3                   	ret    

00107203 <_reschedule_threads>:
{
  107203:	55                   	push   %ebp
	return _is_preempt(_current) && __must_switch_threads();
  107204:	a1 68 9a 10 00       	mov    0x109a68,%eax
  107209:	89 e5                	mov    %esp,%ebp
  10720b:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  107210:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107213:	77 09                	ja     10721e <_reschedule_threads+0x1b>
  107215:	e8 ce ff ff ff       	call   1071e8 <__must_switch_threads>
  10721a:	85 c0                	test   %eax,%eax
  10721c:	75 09                	jne    107227 <_reschedule_threads+0x24>
  10721e:	0f ba e1 09          	bt     $0x9,%ecx
  107222:	73 0c                	jae    107230 <_reschedule_threads+0x2d>
	__asm__ volatile (
  107224:	fb                   	sti    
}
  107225:	eb 09                	jmp    107230 <_reschedule_threads+0x2d>
		_Swap(key);
  107227:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
  10722a:	5d                   	pop    %ebp
		_Swap(key);
  10722b:	e9 04 f6 ff ff       	jmp    106834 <_Swap>
}
  107230:	5d                   	pop    %ebp
  107231:	c3                   	ret    

00107232 <k_sched_unlock>:
{
  107232:	55                   	push   %ebp
  107233:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  107235:	9c                   	pushf  
  107236:	fa                   	cli    
  107237:	5a                   	pop    %edx
	++_current->base.sched_locked;
  107238:	a1 68 9a 10 00       	mov    0x109a68,%eax
  10723d:	fe 40 0b             	incb   0xb(%eax)
	_reschedule_threads(key);
  107240:	52                   	push   %edx
  107241:	e8 bd ff ff ff       	call   107203 <_reschedule_threads>
  107246:	58                   	pop    %eax
}
  107247:	c9                   	leave  
  107248:	c3                   	ret    

00107249 <_move_thread_to_end_of_prio_q>:
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  107249:	55                   	push   %ebp
  10724a:	89 e5                	mov    %esp,%ebp
  10724c:	56                   	push   %esi
  10724d:	53                   	push   %ebx
  10724e:	8b 45 08             	mov    0x8(%ebp),%eax
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  107251:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
  107255:	83 c2 12             	add    $0x12,%edx
  107258:	8d 0c d5 6c 9a 10 00 	lea    0x109a6c(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  10725f:	3b 41 04             	cmp    0x4(%ecx),%eax
  107262:	74 44                	je     1072a8 <_move_thread_to_end_of_prio_q+0x5f>
	node->prev->next = node->next;
  107264:	8b 58 04             	mov    0x4(%eax),%ebx
  107267:	8b 30                	mov    (%eax),%esi
  107269:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
  10726b:	8b 30                	mov    (%eax),%esi
  10726d:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
  107270:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
  107272:	8b 0c d5 70 9a 10 00 	mov    0x109a70(,%edx,8),%ecx
  107279:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
  10727c:	8b 0c d5 70 9a 10 00 	mov    0x109a70(,%edx,8),%ecx
  107283:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  107285:	89 04 d5 70 9a 10 00 	mov    %eax,0x109a70(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  10728c:	8b 15 74 9a 10 00    	mov    0x109a74,%edx
  107292:	39 d0                	cmp    %edx,%eax
  107294:	75 0c                	jne    1072a2 <_move_thread_to_end_of_prio_q+0x59>
	int prio = _get_highest_ready_prio();
  107296:	e8 5f fd ff ff       	call   106ffa <_get_highest_ready_prio>
  10729b:	8b 14 c5 fc 9a 10 00 	mov    0x109afc(,%eax,8),%edx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  1072a2:	89 15 74 9a 10 00    	mov    %edx,0x109a74
#endif
}
  1072a8:	5b                   	pop    %ebx
  1072a9:	5e                   	pop    %esi
  1072aa:	5d                   	pop    %ebp
  1072ab:	c3                   	ret    

001072ac <k_yield>:

void k_yield(void)
{
  1072ac:	55                   	push   %ebp
  1072ad:	89 e5                	mov    %esp,%ebp
  1072af:	53                   	push   %ebx
  1072b0:	9c                   	pushf  
  1072b1:	fa                   	cli    
  1072b2:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	int key = irq_lock();

	_move_thread_to_end_of_prio_q(_current);
  1072b3:	ff 35 68 9a 10 00    	pushl  0x109a68
  1072b9:	e8 8b ff ff ff       	call   107249 <_move_thread_to_end_of_prio_q>

	if (_current == _get_next_ready_thread()) {
  1072be:	a1 74 9a 10 00       	mov    0x109a74,%eax
	_move_thread_to_end_of_prio_q(_current);
  1072c3:	5a                   	pop    %edx
	if (_current == _get_next_ready_thread()) {
  1072c4:	39 05 68 9a 10 00    	cmp    %eax,0x109a68
  1072ca:	75 09                	jne    1072d5 <k_yield+0x29>
  1072cc:	0f ba e3 09          	bt     $0x9,%ebx
  1072d0:	73 0a                	jae    1072dc <k_yield+0x30>
	__asm__ volatile (
  1072d2:	fb                   	sti    
  1072d3:	eb 07                	jmp    1072dc <k_yield+0x30>
		irq_unlock(key);
	} else {
		_Swap(key);
  1072d5:	53                   	push   %ebx
  1072d6:	e8 59 f5 ff ff       	call   106834 <_Swap>
  1072db:	58                   	pop    %eax
	}
}
  1072dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1072df:	c9                   	leave  
  1072e0:	c3                   	ret    

001072e1 <k_sleep>:

void k_sleep(int32_t duration)
{
  1072e1:	55                   	push   %ebp
  1072e2:	89 e5                	mov    %esp,%ebp
  1072e4:	53                   	push   %ebx
  1072e5:	52                   	push   %edx
  1072e6:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  1072e9:	85 c0                	test   %eax,%eax
  1072eb:	75 07                	jne    1072f4 <k_sleep+0x13>
		k_yield();
  1072ed:	e8 ba ff ff ff       	call   1072ac <k_yield>
		return;
  1072f2:	eb 3c                	jmp    107330 <k_sleep+0x4f>
  1072f4:	83 c0 09             	add    $0x9,%eax
  1072f7:	b9 0a 00 00 00       	mov    $0xa,%ecx
  1072fc:	31 d2                	xor    %edx,%edx
  1072fe:	f7 f1                	div    %ecx
	}

	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  107300:	40                   	inc    %eax
  107301:	89 45 f8             	mov    %eax,-0x8(%ebp)
	__asm__ volatile (
  107304:	9c                   	pushf  
  107305:	fa                   	cli    
  107306:	5b                   	pop    %ebx
	key = irq_lock();

	_remove_thread_from_ready_q(_current);
  107307:	ff 35 68 9a 10 00    	pushl  0x109a68
  10730d:	e8 d3 fd ff ff       	call   1070e5 <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
  107312:	a1 68 9a 10 00       	mov    0x109a68,%eax
  107317:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10731a:	8d 50 10             	lea    0x10(%eax),%edx
  10731d:	89 0c 24             	mov    %ecx,(%esp)
  107320:	31 c9                	xor    %ecx,%ecx
  107322:	e8 e9 fc ff ff       	call   107010 <_add_timeout>

	_Swap(key);
  107327:	89 1c 24             	mov    %ebx,(%esp)
  10732a:	e8 05 f5 ff ff       	call   106834 <_Swap>
  10732f:	58                   	pop    %eax
#endif
}
  107330:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107333:	c9                   	leave  
  107334:	c3                   	ret    

00107335 <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
  107335:	55                   	push   %ebp
	return _current;
}
  107336:	a1 68 9a 10 00       	mov    0x109a68,%eax
{
  10733b:	89 e5                	mov    %esp,%ebp
}
  10733d:	5d                   	pop    %ebp
  10733e:	c3                   	ret    

0010733f <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
  10733f:	8a 50 09             	mov    0x9(%eax),%dl
  107342:	88 d1                	mov    %dl,%cl
  107344:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
  107347:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
  10734a:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
  10734d:	75 11                	jne    107360 <_ready_thread+0x21>
  10734f:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  107353:	75 0b                	jne    107360 <_ready_thread+0x21>
{
  107355:	55                   	push   %ebp
  107356:	89 e5                	mov    %esp,%ebp
		_add_thread_to_ready_q(thread);
  107358:	50                   	push   %eax
  107359:	e8 26 fd ff ff       	call   107084 <_add_thread_to_ready_q>
  10735e:	58                   	pop    %eax
}
  10735f:	c9                   	leave  
  107360:	c3                   	ret    

00107361 <_unpend_first_thread>:
{
  107361:	55                   	push   %ebp
	if (_handling_timeouts) {
  107362:	8b 15 90 9b 10 00    	mov    0x109b90,%edx
{
  107368:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
  10736a:	85 d2                	test   %edx,%edx
  10736c:	8b 08                	mov    (%eax),%ecx
  10736e:	74 1f                	je     10738f <_unpend_first_thread+0x2e>
	return list->head == list;
  107370:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
  107372:	39 c8                	cmp    %ecx,%eax
  107374:	75 11                	jne    107387 <_unpend_first_thread+0x26>
  107376:	31 d2                	xor    %edx,%edx
  107378:	eb 0d                	jmp    107387 <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
  10737a:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
  10737e:	75 1b                	jne    10739b <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
  107380:	3b 50 04             	cmp    0x4(%eax),%edx
  107383:	74 06                	je     10738b <_unpend_first_thread+0x2a>
  107385:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  107387:	85 d2                	test   %edx,%edx
  107389:	75 ef                	jne    10737a <_unpend_first_thread+0x19>
  10738b:	31 d2                	xor    %edx,%edx
  10738d:	eb 1c                	jmp    1073ab <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  10738f:	31 d2                	xor    %edx,%edx
  107391:	39 c8                	cmp    %ecx,%eax
  107393:	74 16                	je     1073ab <_unpend_first_thread+0x4a>
	if (thread) {
  107395:	85 c9                	test   %ecx,%ecx
  107397:	74 12                	je     1073ab <_unpend_first_thread+0x4a>
  107399:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
  10739b:	8b 42 04             	mov    0x4(%edx),%eax
  10739e:	8b 0a                	mov    (%edx),%ecx
  1073a0:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  1073a2:	8b 0a                	mov    (%edx),%ecx
  1073a4:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
  1073a7:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
  1073ab:	89 d0                	mov    %edx,%eax
  1073ad:	5d                   	pop    %ebp
  1073ae:	c3                   	ret    

001073af <_abort_timeout>:
{
  1073af:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1073b0:	8b 48 10             	mov    0x10(%eax),%ecx
{
  1073b3:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1073b5:	83 f9 ff             	cmp    $0xffffffff,%ecx
  1073b8:	74 24                	je     1073de <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  1073ba:	3b 05 70 9a 10 00    	cmp    0x109a70,%eax
  1073c0:	74 05                	je     1073c7 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
  1073c2:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  1073c4:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
  1073c7:	8b 50 04             	mov    0x4(%eax),%edx
  1073ca:	8b 08                	mov    (%eax),%ecx
  1073cc:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1073ce:	8b 08                	mov    (%eax),%ecx
  1073d0:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
  1073d3:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
  1073da:	31 c0                	xor    %eax,%eax
  1073dc:	eb 03                	jmp    1073e1 <_abort_timeout+0x32>
		return _INACTIVE;
  1073de:	83 c8 ff             	or     $0xffffffff,%eax
}
  1073e1:	5d                   	pop    %ebp
  1073e2:	c3                   	ret    

001073e3 <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
  1073e3:	55                   	push   %ebp
  1073e4:	89 e5                	mov    %esp,%ebp
  1073e6:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
  1073e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1073ec:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
  1073ef:	8b 55 10             	mov    0x10(%ebp),%edx
  1073f2:	89 50 0c             	mov    %edx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
  1073f5:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  1073f7:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
  1073fa:	5d                   	pop    %ebp
  1073fb:	c3                   	ret    

001073fc <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
  1073fc:	55                   	push   %ebp
  1073fd:	89 e5                	mov    %esp,%ebp
  1073ff:	57                   	push   %edi
  107400:	56                   	push   %esi
  107401:	53                   	push   %ebx
  107402:	8b 75 08             	mov    0x8(%ebp),%esi
  107405:	9c                   	pushf  
  107406:	fa                   	cli    
  107407:	5f                   	pop    %edi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
  107408:	89 f0                	mov    %esi,%eax
  10740a:	e8 52 ff ff ff       	call   107361 <_unpend_first_thread>
	if (!thread) {
  10740f:	85 c0                	test   %eax,%eax
  107411:	75 12                	jne    107425 <k_sem_give+0x29>
	sem->count += (sem->count != sem->limit);
  107413:	8b 56 08             	mov    0x8(%esi),%edx
  107416:	31 c0                	xor    %eax,%eax
  107418:	39 56 0c             	cmp    %edx,0xc(%esi)
  10741b:	0f 95 c0             	setne  %al
  10741e:	01 d0                	add    %edx,%eax
  107420:	89 46 08             	mov    %eax,0x8(%esi)
  107423:	eb 44                	jmp    107469 <k_sem_give+0x6d>
  107425:	89 c3                	mov    %eax,%ebx
	return _abort_timeout(&thread->base.timeout);
  107427:	8d 40 10             	lea    0x10(%eax),%eax
  10742a:	e8 80 ff ff ff       	call   1073af <_abort_timeout>
	_ready_thread(thread);
  10742f:	89 d8                	mov    %ebx,%eax
  107431:	e8 09 ff ff ff       	call   10733f <_ready_thread>
  107436:	8b 43 28             	mov    0x28(%ebx),%eax
  107439:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
  10743f:	83 3d 60 9a 10 00 00 	cmpl   $0x0,0x109a60
  107446:	75 21                	jne    107469 <k_sem_give+0x6d>
	return _is_preempt(_current) && __must_switch_threads();
  107448:	a1 68 9a 10 00       	mov    0x109a68,%eax
  10744d:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  107452:	77 15                	ja     107469 <k_sem_give+0x6d>
  107454:	e8 8f fd ff ff       	call   1071e8 <__must_switch_threads>
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
  107459:	85 c0                	test   %eax,%eax
  10745b:	74 0c                	je     107469 <k_sem_give+0x6d>
		_Swap(key);
	} else {
		irq_unlock(key);
	}
}
  10745d:	5b                   	pop    %ebx
		_Swap(key);
  10745e:	89 7d 08             	mov    %edi,0x8(%ebp)
}
  107461:	5e                   	pop    %esi
  107462:	5f                   	pop    %edi
  107463:	5d                   	pop    %ebp
		_Swap(key);
  107464:	e9 cb f3 ff ff       	jmp    106834 <_Swap>
  107469:	0f ba e7 09          	bt     $0x9,%edi
  10746d:	73 01                	jae    107470 <k_sem_give+0x74>
	__asm__ volatile (
  10746f:	fb                   	sti    
}
  107470:	5b                   	pop    %ebx
  107471:	5e                   	pop    %esi
  107472:	5f                   	pop    %edi
  107473:	5d                   	pop    %ebp
  107474:	c3                   	ret    

00107475 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
  107475:	55                   	push   %ebp
  107476:	89 e5                	mov    %esp,%ebp
  107478:	53                   	push   %ebx
  107479:	8b 55 08             	mov    0x8(%ebp),%edx
  10747c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	__asm__ volatile (
  10747f:	9c                   	pushf  
  107480:	fa                   	cli    
  107481:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
  107482:	8b 42 08             	mov    0x8(%edx),%eax
  107485:	85 c0                	test   %eax,%eax
  107487:	74 08                	je     107491 <k_sem_take+0x1c>
		sem->count--;
  107489:	48                   	dec    %eax
  10748a:	89 42 08             	mov    %eax,0x8(%edx)
		irq_unlock(key);
		return 0;
  10748d:	31 c0                	xor    %eax,%eax
  10748f:	eb 09                	jmp    10749a <k_sem_take+0x25>
	}

	if (timeout == K_NO_WAIT) {
  107491:	85 c9                	test   %ecx,%ecx
  107493:	75 0e                	jne    1074a3 <k_sem_take+0x2e>
		irq_unlock(key);
		return -EBUSY;
  107495:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  10749a:	0f ba e3 09          	bt     $0x9,%ebx
  10749e:	73 18                	jae    1074b8 <k_sem_take+0x43>
	__asm__ volatile (
  1074a0:	fb                   	sti    
  1074a1:	eb 15                	jmp    1074b8 <k_sem_take+0x43>
	}

	_pend_current_thread(&sem->wait_q, timeout);
  1074a3:	51                   	push   %ecx
  1074a4:	52                   	push   %edx
  1074a5:	e8 19 fd ff ff       	call   1071c3 <_pend_current_thread>

	return _Swap(key);
  1074aa:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1074ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	_pend_current_thread(&sem->wait_q, timeout);
  1074b0:	58                   	pop    %eax
  1074b1:	5a                   	pop    %edx
}
  1074b2:	c9                   	leave  
	return _Swap(key);
  1074b3:	e9 7c f3 ff ff       	jmp    106834 <_Swap>
}
  1074b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1074bb:	c9                   	leave  
  1074bc:	c3                   	ret    

001074bd <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  1074bd:	55                   	push   %ebp
  1074be:	89 e5                	mov    %esp,%ebp
  1074c0:	57                   	push   %edi
  1074c1:	56                   	push   %esi
  1074c2:	53                   	push   %ebx
  1074c3:	83 ec 08             	sub    $0x8,%esp
  1074c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  1074c9:	9c                   	pushf  
  1074ca:	fa                   	cli    
  1074cb:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
  1074cc:	89 df                	mov    %ebx,%edi
  1074ce:	c1 ff 1f             	sar    $0x1f,%edi
  1074d1:	01 1d 98 9b 10 00    	add    %ebx,0x109b98
  1074d7:	11 3d 9c 9b 10 00    	adc    %edi,0x109b9c
  1074dd:	0f ba e0 09          	bt     $0x9,%eax
  1074e1:	73 01                	jae    1074e4 <_nano_sys_clock_tick_announce+0x27>
	__asm__ volatile (
  1074e3:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
  1074e4:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  1074e7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
  1074ea:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
  1074ed:	9c                   	pushf  
  1074ee:	fa                   	cli    
  1074ef:	5e                   	pop    %esi
	return list->head == list;
  1074f0:	a1 6c 9a 10 00       	mov    0x109a6c,%eax
  1074f5:	89 f2                	mov    %esi,%edx
	if (!head) {
  1074f7:	85 c0                	test   %eax,%eax
  1074f9:	74 07                	je     107502 <_nano_sys_clock_tick_announce+0x45>
  1074fb:	3d 6c 9a 10 00       	cmp    $0x109a6c,%eax
  107500:	75 10                	jne    107512 <_nano_sys_clock_tick_announce+0x55>
  107502:	0f ba e6 09          	bt     $0x9,%esi
  107506:	0f 83 06 01 00 00    	jae    107612 <_nano_sys_clock_tick_announce+0x155>
	__asm__ volatile (
  10750c:	fb                   	sti    
  10750d:	e9 00 01 00 00       	jmp    107612 <_nano_sys_clock_tick_announce+0x155>
	head->delta_ticks_from_prev -= ticks;
  107512:	29 58 10             	sub    %ebx,0x10(%eax)
	_handling_timeouts = 1;
  107515:	c7 05 90 9b 10 00 01 	movl   $0x1,0x109b90
  10751c:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
  10751f:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  107523:	75 3e                	jne    107563 <_nano_sys_clock_tick_announce+0xa6>
	node->prev->next = node->next;
  107525:	8b 70 04             	mov    0x4(%eax),%esi
  107528:	8b 38                	mov    (%eax),%edi
  10752a:	0f ba e2 09          	bt     $0x9,%edx
  10752e:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
  107530:	8b 38                	mov    (%eax),%edi
  107532:	89 77 04             	mov    %esi,0x4(%edi)
	node->next = list->head;
  107535:	8b 75 ec             	mov    -0x14(%ebp),%esi
  107538:	89 30                	mov    %esi,(%eax)
	node->prev = list;
  10753a:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
  10753d:	8b 75 ec             	mov    -0x14(%ebp),%esi
	list->head = node;
  107540:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
  107543:	89 46 04             	mov    %eax,0x4(%esi)
		timeout->delta_ticks_from_prev = _EXPIRED;
  107546:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
  10754d:	73 01                	jae    107550 <_nano_sys_clock_tick_announce+0x93>
  10754f:	fb                   	sti    
	__asm__ volatile (
  107550:	9c                   	pushf  
  107551:	fa                   	cli    
  107552:	5a                   	pop    %edx
	return list->head == list;
  107553:	a1 6c 9a 10 00       	mov    0x109a6c,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
  107558:	3d 6c 9a 10 00       	cmp    $0x109a6c,%eax
  10755d:	74 04                	je     107563 <_nano_sys_clock_tick_announce+0xa6>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
  10755f:	85 c0                	test   %eax,%eax
  107561:	75 bc                	jne    10751f <_nano_sys_clock_tick_announce+0x62>
  107563:	0f ba e2 09          	bt     $0x9,%edx
  107567:	73 01                	jae    10756a <_nano_sys_clock_tick_announce+0xad>
	__asm__ volatile (
  107569:	fb                   	sti    
	return list->head == list;
  10756a:	8b 45 ec             	mov    -0x14(%ebp),%eax
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  10756d:	39 c8                	cmp    %ecx,%eax
  10756f:	74 04                	je     107575 <_nano_sys_clock_tick_announce+0xb8>
  107571:	85 c0                	test   %eax,%eax
  107573:	75 0f                	jne    107584 <_nano_sys_clock_tick_announce+0xc7>
	_handling_timeouts = 0;
  107575:	c7 05 90 9b 10 00 00 	movl   $0x0,0x109b90
  10757c:	00 00 00 
  10757f:	e9 8e 00 00 00       	jmp    107612 <_nano_sys_clock_tick_announce+0x155>
	return (node == list->tail) ? NULL : node->next;
  107584:	31 f6                	xor    %esi,%esi
  107586:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  107589:	74 4c                	je     1075d7 <_nano_sys_clock_tick_announce+0x11a>
  10758b:	8b 30                	mov    (%eax),%esi
  10758d:	eb 48                	jmp    1075d7 <_nano_sys_clock_tick_announce+0x11a>
	if (timeout_obj->wait_q) {
  10758f:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  107593:	74 17                	je     1075ac <_nano_sys_clock_tick_announce+0xef>
	node->prev->next = node->next;
  107595:	8b 42 04             	mov    0x4(%edx),%eax
  107598:	8b 0a                	mov    (%edx),%ecx
  10759a:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  10759c:	8b 0a                	mov    (%edx),%ecx
  10759e:	89 41 04             	mov    %eax,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
  1075a1:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
  1075a8:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1075ac:	8a 42 09             	mov    0x9(%edx),%al
  1075af:	88 c1                	mov    %al,%cl
  1075b1:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
  1075b4:	a8 1b                	test   $0x1b,%al
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1075b6:	88 4a 09             	mov    %cl,0x9(%edx)
	return !(_is_thread_prevented_from_running(thread) ||
  1075b9:	74 3b                	je     1075f6 <_nano_sys_clock_tick_announce+0x139>
  1075bb:	0f ba e7 09          	bt     $0x9,%edi
  1075bf:	73 01                	jae    1075c2 <_nano_sys_clock_tick_announce+0x105>
  1075c1:	fb                   	sti    
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1075c2:	85 f6                	test   %esi,%esi
  1075c4:	74 af                	je     107575 <_nano_sys_clock_tick_announce+0xb8>
	return (node == list->tail) ? NULL : node->next;
  1075c6:	31 d2                	xor    %edx,%edx
  1075c8:	39 75 f0             	cmp    %esi,-0x10(%ebp)
  1075cb:	74 02                	je     1075cf <_nano_sys_clock_tick_announce+0x112>
  1075cd:	8b 16                	mov    (%esi),%edx
	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
  1075cf:	85 f6                	test   %esi,%esi
  1075d1:	74 a2                	je     107575 <_nano_sys_clock_tick_announce+0xb8>
  1075d3:	89 f0                	mov    %esi,%eax
  1075d5:	89 d6                	mov    %edx,%esi
	node->prev->next = node->next;
  1075d7:	8b 50 04             	mov    0x4(%eax),%edx
  1075da:	8b 08                	mov    (%eax),%ecx
  1075dc:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1075de:	8b 08                	mov    (%eax),%ecx
  1075e0:	89 51 04             	mov    %edx,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
  1075e3:	8b 50 08             	mov    0x8(%eax),%edx
	__asm__ volatile (
  1075e6:	9c                   	pushf  
  1075e7:	fa                   	cli    
  1075e8:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
  1075e9:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	if (thread) {
  1075f0:	85 d2                	test   %edx,%edx
  1075f2:	75 9b                	jne    10758f <_nano_sys_clock_tick_announce+0xd2>
  1075f4:	eb 08                	jmp    1075fe <_nano_sys_clock_tick_announce+0x141>
  1075f6:	83 7a 20 ff          	cmpl   $0xffffffff,0x20(%edx)
  1075fa:	75 bf                	jne    1075bb <_nano_sys_clock_tick_announce+0xfe>
  1075fc:	eb 66                	jmp    107664 <_nano_sys_clock_tick_announce+0x1a7>
  1075fe:	0f ba e7 09          	bt     $0x9,%edi
  107602:	73 01                	jae    107605 <_nano_sys_clock_tick_announce+0x148>
	__asm__ volatile (
  107604:	fb                   	sti    
		if (timeout->func) {
  107605:	8b 50 14             	mov    0x14(%eax),%edx
  107608:	85 d2                	test   %edx,%edx
  10760a:	74 b6                	je     1075c2 <_nano_sys_clock_tick_announce+0x105>
			timeout->func(timeout);
  10760c:	50                   	push   %eax
  10760d:	ff d2                	call   *%edx
  10760f:	59                   	pop    %ecx
  107610:	eb b0                	jmp    1075c2 <_nano_sys_clock_tick_announce+0x105>
	if (_time_slice_duration == 0) {
  107612:	a1 80 9b 10 00       	mov    0x109b80,%eax
  107617:	85 c0                	test   %eax,%eax
  107619:	74 55                	je     107670 <_nano_sys_clock_tick_announce+0x1b3>
	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  10761b:	8b 15 68 9a 10 00    	mov    0x109a68,%edx
  107621:	0f be 52 0a          	movsbl 0xa(%edx),%edx
  107625:	39 15 7c 9b 10 00    	cmp    %edx,0x109b7c
  10762b:	7f 43                	jg     107670 <_nano_sys_clock_tick_announce+0x1b3>
	return (uint64_t)ticks * _ms_per_tick;
  10762d:	6b db 0a             	imul   $0xa,%ebx,%ebx
	_time_slice_elapsed += __ticks_to_ms(ticks);
  107630:	03 1d 94 9b 10 00    	add    0x109b94,%ebx
	if (_time_slice_elapsed >= _time_slice_duration) {
  107636:	39 d8                	cmp    %ebx,%eax
  107638:	7e 08                	jle    107642 <_nano_sys_clock_tick_announce+0x185>
	_time_slice_elapsed += __ticks_to_ms(ticks);
  10763a:	89 1d 94 9b 10 00    	mov    %ebx,0x109b94
  107640:	eb 2e                	jmp    107670 <_nano_sys_clock_tick_announce+0x1b3>
		_time_slice_elapsed = 0;
  107642:	c7 05 94 9b 10 00 00 	movl   $0x0,0x109b94
  107649:	00 00 00 
	__asm__ volatile (
  10764c:	9c                   	pushf  
  10764d:	fa                   	cli    
  10764e:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
  10764f:	ff 35 68 9a 10 00    	pushl  0x109a68
  107655:	e8 ef fb ff ff       	call   107249 <_move_thread_to_end_of_prio_q>
  10765a:	5a                   	pop    %edx
  10765b:	0f ba e3 09          	bt     $0x9,%ebx
  10765f:	73 0f                	jae    107670 <_nano_sys_clock_tick_announce+0x1b3>
	__asm__ volatile (
  107661:	fb                   	sti    

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
}
  107662:	eb 0c                	jmp    107670 <_nano_sys_clock_tick_announce+0x1b3>
		_add_thread_to_ready_q(thread);
  107664:	52                   	push   %edx
  107665:	e8 1a fa ff ff       	call   107084 <_add_thread_to_ready_q>
  10766a:	58                   	pop    %eax
  10766b:	e9 4b ff ff ff       	jmp    1075bb <_nano_sys_clock_tick_announce+0xfe>
  107670:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107673:	5b                   	pop    %ebx
  107674:	5e                   	pop    %esi
  107675:	5f                   	pop    %edi
  107676:	5d                   	pop    %ebp
  107677:	c3                   	ret    

00107678 <k_sys_work_q_init>:
char __noinit __stack sys_work_q_stack[CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE];

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
  107678:	55                   	push   %ebp
  107679:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
  10767b:	6a ff                	push   $0xffffffff
  10767d:	68 00 04 00 00       	push   $0x400
  107682:	68 a0 cc 10 00       	push   $0x10cca0
  107687:	68 a0 9b 10 00       	push   $0x109ba0
  10768c:	e8 ab 05 00 00       	call   107c3c <k_work_q_start>
  107691:	83 c4 10             	add    $0x10,%esp
		       sys_work_q_stack,
		       sizeof(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);

	return 0;
}
  107694:	31 c0                	xor    %eax,%eax
  107696:	c9                   	leave  
  107697:	c3                   	ret    

00107698 <_is_thread_ready>:
{
  107698:	55                   	push   %ebp
  107699:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
  10769b:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  10769f:	75 09                	jne    1076aa <_is_thread_ready+0x12>
  1076a1:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1076a5:	0f 94 c0             	sete   %al
  1076a8:	eb 02                	jmp    1076ac <_is_thread_ready+0x14>
  1076aa:	31 c0                	xor    %eax,%eax
  1076ac:	0f b6 c0             	movzbl %al,%eax
}
  1076af:	5d                   	pop    %ebp
  1076b0:	c3                   	ret    

001076b1 <_abort_timeout>:
{
  1076b1:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1076b2:	8b 48 10             	mov    0x10(%eax),%ecx
{
  1076b5:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1076b7:	83 f9 ff             	cmp    $0xffffffff,%ecx
  1076ba:	74 24                	je     1076e0 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  1076bc:	3b 05 70 9a 10 00    	cmp    0x109a70,%eax
  1076c2:	74 05                	je     1076c9 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
  1076c4:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  1076c6:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
  1076c9:	8b 50 04             	mov    0x4(%eax),%edx
  1076cc:	8b 08                	mov    (%eax),%ecx
  1076ce:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1076d0:	8b 08                	mov    (%eax),%ecx
  1076d2:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
  1076d5:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
  1076dc:	31 c0                	xor    %eax,%eax
  1076de:	eb 03                	jmp    1076e3 <_abort_timeout+0x32>
		return _INACTIVE;
  1076e0:	83 c8 ff             	or     $0xffffffff,%eax
}
  1076e3:	5d                   	pop    %ebp
  1076e4:	c3                   	ret    

001076e5 <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
  1076e5:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  1076e6:	85 d2                	test   %edx,%edx
{
  1076e8:	89 e5                	mov    %esp,%ebp
  1076ea:	57                   	push   %edi
  1076eb:	56                   	push   %esi
  1076ec:	53                   	push   %ebx
  1076ed:	51                   	push   %ecx
  1076ee:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
  1076f0:	75 41                	jne    107733 <schedule_new_thread+0x4e>
	__asm__ volatile (
  1076f2:	9c                   	pushf  
  1076f3:	fa                   	cli    
  1076f4:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1076f5:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
  1076f9:	e8 9a ff ff ff       	call   107698 <_is_thread_ready>
  1076fe:	85 c0                	test   %eax,%eax
  107700:	75 09                	jne    10770b <schedule_new_thread+0x26>
  107702:	0f ba e3 09          	bt     $0x9,%ebx
  107706:	e9 b1 00 00 00       	jmp    1077bc <schedule_new_thread+0xd7>
		_add_thread_to_ready_q(thread);
  10770b:	51                   	push   %ecx
  10770c:	e8 73 f9 ff ff       	call   107084 <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
  107711:	a1 68 9a 10 00       	mov    0x109a68,%eax
  107716:	5a                   	pop    %edx
  107717:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  10771c:	77 e4                	ja     107702 <schedule_new_thread+0x1d>
  10771e:	e8 c5 fa ff ff       	call   1071e8 <__must_switch_threads>
  107723:	85 c0                	test   %eax,%eax
  107725:	74 db                	je     107702 <schedule_new_thread+0x1d>
			_Swap(key);
  107727:	53                   	push   %ebx
  107728:	e8 07 f1 ff ff       	call   106834 <_Swap>
  10772d:	58                   	pop    %eax
  10772e:	e9 8c 00 00 00       	jmp    1077bf <schedule_new_thread+0xda>
  107733:	9c                   	pushf  
  107734:	fa                   	cli    
  107735:	8f 45 f0             	popl   -0x10(%ebp)
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  107738:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  10773d:	8d 58 10             	lea    0x10(%eax),%ebx
  107740:	8d 42 09             	lea    0x9(%edx),%eax
  107743:	31 d2                	xor    %edx,%edx
  107745:	f7 f6                	div    %esi
		start_thread(thread);
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  107747:	40                   	inc    %eax
	timeout->thread = thread;
  107748:	89 49 18             	mov    %ecx,0x18(%ecx)
  10774b:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
  10774e:	a1 6c 9a 10 00       	mov    0x109a6c,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
  107753:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  10775a:	85 c0                	test   %eax,%eax
  10775c:	74 0d                	je     10776b <schedule_new_thread+0x86>
  10775e:	8b 3d 70 9a 10 00    	mov    0x109a70,%edi
  107764:	3d 6c 9a 10 00       	cmp    $0x109a6c,%eax
  107769:	75 19                	jne    107784 <schedule_new_thread+0x9f>
	node->next = list;
  10776b:	c7 41 10 6c 9a 10 00 	movl   $0x109a6c,0x10(%ecx)
	node->prev = list->tail;
  107772:	a1 70 9a 10 00       	mov    0x109a70,%eax
  107777:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
  10777a:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10777c:	89 1d 70 9a 10 00    	mov    %ebx,0x109a70
  107782:	eb 31                	jmp    1077b5 <schedule_new_thread+0xd0>
		if (*delta <= in_q->delta_ticks_from_prev) {
  107784:	8b 51 20             	mov    0x20(%ecx),%edx
  107787:	8b 70 10             	mov    0x10(%eax),%esi
  10778a:	39 f2                	cmp    %esi,%edx
  10778c:	7f 18                	jg     1077a6 <schedule_new_thread+0xc1>
			in_q->delta_ticks_from_prev -= *delta;
  10778e:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
  107790:	8b 50 04             	mov    0x4(%eax),%edx
  107793:	89 70 10             	mov    %esi,0x10(%eax)
  107796:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
  107799:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
  10779c:	8b 50 04             	mov    0x4(%eax),%edx
  10779f:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
  1077a1:	89 58 04             	mov    %ebx,0x4(%eax)
  1077a4:	eb 0f                	jmp    1077b5 <schedule_new_thread+0xd0>
		*delta -= in_q->delta_ticks_from_prev;
  1077a6:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
  1077a8:	39 f8                	cmp    %edi,%eax
  1077aa:	89 51 20             	mov    %edx,0x20(%ecx)
  1077ad:	74 bc                	je     10776b <schedule_new_thread+0x86>
  1077af:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1077b1:	85 c0                	test   %eax,%eax
  1077b3:	eb b4                	jmp    107769 <schedule_new_thread+0x84>
  1077b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1077b8:	0f ba e0 09          	bt     $0x9,%eax
  1077bc:	73 01                	jae    1077bf <schedule_new_thread+0xda>
	__asm__ volatile (
  1077be:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  1077bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1077c2:	5b                   	pop    %ebx
  1077c3:	5e                   	pop    %esi
  1077c4:	5f                   	pop    %edi
  1077c5:	5d                   	pop    %ebp
  1077c6:	c3                   	ret    

001077c7 <k_is_in_isr>:
{
  1077c7:	55                   	push   %ebp
	return _is_in_isr();
  1077c8:	31 c0                	xor    %eax,%eax
{
  1077ca:	89 e5                	mov    %esp,%ebp
}
  1077cc:	5d                   	pop    %ebp
	return _is_in_isr();
  1077cd:	83 3d 60 9a 10 00 00 	cmpl   $0x0,0x109a60
  1077d4:	0f 95 c0             	setne  %al
}
  1077d7:	c3                   	ret    

001077d8 <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
  1077d8:	a1 68 9a 10 00       	mov    0x109a68,%eax
{
  1077dd:	55                   	push   %ebp
  1077de:	89 e5                	mov    %esp,%ebp
}
  1077e0:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
  1077e1:	8a 40 08             	mov    0x8(%eax),%al
  1077e4:	83 e0 01             	and    $0x1,%eax
}
  1077e7:	c3                   	ret    

001077e8 <_thread_entry>:
{
  1077e8:	55                   	push   %ebp
  1077e9:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
  1077eb:	ff 75 14             	pushl  0x14(%ebp)
  1077ee:	ff 75 10             	pushl  0x10(%ebp)
  1077f1:	ff 75 0c             	pushl  0xc(%ebp)
  1077f4:	ff 55 08             	call   *0x8(%ebp)
  1077f7:	83 c4 0c             	add    $0xc,%esp
	if (_is_thread_essential()) {
  1077fa:	e8 d9 ff ff ff       	call   1077d8 <_is_thread_essential>
  1077ff:	85 c0                	test   %eax,%eax
  107801:	74 0c                	je     10780f <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  107803:	68 a0 83 10 00       	push   $0x1083a0
  107808:	6a 03                	push   $0x3
  10780a:	e8 c8 f0 ff ff       	call   1068d7 <_NanoFatalErrorHandler>
	k_thread_abort(_current);
  10780f:	ff 35 68 9a 10 00    	pushl  0x109a68
  107815:	e8 3b 01 00 00       	call   107955 <k_thread_abort>
  10781a:	58                   	pop    %eax

0010781b <k_thread_spawn>:
#ifdef CONFIG_MULTITHREADING
k_tid_t k_thread_spawn(char *stack, size_t stack_size,
			void (*entry)(void *, void *, void*),
			void *p1, void *p2, void *p3,
			int prio, uint32_t options, int32_t delay)
{
  10781b:	55                   	push   %ebp
  10781c:	89 e5                	mov    %esp,%ebp
  10781e:	53                   	push   %ebx
	__ASSERT(!_is_in_isr(), "");

	struct k_thread *new_thread = (struct k_thread *)stack;

	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  10781f:	ff 75 24             	pushl  0x24(%ebp)
  107822:	ff 75 20             	pushl  0x20(%ebp)
  107825:	ff 75 1c             	pushl  0x1c(%ebp)
  107828:	ff 75 18             	pushl  0x18(%ebp)
  10782b:	ff 75 14             	pushl  0x14(%ebp)
  10782e:	ff 75 10             	pushl  0x10(%ebp)
  107831:	ff 75 0c             	pushl  0xc(%ebp)
{
  107834:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  107837:	53                   	push   %ebx
  107838:	e8 20 f0 ff ff       	call   10685d <_new_thread>

	schedule_new_thread(new_thread, delay);
  10783d:	89 d8                	mov    %ebx,%eax
	_new_thread(stack, stack_size, entry, p1, p2, p3, prio, options);
  10783f:	83 c4 20             	add    $0x20,%esp
	schedule_new_thread(new_thread, delay);
  107842:	8b 55 28             	mov    0x28(%ebp),%edx
  107845:	e8 9b fe ff ff       	call   1076e5 <schedule_new_thread>

	return new_thread;
}
  10784a:	89 d8                	mov    %ebx,%eax
  10784c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10784f:	c9                   	leave  
  107850:	c3                   	ret    

00107851 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  107851:	55                   	push   %ebp
  107852:	89 e5                	mov    %esp,%ebp
  107854:	53                   	push   %ebx
  107855:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
  107858:	8b 43 30             	mov    0x30(%ebx),%eax
  10785b:	85 c0                	test   %eax,%eax
  10785d:	74 02                	je     107861 <_k_thread_single_abort+0x10>
		thread->fn_abort();
  10785f:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
  107861:	89 d8                	mov    %ebx,%eax
  107863:	e8 30 fe ff ff       	call   107698 <_is_thread_ready>
  107868:	85 c0                	test   %eax,%eax
  10786a:	74 09                	je     107875 <_k_thread_single_abort+0x24>
		_remove_thread_from_ready_q(thread);
  10786c:	53                   	push   %ebx
  10786d:	e8 73 f8 ff ff       	call   1070e5 <_remove_thread_from_ready_q>
  107872:	58                   	pop    %eax
  107873:	eb 24                	jmp    107899 <_k_thread_single_abort+0x48>
	} else {
		if (_is_thread_pending(thread)) {
  107875:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
  107879:	74 10                	je     10788b <_k_thread_single_abort+0x3a>
	node->prev->next = node->next;
  10787b:	8b 43 04             	mov    0x4(%ebx),%eax
  10787e:	8b 13                	mov    (%ebx),%edx
  107880:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  107882:	8b 13                	mov    (%ebx),%edx
  107884:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
  107887:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  10788b:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  10788f:	74 08                	je     107899 <_k_thread_single_abort+0x48>
	return _abort_timeout(&thread->base.timeout);
  107891:	8d 43 10             	lea    0x10(%ebx),%eax
  107894:	e8 18 fe ff ff       	call   1076b1 <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
  107899:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  10789d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1078a0:	c9                   	leave  
  1078a1:	c3                   	ret    

001078a2 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
  1078a2:	55                   	push   %ebp
  1078a3:	89 e5                	mov    %esp,%ebp
  1078a5:	56                   	push   %esi
  1078a6:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  1078a7:	bb 14 8e 10 00       	mov    $0x108e14,%ebx
  1078ac:	81 fb 14 8e 10 00    	cmp    $0x108e14,%ebx
  1078b2:	73 29                	jae    1078dd <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
  1078b4:	ff 73 1c             	pushl  0x1c(%ebx)
  1078b7:	ff 73 18             	pushl  0x18(%ebx)
  1078ba:	ff 73 14             	pushl  0x14(%ebx)
  1078bd:	ff 73 10             	pushl  0x10(%ebx)
  1078c0:	ff 73 0c             	pushl  0xc(%ebx)
  1078c3:	ff 73 08             	pushl  0x8(%ebx)
  1078c6:	ff 73 04             	pushl  0x4(%ebx)
  1078c9:	ff 33                	pushl  (%ebx)
  1078cb:	e8 8d ef ff ff       	call   10685d <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  1078d0:	8b 03                	mov    (%ebx),%eax
		_new_thread(
  1078d2:	83 c4 20             	add    $0x20,%esp
		thread_data->thread->init_data = thread_data;
  1078d5:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
  1078d8:	83 c3 2c             	add    $0x2c,%ebx
  1078db:	eb cf                	jmp    1078ac <_init_static_threads+0xa>
	--_current->base.sched_locked;
  1078dd:	a1 68 9a 10 00       	mov    0x109a68,%eax
  1078e2:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
  1078e5:	9c                   	pushf  
  1078e6:	fa                   	cli    
  1078e7:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  1078e8:	bb 14 8e 10 00       	mov    $0x108e14,%ebx
  1078ed:	81 fb 14 8e 10 00    	cmp    $0x108e14,%ebx
  1078f3:	73 14                	jae    107909 <_init_static_threads+0x67>
		if (thread_data->init_delay != K_FOREVER) {
  1078f5:	8b 53 20             	mov    0x20(%ebx),%edx
  1078f8:	83 fa ff             	cmp    $0xffffffff,%edx
  1078fb:	74 07                	je     107904 <_init_static_threads+0x62>
			schedule_new_thread(thread_data->thread,
  1078fd:	8b 03                	mov    (%ebx),%eax
  1078ff:	e8 e1 fd ff ff       	call   1076e5 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
  107904:	83 c3 2c             	add    $0x2c,%ebx
  107907:	eb e4                	jmp    1078ed <_init_static_threads+0x4b>
  107909:	0f ba e6 09          	bt     $0x9,%esi
  10790d:	73 01                	jae    107910 <_init_static_threads+0x6e>
	__asm__ volatile (
  10790f:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
  107910:	8d 65 f8             	lea    -0x8(%ebp),%esp
  107913:	5b                   	pop    %ebx
  107914:	5e                   	pop    %esi
  107915:	5d                   	pop    %ebp
	k_sched_unlock();
  107916:	e9 17 f9 ff ff       	jmp    107232 <k_sched_unlock>

0010791b <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  10791b:	55                   	push   %ebp
  10791c:	89 e5                	mov    %esp,%ebp
  10791e:	8b 45 08             	mov    0x8(%ebp),%eax
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  107921:	8b 55 14             	mov    0x14(%ebp),%edx
  107924:	88 50 08             	mov    %dl,0x8(%eax)
	thread_base->thread_state = (uint8_t)initial_state;
  107927:	8b 55 10             	mov    0x10(%ebp),%edx
  10792a:	88 50 09             	mov    %dl,0x9(%eax)

	thread_base->prio = priority;
  10792d:	8b 55 0c             	mov    0xc(%ebp),%edx
  107930:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
  107933:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	t->delta_ticks_from_prev = _INACTIVE;
  107937:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
	t->wait_q = NULL;
  10793e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	t->thread = NULL;
  107945:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
  10794c:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  107953:	5d                   	pop    %ebp
  107954:	c3                   	ret    

00107955 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
  107955:	55                   	push   %ebp
  107956:	89 e5                	mov    %esp,%ebp
  107958:	56                   	push   %esi
  107959:	53                   	push   %ebx
  10795a:	8b 75 08             	mov    0x8(%ebp),%esi
	__asm__ volatile (
  10795d:	9c                   	pushf  
  10795e:	fa                   	cli    
  10795f:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  107960:	56                   	push   %esi
  107961:	e8 eb fe ff ff       	call   107851 <_k_thread_single_abort>
  107966:	5a                   	pop    %edx
	_thread_monitor_exit(thread);

	if (_current == thread) {
  107967:	3b 35 68 9a 10 00    	cmp    0x109a68,%esi
  10796d:	75 07                	jne    107976 <k_thread_abort+0x21>
		_Swap(key);
  10796f:	53                   	push   %ebx
  107970:	e8 bf ee ff ff       	call   106834 <_Swap>
  107975:	58                   	pop    %eax
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  107976:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  107979:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10797c:	5b                   	pop    %ebx
  10797d:	5e                   	pop    %esi
  10797e:	5d                   	pop    %ebp
	_reschedule_threads(key);
  10797f:	e9 7f f8 ff ff       	jmp    107203 <_reschedule_threads>

00107984 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
  107984:	8a 50 09             	mov    0x9(%eax),%dl
  107987:	88 d1                	mov    %dl,%cl
  107989:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
  10798c:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
  10798f:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
  107992:	75 11                	jne    1079a5 <_ready_thread+0x21>
  107994:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  107998:	75 0b                	jne    1079a5 <_ready_thread+0x21>
{
  10799a:	55                   	push   %ebp
  10799b:	89 e5                	mov    %esp,%ebp
		_add_thread_to_ready_q(thread);
  10799d:	50                   	push   %eax
  10799e:	e8 e1 f6 ff ff       	call   107084 <_add_thread_to_ready_q>
  1079a3:	58                   	pop    %eax
}
  1079a4:	c9                   	leave  
  1079a5:	c3                   	ret    

001079a6 <_abort_timeout>:
{
  1079a6:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1079a7:	8b 48 10             	mov    0x10(%eax),%ecx
{
  1079aa:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1079ac:	83 f9 ff             	cmp    $0xffffffff,%ecx
  1079af:	74 24                	je     1079d5 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  1079b1:	3b 05 70 9a 10 00    	cmp    0x109a70,%eax
  1079b7:	74 05                	je     1079be <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
  1079b9:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  1079bb:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
  1079be:	8b 50 04             	mov    0x4(%eax),%edx
  1079c1:	8b 08                	mov    (%eax),%ecx
  1079c3:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1079c5:	8b 08                	mov    (%eax),%ecx
  1079c7:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
  1079ca:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
  1079d1:	31 c0                	xor    %eax,%eax
  1079d3:	eb 03                	jmp    1079d8 <_abort_timeout+0x32>
		return _INACTIVE;
  1079d5:	83 c8 ff             	or     $0xffffffff,%eax
}
  1079d8:	5d                   	pop    %ebp
  1079d9:	c3                   	ret    

001079da <_add_timeout.constprop.7>:
	timeout->thread = thread;
  1079da:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  1079e1:	89 50 0c             	mov    %edx,0xc(%eax)
static inline void _add_timeout(struct k_thread *thread,
  1079e4:	55                   	push   %ebp
	return list->head == list;
  1079e5:	8b 15 6c 9a 10 00    	mov    0x109a6c,%edx
  1079eb:	89 e5                	mov    %esp,%ebp
	timeout->delta_ticks_from_prev = timeout_in_ticks;
  1079ed:	89 48 10             	mov    %ecx,0x10(%eax)
static inline void _add_timeout(struct k_thread *thread,
  1079f0:	53                   	push   %ebx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1079f1:	85 d2                	test   %edx,%edx
  1079f3:	74 08                	je     1079fd <_add_timeout.constprop.7+0x23>
  1079f5:	81 fa 6c 9a 10 00    	cmp    $0x109a6c,%edx
  1079fb:	75 1e                	jne    107a1b <_add_timeout.constprop.7+0x41>
	node->next = list;
  1079fd:	c7 00 6c 9a 10 00    	movl   $0x109a6c,(%eax)
	node->prev = list->tail;
  107a03:	8b 15 70 9a 10 00    	mov    0x109a70,%edx
  107a09:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
  107a0c:	8b 15 70 9a 10 00    	mov    0x109a70,%edx
  107a12:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  107a14:	a3 70 9a 10 00       	mov    %eax,0x109a70
  107a19:	eb 34                	jmp    107a4f <_add_timeout.constprop.7+0x75>
		if (*delta <= in_q->delta_ticks_from_prev) {
  107a1b:	8b 48 10             	mov    0x10(%eax),%ecx
  107a1e:	8b 5a 10             	mov    0x10(%edx),%ebx
  107a21:	39 d9                	cmp    %ebx,%ecx
  107a23:	7f 17                	jg     107a3c <_add_timeout.constprop.7+0x62>
			in_q->delta_ticks_from_prev -= *delta;
  107a25:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
  107a27:	8b 4a 04             	mov    0x4(%edx),%ecx
  107a2a:	89 5a 10             	mov    %ebx,0x10(%edx)
  107a2d:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  107a30:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
  107a32:	8b 4a 04             	mov    0x4(%edx),%ecx
  107a35:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  107a37:	89 42 04             	mov    %eax,0x4(%edx)
  107a3a:	eb 13                	jmp    107a4f <_add_timeout.constprop.7+0x75>
		*delta -= in_q->delta_ticks_from_prev;
  107a3c:	29 d9                	sub    %ebx,%ecx
  107a3e:	89 48 10             	mov    %ecx,0x10(%eax)
	return (node == list->tail) ? NULL : node->next;
  107a41:	3b 15 70 9a 10 00    	cmp    0x109a70,%edx
  107a47:	74 b4                	je     1079fd <_add_timeout.constprop.7+0x23>
  107a49:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  107a4b:	85 d2                	test   %edx,%edx
  107a4d:	eb ac                	jmp    1079fb <_add_timeout.constprop.7+0x21>
}
  107a4f:	5b                   	pop    %ebx
  107a50:	5d                   	pop    %ebp
  107a51:	c3                   	ret    

00107a52 <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
  107a52:	55                   	push   %ebp
  107a53:	89 e5                	mov    %esp,%ebp
  107a55:	56                   	push   %esi
  107a56:	53                   	push   %ebx
  107a57:	8b 5d 08             	mov    0x8(%ebp),%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
  107a5a:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
  107a5e:	7e 17                	jle    107a77 <_timer_expiration_handler+0x25>
  107a60:	9c                   	pushf  
  107a61:	fa                   	cli    
  107a62:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
  107a63:	8b 4b 28             	mov    0x28(%ebx),%ecx
  107a66:	8d 53 18             	lea    0x18(%ebx),%edx
  107a69:	89 d8                	mov    %ebx,%eax
  107a6b:	e8 6a ff ff ff       	call   1079da <_add_timeout.constprop.7>
  107a70:	0f ba e6 09          	bt     $0x9,%esi
  107a74:	73 01                	jae    107a77 <_timer_expiration_handler+0x25>
	__asm__ volatile (
  107a76:	fb                   	sti    

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
  107a77:	8b 43 20             	mov    0x20(%ebx),%eax
	timer->status += 1;
  107a7a:	ff 43 2c             	incl   0x2c(%ebx)
	if (timer->expiry_fn) {
  107a7d:	85 c0                	test   %eax,%eax
  107a7f:	74 04                	je     107a85 <_timer_expiration_handler+0x33>
		timer->expiry_fn(timer);
  107a81:	53                   	push   %ebx
  107a82:	ff d0                	call   *%eax
  107a84:	58                   	pop    %eax
	return list->head == list;
  107a85:	8b 73 18             	mov    0x18(%ebx),%esi
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);

	if (!thread) {
  107a88:	85 f6                	test   %esi,%esi
  107a8a:	74 31                	je     107abd <_timer_expiration_handler+0x6b>
	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
  107a8c:	83 c3 18             	add    $0x18,%ebx
	if (!thread) {
  107a8f:	39 de                	cmp    %ebx,%esi
  107a91:	74 2a                	je     107abd <_timer_expiration_handler+0x6b>
	node->prev->next = node->next;
  107a93:	8b 46 04             	mov    0x4(%esi),%eax
  107a96:	8b 16                	mov    (%esi),%edx
  107a98:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  107a9a:	8b 16                	mov    (%esi),%edx
  107a9c:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
  107a9f:	80 66 09 fd          	andb   $0xfd,0x9(%esi)
	__asm__ volatile (
  107aa3:	9c                   	pushf  
  107aa4:	fa                   	cli    
  107aa5:	5b                   	pop    %ebx
	 * cannot interrupt the current context.
	 */
	_unpend_thread(thread);

	key = irq_lock();
	_ready_thread(thread);
  107aa6:	89 f0                	mov    %esi,%eax
  107aa8:	e8 d7 fe ff ff       	call   107984 <_ready_thread>
  107aad:	0f ba e3 09          	bt     $0x9,%ebx
  107ab1:	73 01                	jae    107ab4 <_timer_expiration_handler+0x62>
	__asm__ volatile (
  107ab3:	fb                   	sti    
  107ab4:	8b 46 28             	mov    0x28(%esi),%eax
  107ab7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
  107abd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  107ac0:	5b                   	pop    %ebx
  107ac1:	5e                   	pop    %esi
  107ac2:	5d                   	pop    %ebp
  107ac3:	c3                   	ret    

00107ac4 <k_timer_init>:


void k_timer_init(struct k_timer *timer,
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
  107ac4:	55                   	push   %ebp
  107ac5:	89 e5                	mov    %esp,%ebp
  107ac7:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->expiry_fn = expiry_fn;
  107aca:	8b 55 0c             	mov    0xc(%ebp),%edx
  107acd:	89 50 20             	mov    %edx,0x20(%eax)
	timer->stop_fn = stop_fn;
  107ad0:	8b 55 10             	mov    0x10(%ebp),%edx
  107ad3:	89 50 24             	mov    %edx,0x24(%eax)
	timer->status = 0;

	sys_dlist_init(&timer->wait_q);
  107ad6:	8d 50 18             	lea    0x18(%eax),%edx
	timer->status = 0;
  107ad9:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	list->head = (sys_dnode_t *)list;
  107ae0:	89 50 18             	mov    %edx,0x18(%eax)
	list->tail = (sys_dnode_t *)list;
  107ae3:	89 50 1c             	mov    %edx,0x1c(%eax)
	t->delta_ticks_from_prev = _INACTIVE;
  107ae6:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	t->wait_q = NULL;
  107aed:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	t->thread = NULL;
  107af4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	t->func = func;
  107afb:	c7 40 14 52 7a 10 00 	movl   $0x107a52,0x14(%eax)
	_init_timeout(&timer->timeout, _timer_expiration_handler);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = 0;
  107b02:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
}
  107b09:	5d                   	pop    %ebp
  107b0a:	c3                   	ret    

00107b0b <k_timer_start>:


void k_timer_start(struct k_timer *timer, int32_t duration, int32_t period)
{
  107b0b:	55                   	push   %ebp
  107b0c:	b9 0a 00 00 00       	mov    $0xa,%ecx
  107b11:	89 e5                	mov    %esp,%ebp
  107b13:	56                   	push   %esi
  107b14:	53                   	push   %ebx
  107b15:	31 d2                	xor    %edx,%edx
  107b17:	83 ec 08             	sub    $0x8,%esp
  107b1a:	8b 45 10             	mov    0x10(%ebp),%eax
  107b1d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  107b20:	83 c0 09             	add    $0x9,%eax
  107b23:	f7 f1                	div    %ecx
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile int32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = _ms_to_ticks(period);
  107b25:	89 45 f0             	mov    %eax,-0x10(%ebp)
  107b28:	8b 45 0c             	mov    0xc(%ebp),%eax
  107b2b:	83 c0 09             	add    $0x9,%eax
  107b2e:	31 d2                	xor    %edx,%edx
  107b30:	f7 f1                	div    %ecx
	duration_in_ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  107b32:	40                   	inc    %eax
  107b33:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__asm__ volatile (
  107b36:	9c                   	pushf  
  107b37:	fa                   	cli    
  107b38:	5e                   	pop    %esi

	unsigned int key = irq_lock();

	if (timer->timeout.delta_ticks_from_prev != _INACTIVE) {
  107b39:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  107b3d:	74 07                	je     107b46 <k_timer_start+0x3b>
		_abort_timeout(&timer->timeout);
  107b3f:	89 d8                	mov    %ebx,%eax
  107b41:	e8 60 fe ff ff       	call   1079a6 <_abort_timeout>
	}

	timer->period = period_in_ticks;
  107b46:	8b 45 f0             	mov    -0x10(%ebp),%eax
	_add_timeout(NULL, &timer->timeout, &timer->wait_q, duration_in_ticks);
  107b49:	8d 53 18             	lea    0x18(%ebx),%edx
	timer->period = period_in_ticks;
  107b4c:	89 43 28             	mov    %eax,0x28(%ebx)
	_add_timeout(NULL, &timer->timeout, &timer->wait_q, duration_in_ticks);
  107b4f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  107b52:	89 d8                	mov    %ebx,%eax
  107b54:	e8 81 fe ff ff       	call   1079da <_add_timeout.constprop.7>
	timer->status = 0;
  107b59:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  107b60:	0f ba e6 09          	bt     $0x9,%esi
  107b64:	73 01                	jae    107b67 <k_timer_start+0x5c>
	__asm__ volatile (
  107b66:	fb                   	sti    
	irq_unlock(key);
}
  107b67:	58                   	pop    %eax
  107b68:	5a                   	pop    %edx
  107b69:	5b                   	pop    %ebx
  107b6a:	5e                   	pop    %esi
  107b6b:	5d                   	pop    %ebp
  107b6c:	c3                   	ret    

00107b6d <k_timer_stop>:


void k_timer_stop(struct k_timer *timer)
{
  107b6d:	55                   	push   %ebp
  107b6e:	89 e5                	mov    %esp,%ebp
  107b70:	56                   	push   %esi
  107b71:	53                   	push   %ebx
  107b72:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ volatile (
  107b75:	9c                   	pushf  
  107b76:	fa                   	cli    
  107b77:	5e                   	pop    %esi
	int key = irq_lock();
	int inactive = (_abort_timeout(&timer->timeout) == _INACTIVE);
  107b78:	89 d8                	mov    %ebx,%eax
  107b7a:	e8 27 fe ff ff       	call   1079a6 <_abort_timeout>
  107b7f:	0f ba e6 09          	bt     $0x9,%esi
  107b83:	73 01                	jae    107b86 <k_timer_stop+0x19>
	__asm__ volatile (
  107b85:	fb                   	sti    

	irq_unlock(key);

	if (inactive) {
  107b86:	40                   	inc    %eax
  107b87:	74 75                	je     107bfe <k_timer_stop+0x91>
		return;
	}

	if (timer->stop_fn) {
  107b89:	8b 43 24             	mov    0x24(%ebx),%eax
  107b8c:	85 c0                	test   %eax,%eax
  107b8e:	74 04                	je     107b94 <k_timer_stop+0x27>
		timer->stop_fn(timer);
  107b90:	53                   	push   %ebx
  107b91:	ff d0                	call   *%eax
  107b93:	58                   	pop    %eax
	__asm__ volatile (
  107b94:	9c                   	pushf  
  107b95:	fa                   	cli    
  107b96:	5e                   	pop    %esi
	if (_handling_timeouts) {
  107b97:	a1 90 9b 10 00       	mov    0x109b90,%eax
	}

	key = irq_lock();
	struct k_thread *pending_thread = _unpend_first_thread(&timer->wait_q);
  107b9c:	8d 53 18             	lea    0x18(%ebx),%edx
  107b9f:	85 c0                	test   %eax,%eax
  107ba1:	8b 43 18             	mov    0x18(%ebx),%eax
  107ba4:	74 1b                	je     107bc1 <k_timer_stop+0x54>
	return sys_dlist_is_empty(list) ? NULL : list->head;
  107ba6:	39 c2                	cmp    %eax,%edx
  107ba8:	75 11                	jne    107bbb <k_timer_stop+0x4e>
  107baa:	31 c0                	xor    %eax,%eax
  107bac:	eb 0d                	jmp    107bbb <k_timer_stop+0x4e>
			if (_is_thread_timeout_expired(thread)) {
  107bae:	83 78 20 fe          	cmpl   $0xfffffffe,0x20(%eax)
  107bb2:	75 15                	jne    107bc9 <k_timer_stop+0x5c>
	return (node == list->tail) ? NULL : node->next;
  107bb4:	3b 43 1c             	cmp    0x1c(%ebx),%eax
  107bb7:	74 25                	je     107bde <k_timer_stop+0x71>
  107bb9:	8b 00                	mov    (%eax),%eax
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  107bbb:	85 c0                	test   %eax,%eax
  107bbd:	75 ef                	jne    107bae <k_timer_stop+0x41>
  107bbf:	eb 1d                	jmp    107bde <k_timer_stop+0x71>
	if (thread) {
  107bc1:	85 c0                	test   %eax,%eax
  107bc3:	74 19                	je     107bde <k_timer_stop+0x71>
  107bc5:	39 c2                	cmp    %eax,%edx
  107bc7:	74 15                	je     107bde <k_timer_stop+0x71>
	node->prev->next = node->next;
  107bc9:	8b 50 04             	mov    0x4(%eax),%edx
  107bcc:	8b 08                	mov    (%eax),%ecx
  107bce:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  107bd0:	8b 08                	mov    (%eax),%ecx
  107bd2:	89 51 04             	mov    %edx,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
  107bd5:	80 60 09 fd          	andb   $0xfd,0x9(%eax)

	if (pending_thread) {
		_ready_thread(pending_thread);
  107bd9:	e8 a6 fd ff ff       	call   107984 <_ready_thread>
	}

	if (_is_in_isr()) {
  107bde:	83 3d 60 9a 10 00 00 	cmpl   $0x0,0x109a60
  107be5:	74 09                	je     107bf0 <k_timer_stop+0x83>
  107be7:	0f ba e6 09          	bt     $0x9,%esi
  107beb:	73 11                	jae    107bfe <k_timer_stop+0x91>
	__asm__ volatile (
  107bed:	fb                   	sti    
  107bee:	eb 0e                	jmp    107bfe <k_timer_stop+0x91>
		irq_unlock(key);
	} else {
		_reschedule_threads(key);
  107bf0:	89 75 08             	mov    %esi,0x8(%ebp)
	}
}
  107bf3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  107bf6:	5b                   	pop    %ebx
  107bf7:	5e                   	pop    %esi
  107bf8:	5d                   	pop    %ebp
		_reschedule_threads(key);
  107bf9:	e9 05 f6 ff ff       	jmp    107203 <_reschedule_threads>
}
  107bfe:	8d 65 f8             	lea    -0x8(%ebp),%esp
  107c01:	5b                   	pop    %ebx
  107c02:	5e                   	pop    %esi
  107c03:	5d                   	pop    %ebp
  107c04:	c3                   	ret    

00107c05 <work_q_main>:
#include <kernel_structs.h>
#include <wait_q.h>
#include <errno.h>

static void work_q_main(void *work_q_ptr, void *p2, void *p3)
{
  107c05:	55                   	push   %ebp
  107c06:	89 e5                	mov    %esp,%ebp
  107c08:	56                   	push   %esi
  107c09:	53                   	push   %ebx

	while (1) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_fifo_get(&work_q->fifo, K_FOREVER);
  107c0a:	6a ff                	push   $0xffffffff
  107c0c:	ff 75 08             	pushl  0x8(%ebp)
  107c0f:	e8 d0 f0 ff ff       	call   106ce4 <k_fifo_get>
  107c14:	5a                   	pop    %edx
  107c15:	89 c2                	mov    %eax,%edx
  107c17:	59                   	pop    %ecx

		handler = work->handler;
  107c18:	8b 48 04             	mov    0x4(%eax),%ecx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  107c1b:	8b 40 08             	mov    0x8(%eax),%eax
  107c1e:	89 c6                	mov    %eax,%esi
  107c20:	89 c3                	mov    %eax,%ebx
  107c22:	83 e6 fe             	and    $0xfffffffe,%esi
  107c25:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
  107c2a:	75 f2                	jne    107c1e <work_q_main+0x19>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
  107c2c:	80 e3 01             	and    $0x1,%bl
  107c2f:	74 04                	je     107c35 <work_q_main+0x30>
					       K_WORK_STATE_PENDING)) {
			handler(work);
  107c31:	52                   	push   %edx
  107c32:	ff d1                	call   *%ecx
  107c34:	58                   	pop    %eax
		}

		/* Make sure we don't hog up the CPU if the FIFO never (or
		 * very rarely) gets empty.
		 */
		k_yield();
  107c35:	e8 72 f6 ff ff       	call   1072ac <k_yield>
	while (1) {
  107c3a:	eb ce                	jmp    107c0a <work_q_main+0x5>

00107c3c <k_work_q_start>:
	}
}

void k_work_q_start(struct k_work_q *work_q, char *stack,
		    size_t stack_size, int prio)
{
  107c3c:	55                   	push   %ebp
  107c3d:	89 e5                	mov    %esp,%ebp
  107c3f:	53                   	push   %ebx
  107c40:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_fifo_init(&work_q->fifo);
  107c43:	53                   	push   %ebx
  107c44:	e8 c6 ef ff ff       	call   106c0f <k_fifo_init>

	k_thread_spawn(stack, stack_size,
  107c49:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107c50:	6a 00                	push   $0x0
  107c52:	ff 75 14             	pushl  0x14(%ebp)
  107c55:	6a 00                	push   $0x0
  107c57:	6a 00                	push   $0x0
  107c59:	53                   	push   %ebx
  107c5a:	68 05 7c 10 00       	push   $0x107c05
  107c5f:	ff 75 10             	pushl  0x10(%ebp)
  107c62:	ff 75 0c             	pushl  0xc(%ebp)
  107c65:	e8 b1 fb ff ff       	call   10781b <k_thread_spawn>
  107c6a:	83 c4 24             	add    $0x24,%esp
		       work_q_main, work_q, 0, 0,
		       prio, 0, 0);
}
  107c6d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107c70:	c9                   	leave  
  107c71:	c3                   	ret    

00107c72 <k_delayed_work_cancel>:

	return err;
}

int k_delayed_work_cancel(struct k_delayed_work *work)
{
  107c72:	55                   	push   %ebp
  107c73:	89 e5                	mov    %esp,%ebp
  107c75:	56                   	push   %esi
  107c76:	53                   	push   %ebx
  107c77:	8b 55 08             	mov    0x8(%ebp),%edx
	__asm__ volatile (
  107c7a:	9c                   	pushf  
  107c7b:	fa                   	cli    
  107c7c:	59                   	pop    %ecx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  107c7d:	8b 42 08             	mov    0x8(%edx),%eax
	int key = irq_lock();

	if (k_work_pending(&work->work)) {
  107c80:	83 e0 01             	and    $0x1,%eax
  107c83:	74 07                	je     107c8c <k_delayed_work_cancel+0x1a>
		irq_unlock(key);
		return -EINPROGRESS;
  107c85:	b8 bc ff ff ff       	mov    $0xffffffbc,%eax
  107c8a:	eb 42                	jmp    107cce <k_delayed_work_cancel+0x5c>
	}

	if (!work->work_q) {
  107c8c:	83 7a 24 00          	cmpl   $0x0,0x24(%edx)
  107c90:	75 07                	jne    107c99 <k_delayed_work_cancel+0x27>
		irq_unlock(key);
		return -EINVAL;
  107c92:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  107c97:	eb 35                	jmp    107cce <k_delayed_work_cancel+0x5c>
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  107c99:	8b 72 1c             	mov    0x1c(%edx),%esi
	}

	/* Abort timeout, if it has expired this will do nothing */
	_abort_timeout(&work->timeout);
  107c9c:	8d 5a 0c             	lea    0xc(%edx),%ebx
  107c9f:	83 fe ff             	cmp    $0xffffffff,%esi
  107ca2:	74 23                	je     107cc7 <k_delayed_work_cancel+0x55>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  107ca4:	3b 1d 70 9a 10 00    	cmp    0x109a70,%ebx
  107caa:	74 06                	je     107cb2 <k_delayed_work_cancel+0x40>
	return (node == list->tail) ? NULL : node->next;
  107cac:	8b 5a 0c             	mov    0xc(%edx),%ebx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  107caf:	01 73 10             	add    %esi,0x10(%ebx)
	node->prev->next = node->next;
  107cb2:	8b 5a 10             	mov    0x10(%edx),%ebx
  107cb5:	8b 72 0c             	mov    0xc(%edx),%esi
  107cb8:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
  107cba:	8b 72 0c             	mov    0xc(%edx),%esi
  107cbd:	89 5e 04             	mov    %ebx,0x4(%esi)
	timeout->delta_ticks_from_prev = _INACTIVE;
  107cc0:	c7 42 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%edx)

	/* Detach from workqueue */
	work->work_q = NULL;
  107cc7:	c7 42 24 00 00 00 00 	movl   $0x0,0x24(%edx)
  107cce:	0f ba e1 09          	bt     $0x9,%ecx
  107cd2:	73 01                	jae    107cd5 <k_delayed_work_cancel+0x63>
	__asm__ volatile (
  107cd4:	fb                   	sti    

	irq_unlock(key);

	return 0;
}
  107cd5:	5b                   	pop    %ebx
  107cd6:	5e                   	pop    %esi
  107cd7:	5d                   	pop    %ebp
  107cd8:	c3                   	ret    

00107cd9 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
  107cd9:	55                   	push   %ebp
  107cda:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
  107cdc:	9c                   	pushf  
  107cdd:	fa                   	cli    
  107cde:	58                   	pop    %eax
	k_cpu_idle();
  107cdf:	e8 30 ea ff ff       	call   106714 <k_cpu_idle>
  107ce4:	eb f6                	jmp    107cdc <idle+0x3>

00107ce6 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
  107ce6:	55                   	push   %ebp
  107ce7:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
  107ce9:	5d                   	pop    %ebp
  107cea:	c3                   	ret    

00107ceb <_handle_exc_0_vector_0_stub>:
  107ceb:	6a 00                	push   $0x0
  107ced:	68 02 6a 10 00       	push   $0x106a02
  107cf2:	e9 a0 ea ff ff       	jmp    106797 <_exception_enter>

00107cf7 <_handle_exc_2_vector_2_stub>:
  107cf7:	6a 00                	push   $0x0
  107cf9:	68 0f 6a 10 00       	push   $0x106a0f
  107cfe:	e9 94 ea ff ff       	jmp    106797 <_exception_enter>

00107d03 <_handle_exc_4_vector_4_stub>:
  107d03:	6a 00                	push   $0x0
  107d05:	68 1f 6a 10 00       	push   $0x106a1f
  107d0a:	e9 88 ea ff ff       	jmp    106797 <_exception_enter>

00107d0f <_handle_exc_5_vector_5_stub>:
  107d0f:	6a 00                	push   $0x0
  107d11:	68 2f 6a 10 00       	push   $0x106a2f
  107d16:	e9 7c ea ff ff       	jmp    106797 <_exception_enter>

00107d1b <_handle_exc_6_vector_6_stub>:
  107d1b:	6a 00                	push   $0x0
  107d1d:	68 3f 6a 10 00       	push   $0x106a3f
  107d22:	e9 70 ea ff ff       	jmp    106797 <_exception_enter>

00107d27 <_handle_exc_7_vector_7_stub>:
  107d27:	6a 00                	push   $0x0
  107d29:	68 4f 6a 10 00       	push   $0x106a4f
  107d2e:	e9 64 ea ff ff       	jmp    106797 <_exception_enter>

00107d33 <_handle_exc_8_vector_8_stub>:
  107d33:	68 5f 6a 10 00       	push   $0x106a5f
  107d38:	e9 5a ea ff ff       	jmp    106797 <_exception_enter>

00107d3d <_handle_exc_10_vector_10_stub>:
  107d3d:	68 6f 6a 10 00       	push   $0x106a6f
  107d42:	e9 50 ea ff ff       	jmp    106797 <_exception_enter>

00107d47 <_handle_exc_11_vector_11_stub>:
  107d47:	68 7f 6a 10 00       	push   $0x106a7f
  107d4c:	e9 46 ea ff ff       	jmp    106797 <_exception_enter>

00107d51 <_handle_exc_12_vector_12_stub>:
  107d51:	68 8f 6a 10 00       	push   $0x106a8f
  107d56:	e9 3c ea ff ff       	jmp    106797 <_exception_enter>

00107d5b <_handle_exc_13_vector_13_stub>:
  107d5b:	68 9f 6a 10 00       	push   $0x106a9f
  107d60:	e9 32 ea ff ff       	jmp    106797 <_exception_enter>

00107d65 <_handle_exc_14_vector_14_stub>:
  107d65:	68 af 6a 10 00       	push   $0x106aaf
  107d6a:	e9 28 ea ff ff       	jmp    106797 <_exception_enter>

00107d6f <_handle_exc_16_vector_16_stub>:
  107d6f:	6a 00                	push   $0x0
  107d71:	68 bf 6a 10 00       	push   $0x106abf
  107d76:	e9 1c ea ff ff       	jmp    106797 <_exception_enter>

00107d7b <_handle_exc_17_vector_17_stub>:
  107d7b:	68 cf 6a 10 00       	push   $0x106acf
  107d80:	e9 12 ea ff ff       	jmp    106797 <_exception_enter>

00107d85 <_handle_exc_18_vector_18_stub>:
  107d85:	6a 00                	push   $0x0
  107d87:	68 df 6a 10 00       	push   $0x106adf
  107d8c:	e9 06 ea ff ff       	jmp    106797 <_exception_enter>
